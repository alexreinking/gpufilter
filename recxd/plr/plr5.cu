/*
PLR - Parallelized Linear Recurrences [float]
Copyright (c) 2018 Texas State University. All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted for academic, research, experimental, or personal use provided that the following conditions are met:
* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
* Neither the name of Texas State University nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

For all other uses, please contact the Office for Commercialization and Industry Relations at Texas State University http://www.txstate.edu/ocir/.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Authors: Sepideh Maleki and Martin Burtscher


non-recursive coefficients: (0.208500)
recursive coefficients: (-0.008670, -0.173600, -0.113390, -0.376700, -0.119000)

*/

#include <cstdio>
#include <cassert>
#include <cuda.h>

typedef float T;
static const int device = 0;
static const int order = 5;
static const int warp_size = 32;
static const int block_size = 1024;

static __device__ const T facA[530] = {-1.190000e-01f, 1.031730e-03f, 2.064946e-02f, 1.313527e-02f, 4.101168e-02f, 8.795053e-03f, -1.658672e-02f, -1.343867e-02f, -1.501350e-02f, -3.849599e-03f, 9.365137e-03f, 9.325642e-03f, 5.984654e-03f, 5.040193e-04f, -5.170485e-03f, -5.348690e-03f, -2.477352e-03f, 6.342548e-04f, 2.918801e-03f, 2.775634e-03f, 9.670259e-04f, -7.653160e-04f, -1.650958e-03f, -1.355397e-03f, -3.094423e-04f, 5.984004e-04f, 9.152081e-04f, 6.303126e-04f, 4.566160e-05f, -4.021874e-04f, -4.918795e-04f, -2.774418e-04f, 4.119181e-05f, 2.496513e-04f, 2.552951e-04f, 1.128224e-04f, -5.610673e-05f, -1.469929e-04f, -1.276565e-04f, -3.989362e-05f, 4.688412e-05f, 8.304295e-05f, 6.124484e-05f, 9.955615e-06f, -3.304857e-05f, -4.524781e-05f, -2.795238e-05f, 8.063275e-07f, 2.124087e-05f, 2.382301e-05f, 1.192876e-05f, -3.625010e-06f, -1.283808e-05f, -1.211379e-05f, -4.583746e-06f, 3.544424e-06f, 7.406073e-06f, 5.931224e-06f, 1.429217e-06f, -2.671545e-06f, -4.109145e-06f, -2.778267e-06f, -2.038402e-07f, 1.786304e-06f, 2.200756e-06f, 1.229492e-06f, -1.878596e-07f, -1.109999e-06f, -1.138771e-06f, -5.011693e-07f, 2.523557e-07f, 6.544321e-07f, 5.684096e-07f, 1.771521e-07f, -2.098411e-07f, -3.699412e-07f, -2.724488e-07f, -4.399615e-08f, 1.475922e-07f, 2.015790e-07f, 1.242735e-07f, -3.812300e-09f, -9.476033e-08f, -1.061063e-07f, -5.299912e-08f, 1.627198e-08f, 5.724084e-08f, 5.393520e-08f, 2.034171e-08f, -1.585281e-08f, -3.300858e-08f, -2.639736e-08f, -6.324306e-09f, 1.193135e-08f, 1.830847e-08f, 1.235900e-08f, 8.852545e-10f, -7.971141e-09f, -9.802588e-09f, -5.465945e-09f, 8.487697e-10f, 4.950428e-09f, 5.070718e-09f, 2.225930e-09f, -1.130189e-09f, -2.917421e-09f, -2.530144e-09f, -7.853705e-10f, 9.377050e-10f, 1.648589e-09f, 1.212253e-09f, 1.939046e-10f, -6.588361e-10f, -8.980173e-10f, -5.526648e-10f, 1.809086e-11f, 4.227209e-10f, 4.725457e-10f, 2.355203e-10f, -7.305594e-11f, -2.552266e-10f, -2.401221e-10f, -9.028042e-11f, 7.090133e-11f, 1.471229e-10f, 1.174788e-10f, 2.798458e-11f, -5.328438e-11f, -8.157554e-11f, -5.497765e-11f, -3.841687e-12f, 3.556934e-11f, 4.366280e-11f, 2.429979e-11f, -3.834245e-12f, -2.207793e-11f, -2.257884e-11f, -9.886350e-12f, 5.061504e-12f, 1.300564e-11f, 1.126230e-11f, 3.481724e-12f, -4.190224e-12f, -7.346673e-12f, -5.393854e-12f, -8.545026e-13f, 2.940953e-12f, 4.000581e-12f, 2.457776e-12f, -8.552474e-14f, -1.885726e-12f, -2.104483e-12f, -1.046608e-12f, 3.279767e-13f, 1.138005e-12f, 1.069032e-12f, 4.006753e-13f, -3.170987e-13f, -6.557414e-13f, -5.228259e-13f, -1.238238e-13f, 2.379614e-13f, 3.634684e-13f, 2.445608e-13f, 1.665980e-14f, -1.587189e-13f, -1.944828e-13f, -1.080281e-13f, 1.731747e-14f, 9.846283e-14f, 1.005385e-13f, 4.390919e-14f, -2.266703e-14f, -5.797790e-14f, -5.013114e-14f, -1.543486e-14f, 1.872418e-14f, 3.273918e-14f, 2.399956e-14f, 3.765186e-15f, -1.312791e-14f, -1.782215e-14f, -1.093001e-14f, 4.029696e-16f, 8.412038e-15f, 9.372293e-15f, 4.650890e-15f, -1.472322e-15f, -5.074122e-15f, -4.759352e-15f, -1.778215e-15f, 1.418163e-15f, 2.922694e-15f, 2.326768e-15f, 5.478585e-16f, -1.062695e-15f, -1.619467e-15f, -1.087891e-15f, -7.219311e-17f, 7.082374e-16f, 8.662623e-16f, 4.802506e-16f, -7.819979e-17f, -4.391211e-16f, -4.476742e-16f, -1.950158e-16f, 1.015070e-16f, 2.584591e-16f, 2.231447e-16f, 6.842265e-17f, -8.366864e-17f, -1.458960e-16f, -1.067839e-16f, -1.658848e-17f, 5.860034e-17f, 7.939553e-17f, 4.860671e-17f, -1.893013e-18f, -3.752509e-17f, -4.173928e-17f, -2.066733e-17f, 6.608993e-18f, 2.262434e-17f, 2.118867e-17f, 7.891675e-18f, -6.342342e-18f, -1.302665e-17f, -1.035493e-17f, -2.423885e-18f, 4.745774e-18f, 7.215664e-18f, 4.839293e-18f, 3.125955e-19f, -3.160286e-18f, -3.858482e-18f, -2.134992e-18f, 3.530572e-19f, 1.958368e-18f, 1.993381e-18f, 8.661224e-19f, -4.545522e-19f, -1.152178e-18f, -9.932625e-19f, -3.033092e-19f, 3.738668e-19f, 6.501565e-19f, 4.751233e-19f, 7.307558e-20f, -2.615781e-19f, -3.536964e-19f, -2.161571e-19f, 8.868856e-21f, 1.673941e-19f, 1.858843e-19f, 9.183939e-20f, -2.966478e-20f, -1.008763e-19f, -9.433179e-20f, -3.502246e-20f, 2.836385e-20f, 5.806048e-20f, 4.608292e-20f, 1.072343e-20f, -2.119343e-20f, -3.214986e-20f, -2.152664e-20f, -1.352409e-21f, 1.410170e-20f, 1.718630e-20f, 9.491209e-21f, -1.593699e-21f, -8.733785e-21f, -8.876001e-21f, -3.846658e-21f, 2.035441e-21f, 5.136250e-21f, 4.421199e-21f, 1.344497e-21f, -1.670574e-21f, -2.897283e-21f, -2.114001e-21f, -3.218715e-22f, 1.167614e-21f, 1.575665e-21f, 9.612590e-22f, -4.145029e-23f, -7.467176e-22f, -8.278266e-22f, -4.081030e-22f, 1.331437e-22f, 4.497807e-22f, 4.199631e-22f, 1.554236e-22f, -1.268447e-22f, -2.587779e-22f, -2.050837e-22f, -4.743884e-23f, 9.464366e-23f, 1.432454e-22f, 9.575661e-23f, 5.845911e-24f, -6.292367e-23f, -7.655029e-23f, -4.219335e-23f, 7.192672e-24f, 3.895013e-23f, 3.952237e-23f, 1.708374e-23f, -9.114226e-24f, -2.289660e-23f, -1.967952e-23f, -5.959674e-24f, 7.464645e-24f, 1.291108e-23f, 9.405939e-24f, 1.417543e-24f, -5.211880e-24f, -7.019336e-24f, -4.274732e-24f, 1.932986e-25f, 3.330968e-24f, 3.686674e-24f, 1.813455e-24f, -5.975502e-25f, -2.005445e-24f, -1.869661e-24f, -6.897311e-25f, 5.672466e-25f, 1.153380e-24f, 9.126841e-25f, 2.098515e-25f, -4.226469e-25f, -6.382357e-25f, -4.259504e-25f, -2.524586e-26f, 2.807722e-25f, 3.409653e-25f, 1.875700e-25f, -3.245634e-26f, -1.737054e-25f, -1.759816e-25f, -7.587122e-26f, 4.081015e-26f, 1.020691e-25f, 8.759669e-26f, 2.641638e-26f, -3.335394e-26f, -5.753514e-26f, -4.185018e-26f, -6.242112e-27f, 2.326410e-26f, 3.126993e-26f, 1.900968e-26f, -8.996154e-28f, -1.485875e-26f, -1.641832e-26f, -8.058236e-27f, 2.681653e-27f, 8.941680e-27f, 8.323638e-27f, 3.060804e-27f, -2.536667e-27f, -5.140627e-27f, -4.061705e-27f, -9.282572e-28f, 1.887382e-27f, 2.843676e-27f, 1.894730e-27f, 1.089175e-28f, -1.252828e-27f, -1.518701e-27f, -8.338343e-28f, 1.464319e-28f, 7.746688e-28f, 7.835927e-28f, 3.369506e-28f, -1.827274e-28f, -4.550051e-28f, -3.899054e-28f, -1.170880e-28f, 1.490320e-28f, 2.563907e-28f, 1.862047e-28f, 2.748324e-29f, -1.038425e-28f, -1.393017e-28f, -8.453534e-29f, 4.179099e-30f, 6.628147e-29f, 7.311753e-29f, 3.580711e-29f, -1.203387e-29f, -3.986813e-29f, -3.705630e-29f, -1.358262e-29f, 1.134349e-29f, 2.291176e-29f, 1.807568e-29f, 4.105837e-30f, -8.428262e-30f, -1.267004e-29f, -8.428173e-30f, -4.694027e-31f, 5.590188e-30f, 6.764458e-30f, 3.706749e-30f, -6.605423e-31f, -3.454751e-30f, -3.489089e-30f, -1.496409e-30f, 8.181373e-31f, 2.028320e-30f, 1.735519e-30f, 5.189668e-31f, -6.658965e-31f, -1.142536e-30f, -8.284803e-31f, -1.209883e-31f, 4.635115e-31f, 6.205615e-31f, 3.759234e-31f, -1.938082e-32f, -2.956649e-31f, -3.256214e-31f, -1.591090e-31f, 5.399866e-32f, 1.777587e-31f, 1.649717e-31f, 6.027319e-32f, -5.072504e-32f, -1.021173e-31f, -8.044129e-32f, -1.815984e-32f, 3.763675e-32f, 5.645135e-32f, 3.749017e-32f, 2.020701e-33f, -2.494357e-32f, -3.012954e-32f, -1.647796e-32f, 2.979176e-33f, 1.540691e-32f, 1.553576e-32f, 6.645519e-33f, -3.662992e-33f, -9.041809e-33f, -7.724990e-33f, -2.300142e-33f, 2.975284e-33f, 5.091391e-33f, 3.686141e-33f, 5.325455e-34f, -2.068917e-33f, -2.764470e-33f, -1.671698e-33f, 8.973935e-35f, 1.318880e-33f, 1.450117e-33f, 7.069950e-34f, -2.422905e-34f, -7.925637e-34f, -7.344389e-34f, -2.674590e-34f, 2.268247e-34f, 4.551337e-34f, 3.579826e-34f, 8.031548e-35f, -1.680670e-34f, -2.515183e-34f, -1.667629e-34f, -8.688255e-36f, 1.112983e-34f, 1.341995e-34f, 7.325051e-35f, -1.343458e-35f, -6.870887e-35f, -6.917537e-35f, -2.951225e-35f, 1.639961e-35f, 4.030629e-35f, 3.438468e-35f, 1.019430e-35f, -1.329367e-35f, -2.268829e-35f, -1.640060e-35f, -2.343719e-36f, 9.234695e-36f, 1.231509e-35f, 7.433852e-36f, -4.149232e-37f, -5.883134e-36f, -6.457912e-36f, -3.141478e-36f, 1.087092e-36f, 3.533751e-36f, 3.269644e-36f, 1.186814e-36f, -1.014264e-36f, -2.028510e-36f, -1.593101e-36f, -3.551915e-37f, 7.504968e-37f, 1.120633e-36f, 7.417869e-37f, 3.730758e-38f, -4.966107e-37f, -5.977339e-37f, -3.256228e-37f, 6.057404e-38f, 3.064136e-37f, 3.080132e-37f, 1.310601e-37f, -7.342074e-38f, -1.796754e-37f, -1.530491e-37f, -4.518015e-38f, 5.939587e-38f, 1.011033e-37f, 7.297025e-38f, 0.000000e+00f, -4.121915e-38f, -5.486082e-38f, -3.305731e-38f, 0.000000e+00f, 2.624280e-38f, 2.875940e-38f, 1.395879e-38f, 0.000000e+00f, -1.575564e-38f, -1.455606e-38f};

static __device__ const T facB[538] = {-3.767000e-01f, -1.157340e-01f, 6.639854e-02f, 6.222976e-02f, 1.429597e-01f, 6.885283e-02f, -4.371097e-02f, -5.912745e-02f, -6.096461e-02f, -2.719958e-02f, 2.579618e-02f, 3.888589e-02f, 2.827034e-02f, 7.580149e-03f, -1.586339e-02f, -2.210201e-02f, -1.319086e-02f, -4.695889e-04f, 9.873854e-03f, 1.170520e-02f, 5.836799e-03f, -1.455617e-03f, -5.991500e-03f, -5.941530e-03f, -2.334951e-03f, 1.584822e-03f, 3.495534e-03f, 2.910492e-03f, 7.748567e-04f, -1.227481e-03f, -1.959255e-03f, -1.370134e-03f, -1.470472e-04f, 8.314743e-04f, 1.057800e-03f, 6.124396e-04f, -6.478607e-05f, -5.214195e-04f, -5.510955e-04f, -2.539417e-04f, 1.085202e-04f, 3.097604e-04f, 2.769163e-04f, 9.275981e-05f, -9.466113e-05f, -1.762826e-04f, -1.337324e-04f, -2.539992e-05f, 6.804526e-05f, 9.665371e-05f, 6.158406e-05f, 4.536323e-07f, -4.426455e-05f, -5.118484e-05f, -2.662385e-05f, 6.636287e-06f, 2.698869e-05f, 2.618164e-05f, 1.045548e-05f, -7.027680e-06f, -1.567923e-05f, -1.290388e-05f, -3.423534e-06f, 5.450789e-06f, 8.752900e-06f, 6.092770e-06f, 6.348142e-07f, -3.701612e-06f, -4.714831e-06f, -2.725246e-06f, 2.976741e-07f, 2.323991e-06f, 2.453759e-06f, 1.129193e-06f, -4.871097e-07f, -1.380907e-06f, -1.232391e-06f, -4.117207e-07f, 4.232139e-07f, 7.857000e-07f, 5.949726e-07f, 1.122055e-07f, -3.037805e-07f, -4.306447e-07f, -2.738775e-07f, -1.489447e-09f, 1.974705e-07f, 2.279752e-07f, 1.183278e-07f, -2.984109e-08f, -1.203430e-07f, -1.165707e-07f, -4.641726e-08f, 3.144492e-08f, 6.988765e-08f, 5.743148e-08f, 1.516132e-08f, -2.434776e-08f, -3.900169e-08f, -2.710530e-08f, -2.779127e-09f, 1.651958e-08f, 2.100202e-08f, 1.211701e-08f, -1.351734e-09f, -1.036542e-08f, -1.092671e-08f, -5.016272e-09f, 2.182977e-09f, 6.156389e-09f, 5.486032e-09f, 1.826067e-09f, -1.891671e-09f, -3.501552e-09f, -2.647504e-09f, -4.953976e-10f, 1.356233e-09f, 1.918586e-09f, 1.218096e-09f, 4.258482e-12f, -8.809877e-10f, -1.015344e-09f, -5.259090e-10f, 1.341610e-10f, 5.366259e-10f, 5.190077e-10f, 2.060654e-10f, -1.406896e-10f, -3.115156e-10f, -2.556099e-10f, -6.713872e-11f, 1.087547e-10f, 1.737860e-10f, 1.205849e-10f, 1.216232e-11f, -7.372298e-11f, -9.355231e-11f, -5.387455e-11f, 6.136072e-12f, 4.623145e-11f, 4.865698e-11f, 2.228386e-11f, -9.782624e-12f, -2.744646e-11f, -2.442117e-11f, -8.098824e-12f, 8.455221e-12f, 1.560498e-11f, 1.178079e-11f, 2.187045e-12f, -6.054877e-12f, -8.547565e-12f, -5.417571e-12f, -8.383376e-15f, 3.930385e-12f, 4.522075e-12f, 2.337389e-12f, -6.031148e-13f, -2.392878e-12f, -2.310771e-12f, -9.147960e-13f, 6.294538e-13f, 1.388538e-12f, 1.137637e-12f, 2.972983e-13f, -4.857721e-13f, -7.743631e-13f, -5.364507e-13f, -5.320890e-14f, 3.290061e-13f, 4.167222e-13f, 2.395351e-13f, -2.784432e-14f, -2.061988e-13f, -2.166704e-13f, -9.899091e-14f, 4.383738e-14f, 1.223616e-13f, 1.087109e-13f, 3.591844e-14f, -3.779183e-14f, -6.954476e-14f, -5.242160e-14f, -9.654393e-15f, 2.703166e-14f, 3.808046e-14f, 2.409490e-14f, -9.810759e-18f, -1.753469e-14f, -2.014007e-14f, -1.038838e-14f, 2.711044e-15f, 1.067009e-14f, 1.028818e-14f, 4.061040e-15f, -2.816152e-15f, -6.189193e-15f, -5.063236e-15f, -1.316422e-15f, 2.169764e-15f, 3.450430e-15f, 2.386518e-15f, 2.327059e-16f, -1.468257e-15f, -1.856254e-15f, -1.065006e-15f, 1.263091e-16f, 9.196711e-16f, 9.648338e-16f, 4.397398e-16f, -1.964342e-16f, -5.455092e-16f, -4.839254e-16f, -1.592955e-16f, 1.689135e-16f, 3.099305e-16f, 2.332623e-16f, 4.261431e-17f, -1.206804e-16f, -1.696527e-16f, -1.071627e-16f, 2.537294e-19f, 7.822736e-17f, 8.969804e-17f, 4.617013e-17f, -1.218530e-17f, -4.757879e-17f, -4.580566e-17f, -1.802785e-17f, 1.259908e-17f, 2.758729e-17f, 2.253467e-17f, 5.828828e-18f, -9.691435e-18f, -1.537449e-17f, -1.061690e-17f, -1.017374e-18f, 6.552361e-18f, 8.268507e-18f, 4.735131e-18f, -5.727834e-19f, -4.101826e-18f, -4.296396e-18f, -1.953402e-18f, 8.801832e-19f, 2.431967e-18f, 2.154181e-18f, 7.064476e-19f, -7.549616e-19f, -1.381220e-18f, -1.037952e-18f, -1.880824e-19f, 5.387624e-19f, 7.558194e-19f, 4.766062e-19f, -2.065819e-21f, -3.489933e-19f, -3.994879e-19f, -2.051970e-19f, 5.476457e-20f, 2.121569e-19f, 2.039381e-19f, 8.002843e-20f, -5.636533e-20f, -1.229653e-19f, -1.002934e-19f, -2.580775e-20f, 4.328717e-20f, 6.850570e-20f, 4.723115e-20f, 4.446284e-21f, -2.924089e-20f, -3.683117e-20f, -2.105277e-20f, 2.596621e-21f, 1.829447e-20f, 1.913176e-20f, 8.677266e-21f, -3.943781e-21f, -1.084206e-20f, -9.589249e-21f, -3.132900e-21f, 3.374265e-21f, 6.155454e-21f, 4.618574e-21f, 8.300464e-22f, -2.405218e-21f, -3.367240e-21f, -2.119695e-21f, 1.336944e-23f, 1.556945e-21f, 1.779193e-21f, 9.119636e-22f, -2.461092e-22f, -9.460180e-22f, -9.079794e-22f, -3.552534e-22f, 2.521599e-22f, 5.480935e-22f, 4.463672e-22f, 1.142621e-22f, -1.933418e-22f, -3.052471e-22f, -2.101152e-22f, -1.942460e-23f, 1.304910e-22f, 1.640600e-22f, 9.360172e-23f, -1.176776e-23f, -8.159445e-23f, -8.519302e-23f, -3.854514e-23f, 1.767000e-23f, 4.833527e-23f, 4.268601e-23f, 1.389323e-23f, -1.508090e-23f, -2.743191e-23f, -2.055119e-23f, -3.662835e-24f, 1.073763e-23f, 1.500130e-23f, 9.427247e-24f, -7.811735e-26f, -6.945878e-24f, -7.923941e-24f, -4.053036e-24f, 1.105913e-24f, 4.218322e-24f, 4.042522e-24f, 1.576979e-24f, -1.128056e-24f, -2.443011e-24f, -1.986601e-24f, -5.058672e-25f, 8.635511e-25f, 1.360113e-24f, 9.347264e-25f, 8.482790e-26f, -5.823287e-25f, -7.307831e-25f, -4.161554e-25f, 5.331515e-26f, 3.639146e-25f, 3.793603e-25f, 1.712189e-25f, -7.916702e-26f, -2.154840e-25f, -1.900137e-25f, -6.160985e-26f, 6.740144e-26f, 1.222505e-25f, 9.144591e-26f, 1.616190e-26f, -4.793567e-26f, -6.683168e-26f, -4.192702e-26f, 4.306603e-28f, 3.098694e-26f, 3.529052e-26f, 1.801274e-26f, -4.969129e-27f, -1.880955e-26f, -1.799813e-26f, -7.000141e-27f, 5.046336e-27f, 1.088917e-26f, 8.841526e-27f, 2.239511e-27f, -3.856966e-27f, -6.060343e-27f, -4.158240e-27f, -3.702965e-28f, 2.598681e-27f, 3.255166e-27f, 1.850224e-27f, -2.414814e-28f, -1.623066e-27f, -1.689268e-27f, -7.605525e-28f, 3.546797e-28f, 9.606484e-28f, 8.458299e-28f, 2.732040e-28f, -3.012348e-28f, -5.448083e-28f, -4.069021e-28f, -7.130614e-29f, 2.139961e-28f, 2.977383e-28f, 1.864665e-28f, -2.286675e-30f, -1.382382e-28f, -1.571715e-28f, -8.005266e-29f, 2.232573e-29f, 8.387170e-29f, 8.013111e-29f, 3.107287e-29f, -2.257421e-29f, -4.853583e-29f, -3.934979e-29f, -9.914080e-30f, 1.722659e-29f, 2.700338e-29f, 1.849833e-29f, 1.615768e-30f, -1.159671e-29f, -1.449962e-29f, -8.226035e-30f, 1.093444e-30f, 7.238878e-30f, 7.522183e-30f, 3.378330e-30f, -1.588960e-30f, -4.282648e-30f, -3.765128e-30f, -1.211473e-30f, 1.346279e-30f, 2.427927e-30f, 1.810564e-30f, 3.145719e-31f, -9.553217e-31f, -1.326434e-30f, -8.292879e-31f, 1.182655e-32f, 6.167019e-31f, 6.999841e-31f, 3.557691e-31f, -1.002994e-31f, -3.739821e-31f, -3.567578e-31f, -1.379270e-31f, 1.009811e-31f, 2.163361e-31f, 1.751281e-31f, 4.388675e-32f, -7.693934e-32f, -1.203200e-31f, -8.229123e-32f, -7.047219e-33f, 5.175047e-32f, 6.458606e-32f, 3.657243e-32f, -4.949863e-33f, -3.228526e-32f, -3.349561e-32f, -1.500618e-32f, 7.118262e-33f, 1.909232e-32f, 1.676003e-32f, 5.371933e-33f, -6.016708e-33f, -1.081997e-32f, -8.056305e-33f, -1.387621e-33f, 4.264716e-33f, 5.909292e-33f, 3.688141e-33f, -5.998832e-35f, -2.751188e-33f, -3.117463e-33f, -1.581092e-33f, 4.505656e-34f, 1.667571e-33f, 1.588344e-33f, 6.122245e-34f, -4.517085e-34f, -9.642597e-34f, -7.794135e-34f, -1.942656e-34f, 3.436318e-34f, 5.361129e-34f, 3.660772e-34f, 3.072260e-35f, -2.309357e-34f, -2.876866e-34f, -1.625977e-34f, 2.240153e-35f, 1.439910e-34f, 1.491525e-34f, 6.665516e-35f, -3.188745e-35f, -8.511448e-35f, -7.460512e-35f, -2.381973e-35f, 2.688913e-35f, 4.821868e-35f, 3.584728e-35f, 6.120385e-36f, -1.903826e-35f, -2.632595e-35f, -1.640240e-35f, 2.997654e-37f, 1.227334e-35f, 1.388396e-35f, 7.026555e-36f, -2.023886e-36f, -7.435604e-36f, -7.071541e-36f, -2.717474e-36f, 2.020541e-36f, 4.297912e-36f, 3.468792e-36f, 8.598849e-37f, -1.534736e-36f, -2.388764e-36f, -1.628507e-36f, -1.338726e-37f, 1.030540e-36f, 1.281443e-36f, 7.228896e-37f, -1.013568e-37f, -6.421914e-37f, -6.641591e-37f, -2.960687e-37f, 1.428403e-37f, 3.794431e-37f, 3.320939e-37f, 1.056168e-37f, -1.201680e-37f, -2.148835e-37f, -1.595052e-37f, -2.699248e-38f, 8.498866e-38f, 1.172820e-37f, 7.294656e-38f, 0.000000e+00f, -5.475242e-38f, -6.183351e-38f, -3.122656e-38f, 0.000000e+00f, 3.315481e-38f, 3.148345e-38f, 1.206184e-38f, 0.000000e+00f, -1.915666e-38f, -1.543786e-38f};

static __device__ const T facC[542] = {-1.133900e-01f, -3.757169e-01f, -9.605803e-02f, 7.891458e-02f, 1.013080e-01f, 1.513401e-01f, 5.304806e-02f, -5.651610e-02f, -7.343318e-02f, -6.463273e-02f, -1.827595e-02f, 3.468218e-02f, 4.458841e-02f, 2.875060e-02f, 2.653417e-03f, -2.095993e-02f, -2.446258e-02f, -1.258651e-02f, 2.311611e-03f, 1.251864e-02f, 1.262664e-02f, 5.107563e-03f, -3.028744e-03f, -7.283000e-03f, -6.236385e-03f, -1.764761e-03f, 2.456884e-03f, 4.096132e-03f, 2.954001e-03f, 3.916298e-04f, -1.696172e-03f, -2.223617e-03f, -1.330885e-03f, 9.083468e-05f, 1.074734e-03f, 1.165303e-03f, 5.589779e-04f, -2.048492e-04f, -6.430579e-04f, -5.891084e-04f, -2.092678e-04f, 1.876483e-04f, 3.681180e-04f, 2.864026e-04f, 6.126927e-05f, -1.377758e-04f, -2.029172e-04f, -1.329641e-04f, -5.160418e-06f, 9.074520e-05f, 1.080201e-04f, 5.812995e-05f, -1.177922e-05f, -5.580726e-05f, -5.555249e-05f, -2.324652e-05f, 1.369322e-05f, 3.264030e-05f, 2.754348e-05f, 7.909879e-06f, -1.094311e-05f, -1.832653e-05f, -1.309811e-05f, -1.721441e-06f, 7.547795e-06f, 9.924430e-06f, 5.913767e-06f, -4.228559e-07f, -4.786698e-06f, -5.192374e-06f, -2.484787e-06f, 9.212545e-07f, 2.865604e-06f, 2.622560e-06f, 9.292444e-07f, -8.396108e-07f, -1.640512e-06f, -1.274313e-06f, -2.710864e-07f, 6.152900e-07f, 9.041149e-07f, 5.913400e-07f, 2.191246e-08f, -4.048847e-07f, -4.811453e-07f, -2.583726e-07f, 5.305290e-08f, 2.488630e-07f, 2.473579e-07f, 1.032224e-07f, -6.129355e-08f, -1.454959e-07f, -1.225968e-07f, -3.504839e-08f, 4.889027e-08f, 8.166403e-08f, 5.827500e-08f, 7.565962e-09f, -3.368823e-08f, -4.420996e-08f, -2.629654e-08f, 1.937925e-09f, 2.135125e-08f, 2.312302e-08f, 1.104010e-08f, -4.131621e-09f, -1.277629e-08f, -1.167506e-08f, -4.122772e-09f, 3.753848e-09f, 7.311493e-09f, 5.670795e-09f, 1.198290e-09f, -2.747354e-09f, -4.028162e-09f, -2.630265e-09f, -9.260476e-11f, 1.806502e-09f, 2.143004e-09f, 1.148484e-09f, -2.389363e-10f, -1.109790e-09f, -1.101369e-09f, -4.583501e-10f, 2.743482e-10f, 6.485664e-10f, 5.456730e-10f, 1.552929e-10f, -2.184195e-10f, -3.639014e-10f, -2.592704e-10f, -3.324618e-11f, 1.503591e-10f, 1.969402e-10f, 1.169314e-10f, -8.874814e-12f, -9.523739e-11f, -1.029726e-10f, -4.905165e-11f, 1.852859e-11f, 5.696281e-11f, 5.197456e-11f, 1.829117e-11f, -1.678295e-11f, -3.258603e-11f, -2.523538e-11f, -5.296513e-12f, 1.226720e-11f, 1.794689e-11f, 1.169929e-11f, 3.902167e-13f, -8.060149e-12f, -9.544832e-12f, -5.105055e-12f, 1.075973e-12f, 4.949019e-12f, 4.903861e-12f, 2.035239e-12f, -1.227943e-12f, -2.891056e-12f, -2.428757e-12f, -6.880528e-13f, 9.757872e-13f, 1.621569e-12f, 1.153511e-12f, 1.460618e-13f, -6.710863e-13f, -8.772983e-13f, -5.199495e-13f, 4.061211e-14f, 4.248049e-13f, 4.585614e-13f, 2.179366e-13f, -8.308897e-14f, -2.539665e-13f, -2.313775e-13f, -8.114945e-14f, 7.503313e-14f, 1.452297e-13f, 1.122986e-13f, 2.340942e-14f, -5.477378e-14f, -7.995948e-14f, -5.203762e-14f, -1.638927e-15f, 3.596211e-14f, 4.251209e-14f, 2.269199e-14f, -4.844722e-15f, -2.206967e-14f, -2.183445e-14f, -9.037068e-15f, 5.495952e-15f, 1.288716e-14f, 1.081021e-14f, 3.048442e-15f, -4.359272e-15f, -7.225797e-15f, -5.132025e-15f, -6.415728e-16f, 2.995188e-15f, 3.908040e-15f, 2.312004e-15f, -1.857137e-16f, -1.894827e-15f, -2.042076e-15f, -9.682840e-16f, 3.725837e-16f, 1.132296e-15f, 1.030031e-15f, 3.600154e-16f, -3.354522e-16f, -6.472589e-16f, -4.997318e-16f, -1.034577e-16f, 2.445661e-16f, 3.562457e-16f, 2.314585e-16f, 6.858257e-18f, -1.604519e-16f, -1.893457e-16f, -1.008652e-16f, 2.181149e-17f, 9.841712e-17f, 9.721766e-17f, 4.012678e-17f, -2.459783e-17f, -5.744556e-17f, -4.811527e-17f, -1.350580e-17f, 1.947457e-17f, 3.219844e-17f, 2.283252e-17f, 2.817525e-18f, -1.336801e-17f, -1.740883e-17f, -1.028048e-17f, 8.486718e-19f, 8.451767e-18f, 9.093797e-18f, 4.302008e-18f, -1.670645e-18f, -5.048263e-18f, -4.585406e-18f, -1.597160e-18f, 1.499689e-18f, 2.884691e-18f, 2.223811e-18f, 4.572009e-19f, -1.091984e-18f, -1.587187e-18f, -1.029501e-18f, -2.857968e-20f, 7.158836e-19f, 8.433291e-19f, 4.483398e-19f, -9.818655e-20f, -4.388779e-19f, -4.328592e-19f, -1.781703e-19f, 1.100879e-19f, 2.560673e-19f, 2.141559e-19f, 5.983411e-20f, -8.699956e-20f, -1.434771e-19f, -1.015821e-19f, -1.237085e-20f, 5.966324e-20f, 7.754946e-20f, 4.571257e-20f, -3.875764e-21f, -3.769845e-20f, -4.049648e-20f, -1.911328e-20f, 7.490731e-21f, 2.250724e-20f, 2.041287e-20f, 7.085446e-21f, -6.704477e-21f, -1.285639e-20f, -9.895945e-21f, -2.020330e-21f, 4.875647e-21f, 7.071395e-21f, 4.579077e-21f, 1.185313e-22f, -3.194018e-21f, -3.756103e-21f, -1.992828e-21f, 4.419461e-22f, 1.957109e-21f, 1.927289e-21f, 7.910985e-22f, -4.926874e-22f, -1.141433e-21f, -9.531817e-22f, -2.650715e-22f, 3.886523e-22f, 6.393357e-22f, 4.519375e-22f, 5.430479e-23f, -2.662833e-22f, -3.454512e-22f, -2.032616e-22f, 1.768929e-23f, 1.681502e-22f, 1.803383e-22f, 8.491714e-23f, -3.358494e-23f, -1.003462e-22f, -9.087171e-23f, -3.143239e-23f, 2.997241e-23f, 5.729777e-23f, 4.403671e-23f, 8.927055e-24f, -2.176932e-23f, -3.150511e-23f, -2.036700e-23f, -4.888989e-25f, 1.425050e-23f, 1.672926e-23f, 8.857864e-24f, -1.989019e-24f, -8.727394e-24f, -8.581153e-24f, -3.512531e-24f, 2.204919e-24f, 5.087978e-24f, 4.242480e-24f, 1.174256e-24f, -1.736203e-24f, -2.848880e-24f, -2.010656e-24f, -2.383315e-25f, 1.188442e-24f, 1.538840e-24f, 9.038000e-25f, -8.068844e-26f, -7.500137e-25f, -8.030774e-25f, -3.772691e-25f, 1.505723e-25f, 4.473815e-25f, 4.045313e-25f, 1.394374e-25f, -1.339897e-25f, -2.553612e-25f, -1.959616e-25f, -3.944252e-26f, 9.719718e-26f, 1.403639e-25f, 9.058869e-26f, 2.003650e-27f, -6.357995e-26f, -7.451001e-26f, -3.937178e-26f, 8.950791e-27f, 3.891816e-26f, 3.820702e-26f, 1.559566e-26f, -9.867405e-27f, -2.267977e-26f, -1.888262e-26f, -5.201737e-27f, 7.755949e-27f, 1.269457e-26f, 8.945307e-27f, 1.045747e-27f, -5.304069e-27f, -6.854865e-27f, -4.018711e-27f, 3.678508e-28f, 3.345331e-27f, 3.576231e-27f, 1.676111e-27f, -6.750354e-28f, -1.994590e-27f, -1.800836e-27f, -6.185464e-28f, 5.989829e-28f, 1.138074e-27f, 8.720174e-28f, 1.742571e-28f, -4.339691e-28f, -6.253581e-28f, -4.029199e-28f, -8.149488e-30f, 2.836665e-28f, 3.318572e-28f, 1.749999e-28f, -4.027522e-29f, -1.735475e-28f, -1.701137e-28f, -6.924395e-29f, 4.415732e-29f, 1.010952e-28f, 8.404336e-29f, 2.304195e-29f, -3.464691e-29f, -5.656664e-29f, -3.979706e-29f, -4.587441e-30f, 2.367214e-29f, 3.053537e-29f, 1.786893e-29f, -1.676108e-30f, -1.492131e-29f, -1.592548e-29f, -7.446468e-30f, 3.026138e-30f, 8.892575e-30f, 8.016682e-30f, 2.743827e-30f, -2.677631e-30f, -5.072068e-30f, -3.880411e-30f, -7.698139e-31f, 1.937584e-30f, 2.786127e-30f, 1.792096e-30f, 3.284613e-32f, -1.265591e-30f, -1.478042e-30f, -7.778349e-31f, 1.812047e-31f, 7.738958e-31f, 7.574156e-31f, 3.074355e-31f, -1.976023e-31f, -4.506308e-31f, -3.740614e-31f, -1.020646e-31f, 1.547710e-31f, 2.520587e-31f, 1.770535e-31f, 2.011914e-32f, -1.056484e-31f, -1.360211e-31f, -7.945250e-32f, 7.633334e-33f, 6.655378e-32f, 7.091826e-32f, 3.308213e-32f, -1.356539e-32f, -3.964604e-32f, -3.568731e-32f, -1.217117e-32f, 1.196962e-32f, 2.260467e-32f, 1.726747e-32f, 3.400555e-33f, -8.650844e-33f, -1.241285e-32f, -7.970794e-33f, -1.309203e-34f, 5.646465e-33f, 6.582954e-33f, 3.457272e-33f, -8.151860e-34f, -3.451000e-33f, -3.372312e-33f, -1.364961e-33f, 8.842416e-34f, 2.008676e-33f, 1.664872e-33f, 4.520810e-34f, -6.913687e-34f, -1.123160e-33f, -7.876920e-34f, -8.821457e-35f, 4.715042e-34f, 6.059098e-34f, 3.532759e-34f, -3.474693e-35f, -2.968497e-34f, -3.158074e-34f, -1.469712e-34f, 6.080752e-35f, 1.767546e-34f, 1.588662e-34f, 5.398821e-35f, -5.350607e-35f, -1.007418e-34f, -7.683832e-35f, -1.502041e-35f, 3.862362e-35f, 5.530205e-35f, 3.545191e-35f, 5.146146e-37f, -2.519170e-35f, -2.931931e-35f, -1.536655e-35f, 3.666915e-36f, 1.538883e-35f, 1.501481e-35f, 6.060107e-36f, -3.956760e-36f, -8.953595e-36f, -7.409986e-36f, -2.002359e-36f, 3.088341e-36f, 5.004725e-36f, 3.504340e-36f, 3.866873e-37f, -2.104289e-36f, -2.699035e-36f, -1.570789e-36f, 1.580949e-37f, 1.324032e-36f, 1.406324e-36f, 6.529301e-37f, -2.725612e-37f, -7.880247e-37f, -7.072090e-37f, -2.394730e-37f, 2.391770e-37f, 4.489730e-37f, 3.419207e-37f, 6.634092e-38f, -1.724423e-37f, -2.463823e-37f, -1.576796e-37f, 0.000000e+00f, 1.123922e-37f, 1.305826e-37f, 6.829926e-38f, -1.649310e-38f, -6.862220e-38f, -6.685144e-38f, -2.690509e-38f, 1.770509e-38f, 3.991017e-38f, 3.298012e-38f, 0.000000e+00f, -1.379546e-38f, -2.230066e-38f, -1.559029e-38f, 0.000000e+00f, 0.000000e+00f, 1.202286e-38f};

static __device__ const T facD[540] = {-1.736000e-01f, -1.118849e-01f, -3.455930e-01f, -7.689599e-02f, 1.387434e-01f, 1.141385e-01f, 1.271430e-01f, 3.344341e-02f, -7.841815e-02f, -7.904906e-02f, -5.097065e-02f, -4.671482e-03f, 4.341273e-02f, 4.532368e-02f, 2.120778e-02f, -5.149378e-03f, -2.457395e-02f, -2.353731e-02f, -8.328495e-03f, 6.360771e-03f, 1.392935e-02f, 1.151017e-02f, 2.699106e-03f, -5.006028e-03f, -7.734422e-03f, -5.363424e-03f, -4.296340e-04f, 3.376399e-03f, 4.162744e-03f, 2.367281e-03f, -3.259358e-04f, -2.100911e-03f, -2.163526e-03f, -9.666875e-04f, 4.632651e-04f, 1.239322e-03f, 1.083453e-03f, 3.445413e-04f, -3.910776e-04f, -7.012556e-04f, -5.207128e-04f, -8.812283e-05f, 2.769937e-04f, 3.826414e-04f, 2.381906e-04f, -4.739275e-06f, -1.785534e-04f, -2.017409e-04f, -1.019774e-04f, 2.959314e-05f, 1.081471e-04f, 1.027319e-04f, 3.940146e-05f, -2.945110e-05f, -6.249413e-05f, -5.038180e-05f, -1.244237e-05f, 2.234582e-05f, 3.472527e-05f, 2.364617e-05f, 1.915364e-06f, -1.499611e-05f, -1.862389e-05f, -1.049221e-05f, 1.489072e-06f, 9.341406e-06f, 9.650376e-06f, 4.294475e-06f, -2.084121e-06f, -5.517815e-06f, -4.824232e-06f, -1.530086e-06f, 1.750464e-06f, 3.124037e-06f, 2.316439e-06f, 3.895657e-07f, -1.237065e-06f, -1.704694e-06f, -1.059002e-06f, 2.298168e-08f, 7.965829e-07f, 8.985534e-07f, 4.531014e-07f, -1.328778e-07f, -4.822009e-07f, -4.574073e-07f, -1.748684e-07f, 1.317348e-07f, 2.785380e-07f, 2.242315e-07f, 5.506870e-08f, -9.980261e-08f, -1.547219e-07f, -1.051911e-07f, -8.339583e-09f, 6.691987e-08f, 8.295544e-08f, 4.664651e-08f, -6.734272e-09f, -4.166207e-08f, -4.297175e-08f, -1.907474e-08f, 9.335201e-09f, 2.459849e-08f, 2.147427e-08f, 6.784096e-09f, -7.822649e-09f, -1.392200e-08f, -1.030711e-08f, -1.717774e-09f, 5.522308e-09f, 7.594364e-09f, 4.709670e-09f, -1.117573e-10f, -3.553593e-09f, -4.001770e-09f, -2.013591e-09f, 5.967554e-10f, 2.150084e-09f, 2.036428e-09f, 7.761538e-10f, -5.892317e-10f, -1.241493e-09f, -9.979361e-10f, -2.437238e-10f, 4.457289e-10f, 6.893908e-10f, 4.679405e-10f, 3.628867e-11f, -2.986221e-10f, -3.695057e-10f, -2.073811e-10f, 3.045009e-11f, 1.858082e-10f, 1.913467e-10f, 8.472362e-11f, -4.181333e-11f, -1.096598e-10f, -9.558874e-11f, -3.007873e-11f, 3.495829e-11f, 6.204202e-11f, 4.586176e-11f, 7.573682e-12f, -2.465163e-11f, -3.383260e-11f, -2.094505e-11f, 5.396248e-13f, 1.585266e-11f, 1.782212e-11f, 8.948352e-12f, -2.679851e-12f, -9.586962e-12f, -9.066373e-12f, -3.444906e-12f, 2.635501e-12f, 5.533533e-12f, 4.441271e-12f, 1.078628e-12f, -1.990653e-12f, -3.071693e-12f, -2.081614e-12f, -1.578167e-13f, 1.332558e-12f, 1.645872e-12f, 9.219684e-13f, -1.376541e-13f, -8.286802e-13f, -8.520352e-13f, -3.763097e-13f, 1.872800e-13f, 4.888606e-13f, 4.254942e-13f, 1.333571e-13f, -1.562214e-13f, -2.764833e-13f, -2.040623e-13f, -3.338878e-14f, 1.100443e-13f, 1.507224e-13f, 9.314729e-14f, -2.589949e-15f, -7.071874e-14f, -7.937164e-14f, -3.976596e-14f, 1.203359e-14f, 4.274694e-14f, 4.036424e-14f, 1.528974e-14f, -1.178777e-14f, -2.466377e-14f, -1.976561e-14f, -4.773377e-15f, 8.890295e-15f, 1.368639e-14f, 9.259931e-15f, 6.859275e-16f, -5.946313e-15f, -7.331114e-15f, -4.098833e-15f, 6.221499e-16f, 3.695789e-15f, 3.793961e-15f, 1.671405e-15f, -8.387910e-16f, -2.179320e-15f, -1.893996e-15f, -5.912381e-16f, 6.981123e-16f, 1.232113e-15f, 9.079732e-16f, 1.471791e-16f, -4.912310e-16f, -6.714586e-16f, -4.142443e-16f, 1.236623e-17f, 3.154747e-16f, 3.534842e-16f, 1.767161e-16f, -5.403195e-17f, -1.906019e-16f, -1.797044e-16f, -6.786035e-17f, 5.272200e-17f, 1.099297e-16f, 8.796532e-17f, 2.112321e-17f, -3.970384e-17f, -6.098158e-17f, -4.119204e-17f, -2.979432e-18f, 2.653425e-17f, 3.265446e-17f, 1.822223e-17f, -2.811315e-18f, -1.648259e-17f, -1.689378e-17f, -7.423571e-18f, 3.756661e-18f, 9.715288e-18f, 8.430687e-18f, 2.621184e-18f, -3.119639e-18f, -5.490738e-18f, -4.040001e-18f, -6.486970e-19f, 2.192810e-18f, 2.991296e-18f, 1.842216e-18f, -5.877951e-20f, -1.407319e-18f, -1.574249e-18f, -7.853026e-19f, 2.425926e-19f, 8.498611e-19f, 8.000536e-19f, 3.011792e-19f, -2.357999e-19f, -4.899696e-19f, -3.914815e-19f, -9.347038e-20f, 1.773147e-19f, 2.717110e-19f, 1.832385e-19f, 1.293317e-20f, -1.184031e-19f, -1.454500e-19f, -8.101021e-20f, 1.270091e-20f, 7.350925e-20f, 7.522455e-20f, 3.297154e-20f, -1.682428e-20f, -4.331005e-20f, -3.752714e-20f, -1.162041e-20f, 1.394048e-20f, 2.446863e-20f, 1.797580e-20f, 2.858825e-21f, -9.788432e-21f, -1.332595e-20f, -8.192604e-21f, 2.782857e-22f, 6.277956e-21f, 7.010928e-21f, 3.489749e-21f, -1.089121e-21f, -3.789369e-21f, -3.561871e-21f, -1.336678e-21f, 1.054598e-21f, 2.183845e-21f, 1.742246e-21f, 4.135875e-22f, -7.918683e-22f, -1.210638e-21f, -8.151136e-22f, -5.610186e-23f, 5.283443e-22f, 6.478641e-22f, 3.601431e-22f, -5.736851e-23f, -3.278360e-22f, -3.349585e-22f, -1.464403e-22f, 7.534544e-23f, 1.930724e-22f, 1.670423e-22f, 5.151508e-23f, -6.229389e-23f, -1.090403e-22f, -7.998215e-23f, -1.259741e-23f, 4.369402e-23f, 5.936573e-23f, 3.643352e-23f, -1.312912e-24f, -2.800540e-23f, -3.122313e-23f, -1.550771e-23f, 4.889305e-24f, 1.689601e-23f, 1.585754e-23f, 5.932277e-24f, -4.716524e-24f, -9.733594e-24f, -7.753644e-24f, -1.829954e-24f, 3.536364e-24f, 5.394116e-24f, 3.625914e-24f, 2.431836e-25f, -2.357590e-24f, -2.885710e-24f, -1.601059e-24f, 2.590765e-25f, 1.462074e-24f, 1.491492e-24f, 6.503947e-25f, -3.374146e-25f, -8.606967e-25f, -7.435429e-25f, -2.283684e-25f, 2.783605e-25f, 4.859185e-25f, 3.558739e-25f, 5.550380e-26f, -1.950418e-25f, -2.644674e-25f, -1.620234e-25f, 6.174796e-27f, 1.249290e-25f, 1.390516e-25f, 6.891242e-26f, -2.194779e-26f, -7.533552e-26f, -7.059799e-26f, -2.632746e-26f, 2.109352e-26f, 4.338335e-26f, 3.450649e-26f, 8.096401e-27f, -1.579272e-26f, -2.403394e-26f, -1.612927e-26f, -1.053317e-27f, 1.052003e-26f, 1.285346e-26f, 7.117655e-27f, -1.169770e-27f, -6.520488e-27f, -6.641250e-27f, -2.888607e-27f, 1.510975e-27f, 3.836884e-27f, 3.309665e-27f, 1.012340e-27f, -1.243839e-27f, -2.165401e-27f, -1.583425e-27f, -2.445176e-28f, 8.706232e-28f, 1.178168e-27f, 7.205299e-28f, -2.895958e-29f, -5.572915e-28f, -6.192618e-28f, -3.062271e-28f, 9.851615e-29f, 3.359029e-28f, 3.143020e-28f, 1.168394e-28f, -9.433387e-29f, -1.933622e-28f, -1.535656e-28f, -3.581974e-29f, 7.052657e-29f, 1.070849e-28f, 7.174804e-29f, 4.558599e-30f, -4.694215e-29f, -5.725145e-29f, -3.164196e-29f, 5.280719e-30f, 2.907964e-29f, 2.957177e-29f, 1.282906e-29f, -6.766080e-30f, -1.710431e-29f, -1.473196e-29f, -4.487507e-30f, 5.557958e-30f, 9.649659e-30f, 7.045259e-30f, 1.077068e-30f, -3.886240e-30f, -5.248571e-30f, -3.204231e-30f, 1.354760e-31f, 2.485991e-30f, 2.757855e-30f, 1.360774e-30f, -4.421784e-31f, -1.497704e-30f, -1.399268e-30f, -5.185165e-31f, 4.218696e-31f, 8.618243e-31f, 6.834170e-31f, 1.584643e-31f, -3.149522e-31f, -4.771231e-31f, -3.191562e-31f, -1.971204e-32f, 2.094627e-31f, 2.550067e-31f, 1.406653e-31f, -2.383459e-32f, -1.296869e-31f, -1.316751e-31f, -5.697655e-32f, 3.029730e-32f, 7.624846e-32f, 6.557463e-32f, 1.989173e-32f, -2.483481e-32f, -4.300157e-32f, -3.134691e-32f, -4.743724e-33f, 1.734706e-32f, 2.338157e-32f, 1.424929e-32f, -6.323227e-34f, -1.108957e-32f, -1.228195e-32f, -6.046783e-33f, 1.984548e-33f, 6.677851e-33f, 6.229499e-33f, 2.301063e-33f, -1.886605e-33f, -3.841178e-33f, -3.041416e-33f, -7.010008e-34f, 1.406476e-33f, 2.125844e-33f, 1.419693e-33f, 8.516000e-35f, -9.346469e-34f, -1.135835e-33f, -6.253276e-34f, 1.075590e-34f, 5.783642e-34f, 5.863114e-34f, 2.530419e-34f, -1.356617e-34f, -3.399031e-34f, -2.918834e-34f, -8.817147e-35f, 1.109688e-34f, 1.916264e-34f, 1.394731e-34f, 2.089000e-35f, -7.743170e-35f, -1.041610e-34f, -6.336656e-35f, 2.945147e-36f, 4.946832e-35f, 5.469678e-35f, 2.686947e-35f, -8.906348e-36f, -2.977458e-35f, -2.773345e-35f, -1.021144e-35f, 8.436755e-36f, 1.712020e-35f, 1.353519e-35f, 3.100870e-36f, -6.280816e-36f, -9.471763e-36f, -6.315148e-36f, -3.675532e-37f, 4.170479e-36f, 5.059154e-36f, 2.779875e-36f, -4.853015e-37f, -2.579317e-36f, -2.610669e-36f, -1.123786e-36f, 6.074322e-37f, 1.515226e-36f, 1.299217e-36f, 3.908155e-37f, -4.958330e-37f, -8.539351e-37f, -6.205612e-37f, -9.198111e-38f, 3.456278e-37f, 4.640182e-37f, 2.817894e-37f, -1.369135e-38f, -2.206672e-37f, -2.435875e-37f, -1.193961e-37f, 3.996800e-38f, 1.327556e-37f, 1.234677e-37f, 4.531459e-38f, -3.772784e-38f, -7.630475e-38f, -6.023531e-38f, -1.371596e-38f, 2.804761e-38f, 4.220162e-38f, 2.809121e-38f, 0.000000e+00f, -1.860895e-38f, -2.253405e-38f, -1.235776e-38f};

static __device__ const T facE[541] = {-8.670000e-03f, -1.735248e-01f, -1.103804e-01f, -3.446360e-01f, -7.390800e-02f, 1.393842e-01f, 1.129300e-01f, 1.261639e-01f, 3.234957e-02f, -7.869862e-02f, -7.836674e-02f, -5.029121e-02f, -4.235461e-03f, 4.344945e-02f, 4.494698e-02f, 2.081808e-02f, -5.329869e-03f, -2.452774e-02f, -2.332465e-02f, -8.126270e-03f, 6.431224e-03f, 1.387360e-02f, 1.138989e-02f, 2.600356e-03f, -5.028573e-03f, -7.690824e-03f, -5.296745e-03f, -3.837117e-04f, 3.379726e-03f, 4.133442e-03f, 2.331444e-03f, -3.461494e-04f, -2.097910e-03f, -2.145337e-03f, -9.480875e-04f, 4.714851e-04f, 1.235234e-03f, 1.072744e-03f, 3.352406e-04f, -3.939842e-04f, -6.978399e-04f, -5.146626e-04f, -8.366068e-05f, 2.777190e-04f, 3.802337e-04f, 2.348940e-04f, -6.775837e-06f, -1.784947e-04f, -2.001934e-04f, -1.002417e-04f, 3.046225e-05f, 1.078831e-04f, 1.017965e-04f, 3.851888e-05f, -2.978506e-05f, -6.223591e-05f, -4.984222e-05f, -1.201024e-05f, 2.244996e-05f, 3.453063e-05f, 2.334679e-05f, 1.712946e-06f, -1.501096e-05f, -1.849375e-05f, -1.033187e-05f, 1.578651e-06f, 9.327720e-06f, 9.569505e-06f, 4.211507e-06f, -2.120636e-06f, -5.499429e-06f, -4.776552e-06f, -1.488673e-06f, 1.763371e-06f, 3.108749e-06f, 2.289486e-06f, 3.697156e-07f, -1.240271e-06f, -1.693941e-06f, -1.044315e-06f, 3.203601e-08f, 7.963052e-07f, 8.916494e-07f, 4.453708e-07f, -1.367392e-07f, -4.810154e-07f, -4.532369e-07f, -1.709388e-07f, 1.332168e-07f, 2.773830e-07f, 2.218266e-07f, 5.314546e-08f, -1.002634e-07f, -1.538527e-07f, -1.038572e-07f, -7.439121e-09f, 6.698438e-08f, 8.237470e-08f, 4.593232e-08f, -7.132517e-09f, -4.160024e-08f, -4.261108e-08f, -1.870530e-08f, 9.497382e-09f, 2.451615e-08f, 2.126172e-08f, 6.599753e-09f, -7.879874e-09f, -1.385369e-08f, -1.018700e-08f, -1.629451e-09f, 5.536438e-09f, 7.546365e-09f, 4.644242e-09f, -1.520244e-10f, -3.552276e-09f, -3.970973e-09f, -1.979162e-09f, 6.139156e-10f, 2.144762e-09f, 2.017833e-09f, 7.586589e-10f, -5.958096e-10f, -1.236327e-09f, -9.872172e-10f, -2.351644e-10f, 4.477680e-10f, 6.855089e-10f, 4.619971e-10f, 3.228302e-11f, -2.989021e-10f, -3.669143e-10f, -2.041999e-10f, 3.222057e-11f, 1.855289e-10f, 1.897382e-10f, 8.307857e-11f, -4.253366e-11f, -1.092911e-10f, -9.464120e-11f, -2.925818e-11f, 3.521198e-11f, 6.173675e-11f, 4.532651e-11f, 7.180692e-12f, -2.471390e-11f, -3.361833e-11f, -2.065358e-11f, 7.186968e-13f, 1.584644e-11f, 1.768474e-11f, 8.795025e-12f, -2.756107e-12f, -9.563072e-12f, -8.983462e-12f, -3.367019e-12f, 2.664695e-12f, 5.510432e-12f, 4.393496e-12f, 1.040536e-12f, -1.999676e-12f, -3.054357e-12f, -2.055133e-12f, -1.399982e-13f, 1.333773e-12f, 1.634309e-12f, 9.077990e-13f, -1.455250e-13f, -8.274189e-13f, -8.448616e-13f, -3.689847e-13f, 1.904793e-13f, 4.872093e-13f, 4.212701e-13f, 1.297047e-13f, -1.573461e-13f, -2.751191e-13f, -2.016770e-13f, -3.164021e-14f, 1.103186e-13f, 1.497660e-13f, 9.184882e-14f, -3.386299e-15f, -7.068940e-14f, -7.875876e-14f, -3.908312e-14f, 1.237245e-14f, 4.263969e-14f, 3.999456e-14f, 1.494299e-14f, -1.191734e-14f, -2.456045e-14f, -1.955267e-14f, -4.603853e-15f, 8.930213e-15f, 1.360897e-14f, 9.141940e-15f, 6.066651e-16f, -5.951575e-15f, -7.279515e-15f, -4.035719e-15f, 6.571410e-16f, 3.690093e-15f, 3.761968e-15f, 1.638788e-15f, -8.530000e-16f, -2.171925e-15f, -1.875165e-15f, -5.749801e-16f, 7.030977e-16f, 1.226017e-15f, 8.973435e-16f, 1.393989e-16f, -4.924398e-16f, -6.671893e-16f, -4.084597e-16f, 1.590772e-17f, 3.153369e-16f, 3.507503e-16f, 1.736750e-16f, -5.553779e-17f, -1.901205e-16f, -1.780560e-16f, -6.631658e-17f, 5.329700e-17f, 1.094676e-16f, 8.701624e-17f, 2.036877e-17f, -3.988046e-17f, -6.063582e-17f, -4.066632e-17f, -2.626848e-18f, 2.655703e-17f, 3.242421e-17f, 1.794111e-17f, -2.966869e-18f, -1.645687e-17f, -1.675110e-17f, -7.278339e-18f, 3.819766e-18f, 9.682171e-18f, 8.346743e-18f, 2.548817e-18f, -3.141738e-18f, -5.463499e-18f, -3.992632e-18f, -6.140806e-19f, 2.198135e-18f, 2.972238e-18f, 1.816446e-18f, -7.452820e-20f, -1.406673e-18f, -1.562053e-18f, -7.717594e-19f, 2.492839e-19f, 8.476999e-19f, 7.927040e-19f, 2.943063e-19f, -2.383516e-19f, -4.879031e-19f, -3.872514e-19f, -9.011286e-20f, 1.780961e-19f, 2.701669e-19f, 1.808961e-19f, 1.136477e-20f, -1.185017e-19f, -1.444226e-19f, -7.975805e-20f, 1.339242e-20f, 7.339314e-20f, 7.458823e-20f, 3.232485e-20f, -1.710454e-20f, -4.316175e-20f, -3.715292e-20f, -1.129829e-20f, 1.403844e-20f, 2.434691e-20f, 1.776471e-20f, 2.704803e-21f, -9.811884e-21f, -1.324088e-20f, -8.077805e-21f, 3.483214e-22f, 6.274936e-21f, 6.956524e-21f, 3.429436e-21f, -1.118855e-21f, -3.779669e-21f, -3.529101e-21f, -1.306080e-21f, 1.065922e-21f, 2.174604e-21f, 1.723392e-21f, 3.986456e-22f, -7.953247e-22f, -1.203743e-21f, -8.046771e-22f, -4.912523e-23f, 5.287702e-22f, 6.432796e-22f, 3.545658e-22f, -6.044262e-23f, -3.273119e-22f, -3.321207e-22f, -1.435608e-22f, 7.659011e-23f, 1.924083e-22f, 1.653741e-22f, 5.008128e-23f, -6.272809e-23f, -1.084965e-22f, -7.904148e-23f, -1.191212e-23f, 4.379729e-23f, 5.898601e-23f, 3.592211e-23f, -1.624359e-24f, -2.799132e-23f, -3.098044e-23f, -1.523911e-23f, 5.021429e-24f, 1.685248e-23f, 1.571143e-23f, 5.796059e-24f, -4.766776e-24f, -9.692266e-24f, -7.669613e-24f, -1.763458e-24f, 3.551654e-24f, 5.363324e-24f, 3.579415e-24f, 2.121502e-25f, -2.359429e-24f, -2.865254e-24f, -1.576218e-24f, 2.727423e-25f, 1.459709e-24f, 1.478837e-24f, 6.375733e-25f, -3.429424e-25f, -8.577235e-25f, -7.361065e-25f, -2.219864e-25f, 2.802851e-25f, 4.834885e-25f, 3.516821e-25f, 5.245473e-26f, -1.954966e-25f, -2.627725e-25f, -1.597452e-25f, 7.559780e-27f, 1.248635e-25f, 1.379691e-25f, 6.771625e-26f, -2.253489e-26f, -7.514016e-26f, -6.994652e-26f, -2.572103e-26f, 2.131652e-26f, 4.319855e-26f, 3.413197e-26f, 7.800478e-27f, -1.586035e-26f, -2.389644e-26f, -1.592210e-26f, -9.152726e-28f, 1.052797e-26f, 1.276219e-26f, 7.007009e-27f, -1.230520e-27f, -6.509821e-27f, -6.584811e-27f, -2.831517e-27f, 1.535524e-27f, 3.823572e-27f, 3.276516e-27f, 9.839326e-28f, -1.252370e-27f, -2.154544e-27f, -1.564745e-27f, -2.309514e-28f, 8.726257e-28f, 1.170603e-27f, 7.103809e-28f, -3.511855e-29f, -5.569872e-28f, -6.144329e-28f, -3.009000e-28f, 1.011250e-28f, 3.350262e-28f, 3.113974e-28f, 1.141396e-28f, -9.532348e-29f, -1.925358e-28f, -1.518964e-28f, -3.450282e-29f, 7.082573e-29f, 1.064709e-28f, 7.082495e-29f, 3.944551e-30f, -4.697636e-29f, -5.684418e-29f, -3.114913e-29f, 5.550781e-30f, 2.903152e-29f, 2.932007e-29f, 1.257486e-29f, -6.875105e-30f, -1.704471e-29f, -1.458419e-29f, -4.361062e-30f, 5.595770e-30f, 9.601145e-30f, 6.962018e-30f, 1.016707e-30f, -3.895055e-30f, -5.214802e-30f, -3.159019e-30f, 1.628650e-31f, 2.484579e-30f, 2.736314e-30f, 1.337050e-30f, -4.537706e-31f, -1.493770e-30f, -1.386317e-30f, -5.064971e-31f, 4.262610e-31f, 8.581286e-31f, 6.759771e-31f, 1.526036e-31f, -3.162753e-31f, -4.743810e-31f, -3.150433e-31f, -1.698063e-32f, 2.096099e-31f, 2.531894e-31f, 1.384702e-31f, -2.503512e-32f, -1.294699e-31f, -1.305526e-31f, -5.584466e-32f, 3.078147e-32f, 7.598159e-32f, 6.491588e-32f, 1.932890e-32f, -2.500239e-32f, -4.278480e-32f, -3.097597e-32f, -4.475164e-33f, 1.738586e-32f, 2.323084e-32f, 1.404788e-32f, -7.541171e-34f, -1.108303e-32f, -1.218586e-32f, -5.941132e-33f, 2.036057e-33f, 6.660199e-33f, 6.171755e-33f, 2.247554e-33f, -1.906091e-33f, -3.824652e-33f, -3.008257e-33f, -6.749194e-34f, 1.412328e-33f, 2.113599e-33f, 1.401368e-33f, 7.301023e-35f, -9.352800e-34f, -1.127726e-33f, -6.155503e-34f, 1.128958e-34f, 5.773853e-34f, 5.813055e-34f, 2.480020e-34f, -1.378119e-34f, -3.387082e-34f, -2.889468e-34f, -8.566631e-35f, 1.117115e-34f, 1.906578e-34f, 1.378201e-34f, 1.969511e-35f, -7.760246e-35f, -1.034882e-34f, -6.246932e-35f, 3.486750e-36f, 4.943810e-35f, 5.426815e-35f, 2.639897e-35f, -9.135225e-36f, -2.969538e-35f, -2.747599e-35f, -9.973223e-36f, 8.523222e-36f, 1.704630e-35f, 1.338740e-35f, 2.984802e-36f, -6.306694e-36f, -9.417084e-36f, -6.233501e-36f, -3.135092e-37f, 4.173198e-36f, 5.022972e-36f, 2.736325e-36f, -5.090253e-37f, -2.574904e-36f, -2.588345e-36f, -1.101345e-36f, 6.169808e-37f, 1.509877e-36f, 1.286126e-36f, 3.796648e-37f, -4.991248e-37f, -8.496076e-37f, -6.131951e-37f, -8.666470e-38f, 3.463793e-37f, 4.610151e-37f, 2.777924e-37f, -1.609982e-38f, -2.205277e-37f, -2.416755e-37f, -1.173007e-37f, 4.098500e-38f, 1.324003e-37f, 1.223198e-37f, 4.425407e-38f, -3.811153e-38f, -7.597432e-38f, -5.957660e-38f, -1.319942e-38f, 2.816204e-38f, 4.195745e-38f, 2.772743e-38f, 0.000000e+00f, -1.862061e-38f, -2.237260e-38f, -1.216379e-38f};

// shared memory size is 26264 bytes

static __device__ unsigned int counter = 0;

static __global__ __launch_bounds__(block_size, 2)
void Recurrence1(const int items, const T* const __restrict__ input, T* const __restrict__ output, volatile int* const __restrict__ status, volatile T* const __restrict__ partcarry, volatile T* const __restrict__ fullcarry)
{
  const int valsperthread = 1;
  const int chunk_size = valsperthread * block_size;
  __shared__ T spartc[chunk_size / warp_size * order];
  __shared__ T sfullc[order];
  __shared__ int cid;

  const int tid = threadIdx.x;
  const int warp = tid / warp_size;
  const int lane = tid % warp_size;

  __shared__ T sfacA[block_size];
  __shared__ T sfacB[block_size];
  __shared__ T sfacC[block_size];
  __shared__ T sfacD[block_size];
  __shared__ T sfacE[block_size];
  if (tid < 530) sfacA[tid] = facA[tid];
  else sfacA[tid] = 0;
  if (tid < 538) sfacB[tid] = facB[tid];
  else sfacB[tid] = 0;
  if (tid < 542) sfacC[tid] = facC[tid];
  else sfacC[tid] = 0;
  if (tid < 540) sfacD[tid] = facD[tid];
  else sfacD[tid] = 0;
  if (tid < 541) sfacE[tid] = facE[tid];
  else sfacE[tid] = 0;

  if (tid == 0) {
    cid = atomicInc(&counter, gridDim.x - 1);
  }

  __syncthreads();
  const int chunk_id = cid;
  const int offs = tid + chunk_id * chunk_size;

  T val0;
  if (chunk_id == gridDim.x - 1) {
    val0 = 0;
    if (offs + (0 * block_size) < items) val0 = input[offs + (0 * block_size)];
  } else {
    val0 = input[offs + (0 * block_size)];
  }

  val0 *= 2.085000e-01f;

  const T sfA = sfacA[lane];
  const T sfB = sfacB[lane];
  const T sfC = sfacC[lane];
  const T sfD = sfacD[lane];
  const T sfE = sfacE[lane];

  int cond;
  T help, spc;

  help = -8.670000e-03f;
  cond = ((lane & 1) != 0);
  spc = help * __shfl(val0, 0, 2);
  if (cond) val0 += spc;

  help = __shfl(sfD, lane % 2);
  cond = ((lane & 2) != 0);
  spc = help * __shfl(val0, 0, 4);
  if (cond) val0 += spc;

  help = __shfl(sfE, lane % 2);
  cond = ((lane & 2) != 0);
  spc = help * __shfl(val0, 1, 4);
  if (cond) val0 += spc;

  help = __shfl(sfB, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 0, 8);
  if (cond) val0 += spc;

  help = __shfl(sfC, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 1, 8);
  if (cond) val0 += spc;

  help = __shfl(sfD, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 2, 8);
  if (cond) val0 += spc;

  help = __shfl(sfE, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 3, 8);
  if (cond) val0 += spc;

  help = __shfl(sfA, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 3, 16);
  if (cond) val0 += spc;

  help = __shfl(sfB, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 4, 16);
  if (cond) val0 += spc;

  help = __shfl(sfC, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 5, 16);
  if (cond) val0 += spc;

  help = __shfl(sfD, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 6, 16);
  if (cond) val0 += spc;

  help = __shfl(sfE, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 7, 16);
  if (cond) val0 += spc;

  help = __shfl(sfA, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 11, 32);
  if (cond) val0 += spc;

  help = __shfl(sfB, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 12, 32);
  if (cond) val0 += spc;

  help = __shfl(sfC, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 13, 32);
  if (cond) val0 += spc;

  help = __shfl(sfD, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 14, 32);
  if (cond) val0 += spc;

  help = __shfl(sfE, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 15, 32);
  if (cond) val0 += spc;

  const int delta = block_size / warp_size * order;
  const int clane = lane - (warp_size - order);
  const int clwo = clane + warp * order;

  if (((warp & 1) == 0) && (clane >= 0)) {
    spartc[clwo + 0 * delta] = val0;
  }

  __syncthreads();
  if ((warp & 1) != 0) {
    const int cwarp = ((warp & ~1) | 0) * order;
    const T helpA = sfacA[tid % (warp_size * 1)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 1)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 1)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 1)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 1)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    if (((warp & 3) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
    }
  }

  __syncthreads();
  if ((warp & 2) != 0) {
    const int cwarp = ((warp & ~3) | 1) * order;
    const T helpA = sfacA[tid % (warp_size * 2)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 2)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 2)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 2)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 2)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    if (((warp & 7) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
    }
  }

  __syncthreads();
  if ((warp & 4) != 0) {
    const int cwarp = ((warp & ~7) | 3) * order;
    const T helpA = sfacA[tid % (warp_size * 4)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 4)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 4)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 4)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 4)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    if (((warp & 15) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
    }
  }

  __syncthreads();
  if ((warp & 8) != 0) {
    const int cwarp = ((warp & ~15) | 7) * order;
    const T helpA = sfacA[tid % (warp_size * 8)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 8)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 8)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 8)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 8)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    if ((warp == 15) && (clane >= 0)) {
      spartc[clane + (15 * order + 0 * delta)] = val0;
    }
  }

  __syncthreads();
  if ((warp & 16) != 0) {
    const int cwarp = 15 * order;
    const T helpA = sfacA[tid % (warp_size * 16)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 16)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 16)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 16)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 16)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    if ((warp == 31) && (clane >= 0)) {
      spartc[clane + (31 * order + 0 * delta)] = val0;
    }
  }

  const int idx = tid - (block_size - order);
  if (idx >= 0) {
    fullcarry[chunk_id * order + idx] = val0;
    __threadfence();
    if (idx == 0) {
      status[chunk_id] = 2;
    }
  }

  if (chunk_id > 0) {
    __syncthreads();
    if (warp == 0) {
      const int cidm1 = chunk_id - 1;
      int flag = 1;
      do {
        if ((cidm1 - lane) >= 0) {
          flag = status[cidm1 - lane];
        }
      } while ((__any(flag == 0)) || (__all(flag != 2)));
      int mask = __ballot(flag == 2);
      const int pos = __ffs(mask) - 1;
      T fc;
      if (lane < order) {
        fc = fullcarry[(cidm1 - pos) * order + lane];
      }
      T X0 = __shfl(fc, 0);
      T X1 = __shfl(fc, 1);
      T X2 = __shfl(fc, 2);
      T X3 = __shfl(fc, 3);
      T X4 = __shfl(fc, 4);
      if (lane == 0) {
        sfullc[0] = X0;
        sfullc[1] = X1;
        sfullc[2] = X2;
        sfullc[3] = X3;
        sfullc[4] = X4;
      }
    }

    __syncthreads();
    T X0 = sfullc[0];
    val0 += sfacA[tid] * X0;
    T X1 = sfullc[1];
    val0 += sfacB[tid] * X1;
    T X2 = sfullc[2];
    val0 += sfacC[tid] * X2;
    T X3 = sfullc[3];
    val0 += sfacD[tid] * X3;
    T X4 = sfullc[4];
    val0 += sfacE[tid] * X4;
  }

  if (chunk_id == gridDim.x - 1) {
    if (offs + (0 * block_size) < items) output[offs + (0 * block_size)] = val0;
  } else {
    output[offs + (0 * block_size)] = val0;
  }
}

static __global__ __launch_bounds__(block_size, 2)
void Recurrence2(const int items, const T* const __restrict__ input, T* const __restrict__ output, volatile int* const __restrict__ status, volatile T* const __restrict__ partcarry, volatile T* const __restrict__ fullcarry)
{
  const int valsperthread = 2;
  const int chunk_size = valsperthread * block_size;
  __shared__ T spartc[chunk_size / warp_size * order];
  __shared__ T sfullc[order];
  __shared__ int cid;

  const int tid = threadIdx.x;
  const int warp = tid / warp_size;
  const int lane = tid % warp_size;

  __shared__ T sfacA[block_size];
  __shared__ T sfacB[block_size];
  __shared__ T sfacC[block_size];
  __shared__ T sfacD[block_size];
  __shared__ T sfacE[block_size];
  if (tid < 530) sfacA[tid] = facA[tid];
  else sfacA[tid] = 0;
  if (tid < 538) sfacB[tid] = facB[tid];
  else sfacB[tid] = 0;
  if (tid < 542) sfacC[tid] = facC[tid];
  else sfacC[tid] = 0;
  if (tid < 540) sfacD[tid] = facD[tid];
  else sfacD[tid] = 0;
  if (tid < 541) sfacE[tid] = facE[tid];
  else sfacE[tid] = 0;

  if (tid == 0) {
    cid = atomicInc(&counter, gridDim.x - 1);
  }

  __syncthreads();
  const int chunk_id = cid;
  const int offs = tid + chunk_id * chunk_size;

  T val0, val1;
  if (chunk_id == gridDim.x - 1) {
    val0 = 0;
    if (offs + (0 * block_size) < items) val0 = input[offs + (0 * block_size)];
    val1 = 0;
    if (offs + (1 * block_size) < items) val1 = input[offs + (1 * block_size)];
  } else {
    val0 = input[offs + (0 * block_size)];
    val1 = input[offs + (1 * block_size)];
  }

  val0 *= 2.085000e-01f;
  val1 *= 2.085000e-01f;

  const T sfA = sfacA[lane];
  const T sfB = sfacB[lane];
  const T sfC = sfacC[lane];
  const T sfD = sfacD[lane];
  const T sfE = sfacE[lane];

  int cond;
  T help, spc;

  help = -8.670000e-03f;
  cond = ((lane & 1) != 0);
  spc = help * __shfl(val0, 0, 2);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 2);
  if (cond) val1 += spc;

  help = __shfl(sfD, lane % 2);
  cond = ((lane & 2) != 0);
  spc = help * __shfl(val0, 0, 4);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 4);
  if (cond) val1 += spc;

  help = __shfl(sfE, lane % 2);
  cond = ((lane & 2) != 0);
  spc = help * __shfl(val0, 1, 4);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 1, 4);
  if (cond) val1 += spc;

  help = __shfl(sfB, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 0, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 8);
  if (cond) val1 += spc;

  help = __shfl(sfC, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 1, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 1, 8);
  if (cond) val1 += spc;

  help = __shfl(sfD, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 2, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 2, 8);
  if (cond) val1 += spc;

  help = __shfl(sfE, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 3, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 3, 8);
  if (cond) val1 += spc;

  help = __shfl(sfA, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 3, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 3, 16);
  if (cond) val1 += spc;

  help = __shfl(sfB, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 4, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 4, 16);
  if (cond) val1 += spc;

  help = __shfl(sfC, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 5, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 5, 16);
  if (cond) val1 += spc;

  help = __shfl(sfD, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 6, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 6, 16);
  if (cond) val1 += spc;

  help = __shfl(sfE, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 7, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 7, 16);
  if (cond) val1 += spc;

  help = __shfl(sfA, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 11, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 11, 32);
  if (cond) val1 += spc;

  help = __shfl(sfB, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 12, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 12, 32);
  if (cond) val1 += spc;

  help = __shfl(sfC, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 13, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 13, 32);
  if (cond) val1 += spc;

  help = __shfl(sfD, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 14, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 14, 32);
  if (cond) val1 += spc;

  help = __shfl(sfE, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 15, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 15, 32);
  if (cond) val1 += spc;

  const int delta = block_size / warp_size * order;
  const int clane = lane - (warp_size - order);
  const int clwo = clane + warp * order;

  if (((warp & 1) == 0) && (clane >= 0)) {
    spartc[clwo + 0 * delta] = val0;
    spartc[clwo + 1 * delta] = val1;
  }

  __syncthreads();
  if ((warp & 1) != 0) {
    const int cwarp = ((warp & ~1) | 0) * order;
    const T helpA = sfacA[tid % (warp_size * 1)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 1)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 1)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 1)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 1)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    if (((warp & 3) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
    }
  }

  __syncthreads();
  if ((warp & 2) != 0) {
    const int cwarp = ((warp & ~3) | 1) * order;
    const T helpA = sfacA[tid % (warp_size * 2)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 2)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 2)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 2)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 2)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    if (((warp & 7) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
    }
  }

  __syncthreads();
  if ((warp & 4) != 0) {
    const int cwarp = ((warp & ~7) | 3) * order;
    const T helpA = sfacA[tid % (warp_size * 4)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 4)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 4)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 4)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 4)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    if (((warp & 15) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
    }
  }

  __syncthreads();
  if ((warp & 8) != 0) {
    const int cwarp = ((warp & ~15) | 7) * order;
    const T helpA = sfacA[tid % (warp_size * 8)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 8)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 8)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 8)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 8)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    if ((warp == 15) && (clane >= 0)) {
      spartc[clane + (15 * order + 0 * delta)] = val0;
      spartc[clane + (15 * order + 1 * delta)] = val1;
    }
  }

  __syncthreads();
  if ((warp & 16) != 0) {
    const int cwarp = 15 * order;
    const T helpA = sfacA[tid % (warp_size * 16)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 16)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 16)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 16)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 16)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    if ((warp == 31) && (clane >= 0)) {
      spartc[clane + (31 * order + 0 * delta)] = val0;
    }
  }

  __syncthreads();
 if (warp < 17) {
  val1 += sfacA[tid] * spartc[31 * order + (0 * delta + 0)];
  val1 += sfacB[tid] * spartc[31 * order + (0 * delta + 1)];
  val1 += sfacC[tid] * spartc[31 * order + (0 * delta + 2)];
  val1 += sfacD[tid] * spartc[31 * order + (0 * delta + 3)];
  val1 += sfacE[tid] * spartc[31 * order + (0 * delta + 4)];
 }

  const int idx = tid - (block_size - order);
  if (idx >= 0) {
    fullcarry[chunk_id * order + idx] = val1;
    __threadfence();
    if (idx == 0) {
      status[chunk_id] = 2;
    }
  }

  if (chunk_id > 0) {
    __syncthreads();
    if (warp == 0) {
      const int cidm1 = chunk_id - 1;
      int flag = 1;
      do {
        if ((cidm1 - lane) >= 0) {
          flag = status[cidm1 - lane];
        }
      } while ((__any(flag == 0)) || (__all(flag != 2)));
      int mask = __ballot(flag == 2);
      const int pos = __ffs(mask) - 1;
      T fc;
      if (lane < order) {
        fc = fullcarry[(cidm1 - pos) * order + lane];
      }
      T X0 = __shfl(fc, 0);
      T X1 = __shfl(fc, 1);
      T X2 = __shfl(fc, 2);
      T X3 = __shfl(fc, 3);
      T X4 = __shfl(fc, 4);
      if (lane == 0) {
        sfullc[0] = X0;
        sfullc[1] = X1;
        sfullc[2] = X2;
        sfullc[3] = X3;
        sfullc[4] = X4;
      }
    }

    __syncthreads();
    T X0 = sfullc[0];
    val0 += sfacA[tid] * X0;
    T X1 = sfullc[1];
    val0 += sfacB[tid] * X1;
    T X2 = sfullc[2];
    val0 += sfacC[tid] * X2;
    T X3 = sfullc[3];
    val0 += sfacD[tid] * X3;
    T X4 = sfullc[4];
    val0 += sfacE[tid] * X4;
  }

  if (chunk_id == gridDim.x - 1) {
    if (offs + (0 * block_size) < items) output[offs + (0 * block_size)] = val0;
    if (offs + (1 * block_size) < items) output[offs + (1 * block_size)] = val1;
  } else {
    output[offs + (0 * block_size)] = val0;
    output[offs + (1 * block_size)] = val1;
  }
}

static __global__ __launch_bounds__(block_size, 2)
void Recurrence3(const int items, const T* const __restrict__ input, T* const __restrict__ output, volatile int* const __restrict__ status, volatile T* const __restrict__ partcarry, volatile T* const __restrict__ fullcarry)
{
  const int valsperthread = 3;
  const int chunk_size = valsperthread * block_size;
  __shared__ T spartc[chunk_size / warp_size * order];
  __shared__ T sfullc[order];
  __shared__ int cid;

  const int tid = threadIdx.x;
  const int warp = tid / warp_size;
  const int lane = tid % warp_size;

  __shared__ T sfacA[block_size];
  __shared__ T sfacB[block_size];
  __shared__ T sfacC[block_size];
  __shared__ T sfacD[block_size];
  __shared__ T sfacE[block_size];
  if (tid < 530) sfacA[tid] = facA[tid];
  else sfacA[tid] = 0;
  if (tid < 538) sfacB[tid] = facB[tid];
  else sfacB[tid] = 0;
  if (tid < 542) sfacC[tid] = facC[tid];
  else sfacC[tid] = 0;
  if (tid < 540) sfacD[tid] = facD[tid];
  else sfacD[tid] = 0;
  if (tid < 541) sfacE[tid] = facE[tid];
  else sfacE[tid] = 0;

  if (tid == 0) {
    cid = atomicInc(&counter, gridDim.x - 1);
  }

  __syncthreads();
  const int chunk_id = cid;
  const int offs = tid + chunk_id * chunk_size;

  T val0, val1, val2;
  if (chunk_id == gridDim.x - 1) {
    val0 = 0;
    if (offs + (0 * block_size) < items) val0 = input[offs + (0 * block_size)];
    val1 = 0;
    if (offs + (1 * block_size) < items) val1 = input[offs + (1 * block_size)];
    val2 = 0;
    if (offs + (2 * block_size) < items) val2 = input[offs + (2 * block_size)];
  } else {
    val0 = input[offs + (0 * block_size)];
    val1 = input[offs + (1 * block_size)];
    val2 = input[offs + (2 * block_size)];
  }

  val0 *= 2.085000e-01f;
  val1 *= 2.085000e-01f;
  val2 *= 2.085000e-01f;

  const T sfA = sfacA[lane];
  const T sfB = sfacB[lane];
  const T sfC = sfacC[lane];
  const T sfD = sfacD[lane];
  const T sfE = sfacE[lane];

  int cond;
  T help, spc;

  help = -8.670000e-03f;
  cond = ((lane & 1) != 0);
  spc = help * __shfl(val0, 0, 2);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 2);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 2);
  if (cond) val2 += spc;

  help = __shfl(sfD, lane % 2);
  cond = ((lane & 2) != 0);
  spc = help * __shfl(val0, 0, 4);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 4);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 4);
  if (cond) val2 += spc;

  help = __shfl(sfE, lane % 2);
  cond = ((lane & 2) != 0);
  spc = help * __shfl(val0, 1, 4);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 1, 4);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 1, 4);
  if (cond) val2 += spc;

  help = __shfl(sfB, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 0, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 8);
  if (cond) val2 += spc;

  help = __shfl(sfC, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 1, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 1, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 1, 8);
  if (cond) val2 += spc;

  help = __shfl(sfD, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 2, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 2, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 2, 8);
  if (cond) val2 += spc;

  help = __shfl(sfE, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 3, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 3, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 3, 8);
  if (cond) val2 += spc;

  help = __shfl(sfA, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 3, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 3, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 3, 16);
  if (cond) val2 += spc;

  help = __shfl(sfB, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 4, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 4, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 4, 16);
  if (cond) val2 += spc;

  help = __shfl(sfC, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 5, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 5, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 5, 16);
  if (cond) val2 += spc;

  help = __shfl(sfD, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 6, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 6, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 6, 16);
  if (cond) val2 += spc;

  help = __shfl(sfE, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 7, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 7, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 7, 16);
  if (cond) val2 += spc;

  help = __shfl(sfA, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 11, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 11, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 11, 32);
  if (cond) val2 += spc;

  help = __shfl(sfB, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 12, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 12, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 12, 32);
  if (cond) val2 += spc;

  help = __shfl(sfC, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 13, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 13, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 13, 32);
  if (cond) val2 += spc;

  help = __shfl(sfD, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 14, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 14, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 14, 32);
  if (cond) val2 += spc;

  help = __shfl(sfE, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 15, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 15, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 15, 32);
  if (cond) val2 += spc;

  const int delta = block_size / warp_size * order;
  const int clane = lane - (warp_size - order);
  const int clwo = clane + warp * order;

  if (((warp & 1) == 0) && (clane >= 0)) {
    spartc[clwo + 0 * delta] = val0;
    spartc[clwo + 1 * delta] = val1;
    spartc[clwo + 2 * delta] = val2;
  }

  __syncthreads();
  if ((warp & 1) != 0) {
    const int cwarp = ((warp & ~1) | 0) * order;
    const T helpA = sfacA[tid % (warp_size * 1)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 1)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 1)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 1)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 1)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    val2 += helpE * spartc[cwarp + (2 * delta + 4)];
    if (((warp & 3) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
    }
  }

  __syncthreads();
  if ((warp & 2) != 0) {
    const int cwarp = ((warp & ~3) | 1) * order;
    const T helpA = sfacA[tid % (warp_size * 2)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 2)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 2)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 2)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 2)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    val2 += helpE * spartc[cwarp + (2 * delta + 4)];
    if (((warp & 7) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
    }
  }

  __syncthreads();
  if ((warp & 4) != 0) {
    const int cwarp = ((warp & ~7) | 3) * order;
    const T helpA = sfacA[tid % (warp_size * 4)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 4)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 4)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 4)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 4)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    val2 += helpE * spartc[cwarp + (2 * delta + 4)];
    if (((warp & 15) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
    }
  }

  __syncthreads();
  if ((warp & 8) != 0) {
    const int cwarp = ((warp & ~15) | 7) * order;
    const T helpA = sfacA[tid % (warp_size * 8)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 8)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 8)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 8)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 8)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    val2 += helpE * spartc[cwarp + (2 * delta + 4)];
    if ((warp == 15) && (clane >= 0)) {
      spartc[clane + (15 * order + 0 * delta)] = val0;
      spartc[clane + (15 * order + 1 * delta)] = val1;
      spartc[clane + (15 * order + 2 * delta)] = val2;
    }
  }

  __syncthreads();
  if ((warp & 16) != 0) {
    const int cwarp = 15 * order;
    const T helpA = sfacA[tid % (warp_size * 16)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 16)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 16)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 16)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 16)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    val2 += helpE * spartc[cwarp + (2 * delta + 4)];
    if ((warp == 31) && (clane >= 0)) {
      spartc[clane + (31 * order + 0 * delta)] = val0;
      spartc[clane + (31 * order + 2 * delta)] = val2;
    }
  }

  __syncthreads();
 if (warp < 17) {
  val1 += sfacA[tid] * spartc[31 * order + (0 * delta + 0)];
  val1 += sfacB[tid] * spartc[31 * order + (0 * delta + 1)];
  val1 += sfacC[tid] * spartc[31 * order + (0 * delta + 2)];
  val1 += sfacD[tid] * spartc[31 * order + (0 * delta + 3)];
  val1 += sfacE[tid] * spartc[31 * order + (0 * delta + 4)];
 }
  if ((warp == 31) && (clane >= 0)) {
    spartc[clane + (31 * order + 1 * delta)] = val1;
  }

  __syncthreads();
 if (warp < 17) {
  val2 += sfacA[tid] * spartc[31 * order + (1 * delta + 0)];
  val2 += sfacB[tid] * spartc[31 * order + (1 * delta + 1)];
  val2 += sfacC[tid] * spartc[31 * order + (1 * delta + 2)];
  val2 += sfacD[tid] * spartc[31 * order + (1 * delta + 3)];
  val2 += sfacE[tid] * spartc[31 * order + (1 * delta + 4)];
 }

  const int idx = tid - (block_size - order);
  if (idx >= 0) {
    fullcarry[chunk_id * order + idx] = val2;
    __threadfence();
    if (idx == 0) {
      status[chunk_id] = 2;
    }
  }

  if (chunk_id > 0) {
    __syncthreads();
    if (warp == 0) {
      const int cidm1 = chunk_id - 1;
      int flag = 1;
      do {
        if ((cidm1 - lane) >= 0) {
          flag = status[cidm1 - lane];
        }
      } while ((__any(flag == 0)) || (__all(flag != 2)));
      int mask = __ballot(flag == 2);
      const int pos = __ffs(mask) - 1;
      T fc;
      if (lane < order) {
        fc = fullcarry[(cidm1 - pos) * order + lane];
      }
      T X0 = __shfl(fc, 0);
      T X1 = __shfl(fc, 1);
      T X2 = __shfl(fc, 2);
      T X3 = __shfl(fc, 3);
      T X4 = __shfl(fc, 4);
      if (lane == 0) {
        sfullc[0] = X0;
        sfullc[1] = X1;
        sfullc[2] = X2;
        sfullc[3] = X3;
        sfullc[4] = X4;
      }
    }

    __syncthreads();
    T X0 = sfullc[0];
    val0 += sfacA[tid] * X0;
    T X1 = sfullc[1];
    val0 += sfacB[tid] * X1;
    T X2 = sfullc[2];
    val0 += sfacC[tid] * X2;
    T X3 = sfullc[3];
    val0 += sfacD[tid] * X3;
    T X4 = sfullc[4];
    val0 += sfacE[tid] * X4;
  }

  if (chunk_id == gridDim.x - 1) {
    if (offs + (0 * block_size) < items) output[offs + (0 * block_size)] = val0;
    if (offs + (1 * block_size) < items) output[offs + (1 * block_size)] = val1;
    if (offs + (2 * block_size) < items) output[offs + (2 * block_size)] = val2;
  } else {
    output[offs + (0 * block_size)] = val0;
    output[offs + (1 * block_size)] = val1;
    output[offs + (2 * block_size)] = val2;
  }
}

static __global__ __launch_bounds__(block_size, 2)
void Recurrence4(const int items, const T* const __restrict__ input, T* const __restrict__ output, volatile int* const __restrict__ status, volatile T* const __restrict__ partcarry, volatile T* const __restrict__ fullcarry)
{
  const int valsperthread = 4;
  const int chunk_size = valsperthread * block_size;
  __shared__ T spartc[chunk_size / warp_size * order];
  __shared__ T sfullc[order];
  __shared__ int cid;

  const int tid = threadIdx.x;
  const int warp = tid / warp_size;
  const int lane = tid % warp_size;

  __shared__ T sfacA[block_size];
  __shared__ T sfacB[block_size];
  __shared__ T sfacC[block_size];
  __shared__ T sfacD[block_size];
  __shared__ T sfacE[block_size];
  if (tid < 530) sfacA[tid] = facA[tid];
  else sfacA[tid] = 0;
  if (tid < 538) sfacB[tid] = facB[tid];
  else sfacB[tid] = 0;
  if (tid < 542) sfacC[tid] = facC[tid];
  else sfacC[tid] = 0;
  if (tid < 540) sfacD[tid] = facD[tid];
  else sfacD[tid] = 0;
  if (tid < 541) sfacE[tid] = facE[tid];
  else sfacE[tid] = 0;

  if (tid == 0) {
    cid = atomicInc(&counter, gridDim.x - 1);
  }

  __syncthreads();
  const int chunk_id = cid;
  const int offs = tid + chunk_id * chunk_size;

  T val0, val1, val2, val3;
  if (chunk_id == gridDim.x - 1) {
    val0 = 0;
    if (offs + (0 * block_size) < items) val0 = input[offs + (0 * block_size)];
    val1 = 0;
    if (offs + (1 * block_size) < items) val1 = input[offs + (1 * block_size)];
    val2 = 0;
    if (offs + (2 * block_size) < items) val2 = input[offs + (2 * block_size)];
    val3 = 0;
    if (offs + (3 * block_size) < items) val3 = input[offs + (3 * block_size)];
  } else {
    val0 = input[offs + (0 * block_size)];
    val1 = input[offs + (1 * block_size)];
    val2 = input[offs + (2 * block_size)];
    val3 = input[offs + (3 * block_size)];
  }

  val0 *= 2.085000e-01f;
  val1 *= 2.085000e-01f;
  val2 *= 2.085000e-01f;
  val3 *= 2.085000e-01f;

  const T sfA = sfacA[lane];
  const T sfB = sfacB[lane];
  const T sfC = sfacC[lane];
  const T sfD = sfacD[lane];
  const T sfE = sfacE[lane];

  int cond;
  T help, spc;

  help = -8.670000e-03f;
  cond = ((lane & 1) != 0);
  spc = help * __shfl(val0, 0, 2);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 2);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 2);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 0, 2);
  if (cond) val3 += spc;

  help = __shfl(sfD, lane % 2);
  cond = ((lane & 2) != 0);
  spc = help * __shfl(val0, 0, 4);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 4);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 4);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 0, 4);
  if (cond) val3 += spc;

  help = __shfl(sfE, lane % 2);
  cond = ((lane & 2) != 0);
  spc = help * __shfl(val0, 1, 4);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 1, 4);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 1, 4);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 1, 4);
  if (cond) val3 += spc;

  help = __shfl(sfB, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 0, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 0, 8);
  if (cond) val3 += spc;

  help = __shfl(sfC, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 1, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 1, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 1, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 1, 8);
  if (cond) val3 += spc;

  help = __shfl(sfD, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 2, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 2, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 2, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 2, 8);
  if (cond) val3 += spc;

  help = __shfl(sfE, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 3, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 3, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 3, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 3, 8);
  if (cond) val3 += spc;

  help = __shfl(sfA, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 3, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 3, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 3, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 3, 16);
  if (cond) val3 += spc;

  help = __shfl(sfB, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 4, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 4, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 4, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 4, 16);
  if (cond) val3 += spc;

  help = __shfl(sfC, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 5, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 5, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 5, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 5, 16);
  if (cond) val3 += spc;

  help = __shfl(sfD, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 6, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 6, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 6, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 6, 16);
  if (cond) val3 += spc;

  help = __shfl(sfE, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 7, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 7, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 7, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 7, 16);
  if (cond) val3 += spc;

  help = __shfl(sfA, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 11, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 11, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 11, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 11, 32);
  if (cond) val3 += spc;

  help = __shfl(sfB, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 12, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 12, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 12, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 12, 32);
  if (cond) val3 += spc;

  help = __shfl(sfC, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 13, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 13, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 13, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 13, 32);
  if (cond) val3 += spc;

  help = __shfl(sfD, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 14, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 14, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 14, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 14, 32);
  if (cond) val3 += spc;

  help = __shfl(sfE, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 15, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 15, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 15, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 15, 32);
  if (cond) val3 += spc;

  const int delta = block_size / warp_size * order;
  const int clane = lane - (warp_size - order);
  const int clwo = clane + warp * order;

  if (((warp & 1) == 0) && (clane >= 0)) {
    spartc[clwo + 0 * delta] = val0;
    spartc[clwo + 1 * delta] = val1;
    spartc[clwo + 2 * delta] = val2;
    spartc[clwo + 3 * delta] = val3;
  }

  __syncthreads();
  if ((warp & 1) != 0) {
    const int cwarp = ((warp & ~1) | 0) * order;
    const T helpA = sfacA[tid % (warp_size * 1)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 1)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 1)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 1)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 1)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    val2 += helpE * spartc[cwarp + (2 * delta + 4)];
    val3 += helpE * spartc[cwarp + (3 * delta + 4)];
    if (((warp & 3) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
      spartc[clwo + 3 * delta] = val3;
    }
  }

  __syncthreads();
  if ((warp & 2) != 0) {
    const int cwarp = ((warp & ~3) | 1) * order;
    const T helpA = sfacA[tid % (warp_size * 2)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 2)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 2)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 2)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 2)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    val2 += helpE * spartc[cwarp + (2 * delta + 4)];
    val3 += helpE * spartc[cwarp + (3 * delta + 4)];
    if (((warp & 7) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
      spartc[clwo + 3 * delta] = val3;
    }
  }

  __syncthreads();
  if ((warp & 4) != 0) {
    const int cwarp = ((warp & ~7) | 3) * order;
    const T helpA = sfacA[tid % (warp_size * 4)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 4)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 4)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 4)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 4)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    val2 += helpE * spartc[cwarp + (2 * delta + 4)];
    val3 += helpE * spartc[cwarp + (3 * delta + 4)];
    if (((warp & 15) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
      spartc[clwo + 3 * delta] = val3;
    }
  }

  __syncthreads();
  if ((warp & 8) != 0) {
    const int cwarp = ((warp & ~15) | 7) * order;
    const T helpA = sfacA[tid % (warp_size * 8)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 8)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 8)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 8)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 8)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    val2 += helpE * spartc[cwarp + (2 * delta + 4)];
    val3 += helpE * spartc[cwarp + (3 * delta + 4)];
    if ((warp == 15) && (clane >= 0)) {
      spartc[clane + (15 * order + 0 * delta)] = val0;
      spartc[clane + (15 * order + 1 * delta)] = val1;
      spartc[clane + (15 * order + 2 * delta)] = val2;
      spartc[clane + (15 * order + 3 * delta)] = val3;
    }
  }

  __syncthreads();
  if ((warp & 16) != 0) {
    const int cwarp = 15 * order;
    const T helpA = sfacA[tid % (warp_size * 16)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 16)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 16)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 16)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 16)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    val2 += helpE * spartc[cwarp + (2 * delta + 4)];
    val3 += helpE * spartc[cwarp + (3 * delta + 4)];
    if ((warp == 31) && (clane >= 0)) {
      spartc[clane + (31 * order + 0 * delta)] = val0;
      spartc[clane + (31 * order + 2 * delta)] = val2;
    }
  }

  __syncthreads();
 if (warp < 17) {
  val1 += sfacA[tid] * spartc[31 * order + (0 * delta + 0)];
  val3 += sfacA[tid] * spartc[31 * order + (2 * delta + 0)];
  val1 += sfacB[tid] * spartc[31 * order + (0 * delta + 1)];
  val3 += sfacB[tid] * spartc[31 * order + (2 * delta + 1)];
  val1 += sfacC[tid] * spartc[31 * order + (0 * delta + 2)];
  val3 += sfacC[tid] * spartc[31 * order + (2 * delta + 2)];
  val1 += sfacD[tid] * spartc[31 * order + (0 * delta + 3)];
  val3 += sfacD[tid] * spartc[31 * order + (2 * delta + 3)];
  val1 += sfacE[tid] * spartc[31 * order + (0 * delta + 4)];
  val3 += sfacE[tid] * spartc[31 * order + (2 * delta + 4)];
 }
  if ((warp == 31) && (clane >= 0)) {
    spartc[clane + (31 * order + 1 * delta)] = val1;
  }

  __syncthreads();
 if (warp < 17) {
  val2 += sfacA[tid] * spartc[31 * order + (1 * delta + 0)];
  val2 += sfacB[tid] * spartc[31 * order + (1 * delta + 1)];
  val2 += sfacC[tid] * spartc[31 * order + (1 * delta + 2)];
  val2 += sfacD[tid] * spartc[31 * order + (1 * delta + 3)];
  val2 += sfacE[tid] * spartc[31 * order + (1 * delta + 4)];
 }

  const int idx = tid - (block_size - order);
  if (idx >= 0) {
    fullcarry[chunk_id * order + idx] = val3;
    __threadfence();
    if (idx == 0) {
      status[chunk_id] = 2;
    }
  }

  if (chunk_id > 0) {
    __syncthreads();
    if (warp == 0) {
      const int cidm1 = chunk_id - 1;
      int flag = 1;
      do {
        if ((cidm1 - lane) >= 0) {
          flag = status[cidm1 - lane];
        }
      } while ((__any(flag == 0)) || (__all(flag != 2)));
      int mask = __ballot(flag == 2);
      const int pos = __ffs(mask) - 1;
      T fc;
      if (lane < order) {
        fc = fullcarry[(cidm1 - pos) * order + lane];
      }
      T X0 = __shfl(fc, 0);
      T X1 = __shfl(fc, 1);
      T X2 = __shfl(fc, 2);
      T X3 = __shfl(fc, 3);
      T X4 = __shfl(fc, 4);
      if (lane == 0) {
        sfullc[0] = X0;
        sfullc[1] = X1;
        sfullc[2] = X2;
        sfullc[3] = X3;
        sfullc[4] = X4;
      }
    }

    __syncthreads();
    T X0 = sfullc[0];
    val0 += sfacA[tid] * X0;
    T X1 = sfullc[1];
    val0 += sfacB[tid] * X1;
    T X2 = sfullc[2];
    val0 += sfacC[tid] * X2;
    T X3 = sfullc[3];
    val0 += sfacD[tid] * X3;
    T X4 = sfullc[4];
    val0 += sfacE[tid] * X4;
  }

  if (chunk_id == gridDim.x - 1) {
    if (offs + (0 * block_size) < items) output[offs + (0 * block_size)] = val0;
    if (offs + (1 * block_size) < items) output[offs + (1 * block_size)] = val1;
    if (offs + (2 * block_size) < items) output[offs + (2 * block_size)] = val2;
    if (offs + (3 * block_size) < items) output[offs + (3 * block_size)] = val3;
  } else {
    output[offs + (0 * block_size)] = val0;
    output[offs + (1 * block_size)] = val1;
    output[offs + (2 * block_size)] = val2;
    output[offs + (3 * block_size)] = val3;
  }
}

static __global__ __launch_bounds__(block_size, 2)
void Recurrence5(const int items, const T* const __restrict__ input, T* const __restrict__ output, volatile int* const __restrict__ status, volatile T* const __restrict__ partcarry, volatile T* const __restrict__ fullcarry)
{
  const int valsperthread = 5;
  const int chunk_size = valsperthread * block_size;
  __shared__ T spartc[chunk_size / warp_size * order];
  __shared__ T sfullc[order];
  __shared__ int cid;

  const int tid = threadIdx.x;
  const int warp = tid / warp_size;
  const int lane = tid % warp_size;

  __shared__ T sfacA[block_size];
  __shared__ T sfacB[block_size];
  __shared__ T sfacC[block_size];
  __shared__ T sfacD[block_size];
  __shared__ T sfacE[block_size];
  if (tid < 530) sfacA[tid] = facA[tid];
  else sfacA[tid] = 0;
  if (tid < 538) sfacB[tid] = facB[tid];
  else sfacB[tid] = 0;
  if (tid < 542) sfacC[tid] = facC[tid];
  else sfacC[tid] = 0;
  if (tid < 540) sfacD[tid] = facD[tid];
  else sfacD[tid] = 0;
  if (tid < 541) sfacE[tid] = facE[tid];
  else sfacE[tid] = 0;

  if (tid == 0) {
    cid = atomicInc(&counter, gridDim.x - 1);
  }

  __syncthreads();
  const int chunk_id = cid;
  const int offs = tid + chunk_id * chunk_size;

  T val0, val1, val2, val3, val4;
  if (chunk_id == gridDim.x - 1) {
    val0 = 0;
    if (offs + (0 * block_size) < items) val0 = input[offs + (0 * block_size)];
    val1 = 0;
    if (offs + (1 * block_size) < items) val1 = input[offs + (1 * block_size)];
    val2 = 0;
    if (offs + (2 * block_size) < items) val2 = input[offs + (2 * block_size)];
    val3 = 0;
    if (offs + (3 * block_size) < items) val3 = input[offs + (3 * block_size)];
    val4 = 0;
    if (offs + (4 * block_size) < items) val4 = input[offs + (4 * block_size)];
  } else {
    val0 = input[offs + (0 * block_size)];
    val1 = input[offs + (1 * block_size)];
    val2 = input[offs + (2 * block_size)];
    val3 = input[offs + (3 * block_size)];
    val4 = input[offs + (4 * block_size)];
  }

  val0 *= 2.085000e-01f;
  val1 *= 2.085000e-01f;
  val2 *= 2.085000e-01f;
  val3 *= 2.085000e-01f;
  val4 *= 2.085000e-01f;

  const T sfA = sfacA[lane];
  const T sfB = sfacB[lane];
  const T sfC = sfacC[lane];
  const T sfD = sfacD[lane];
  const T sfE = sfacE[lane];

  int cond;
  T help, spc;

  help = -8.670000e-03f;
  cond = ((lane & 1) != 0);
  spc = help * __shfl(val0, 0, 2);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 2);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 2);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 0, 2);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 0, 2);
  if (cond) val4 += spc;

  help = __shfl(sfD, lane % 2);
  cond = ((lane & 2) != 0);
  spc = help * __shfl(val0, 0, 4);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 4);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 4);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 0, 4);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 0, 4);
  if (cond) val4 += spc;

  help = __shfl(sfE, lane % 2);
  cond = ((lane & 2) != 0);
  spc = help * __shfl(val0, 1, 4);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 1, 4);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 1, 4);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 1, 4);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 1, 4);
  if (cond) val4 += spc;

  help = __shfl(sfB, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 0, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 0, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 0, 8);
  if (cond) val4 += spc;

  help = __shfl(sfC, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 1, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 1, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 1, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 1, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 1, 8);
  if (cond) val4 += spc;

  help = __shfl(sfD, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 2, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 2, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 2, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 2, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 2, 8);
  if (cond) val4 += spc;

  help = __shfl(sfE, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 3, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 3, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 3, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 3, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 3, 8);
  if (cond) val4 += spc;

  help = __shfl(sfA, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 3, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 3, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 3, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 3, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 3, 16);
  if (cond) val4 += spc;

  help = __shfl(sfB, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 4, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 4, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 4, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 4, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 4, 16);
  if (cond) val4 += spc;

  help = __shfl(sfC, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 5, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 5, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 5, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 5, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 5, 16);
  if (cond) val4 += spc;

  help = __shfl(sfD, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 6, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 6, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 6, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 6, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 6, 16);
  if (cond) val4 += spc;

  help = __shfl(sfE, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 7, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 7, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 7, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 7, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 7, 16);
  if (cond) val4 += spc;

  help = __shfl(sfA, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 11, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 11, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 11, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 11, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 11, 32);
  if (cond) val4 += spc;

  help = __shfl(sfB, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 12, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 12, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 12, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 12, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 12, 32);
  if (cond) val4 += spc;

  help = __shfl(sfC, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 13, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 13, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 13, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 13, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 13, 32);
  if (cond) val4 += spc;

  help = __shfl(sfD, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 14, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 14, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 14, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 14, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 14, 32);
  if (cond) val4 += spc;

  help = __shfl(sfE, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 15, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 15, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 15, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 15, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 15, 32);
  if (cond) val4 += spc;

  const int delta = block_size / warp_size * order;
  const int clane = lane - (warp_size - order);
  const int clwo = clane + warp * order;

  if (((warp & 1) == 0) && (clane >= 0)) {
    spartc[clwo + 0 * delta] = val0;
    spartc[clwo + 1 * delta] = val1;
    spartc[clwo + 2 * delta] = val2;
    spartc[clwo + 3 * delta] = val3;
    spartc[clwo + 4 * delta] = val4;
  }

  __syncthreads();
  if ((warp & 1) != 0) {
    const int cwarp = ((warp & ~1) | 0) * order;
    const T helpA = sfacA[tid % (warp_size * 1)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 1)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 1)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 1)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 1)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    val2 += helpE * spartc[cwarp + (2 * delta + 4)];
    val3 += helpE * spartc[cwarp + (3 * delta + 4)];
    val4 += helpE * spartc[cwarp + (4 * delta + 4)];
    if (((warp & 3) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
      spartc[clwo + 3 * delta] = val3;
      spartc[clwo + 4 * delta] = val4;
    }
  }

  __syncthreads();
  if ((warp & 2) != 0) {
    const int cwarp = ((warp & ~3) | 1) * order;
    const T helpA = sfacA[tid % (warp_size * 2)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 2)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 2)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 2)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 2)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    val2 += helpE * spartc[cwarp + (2 * delta + 4)];
    val3 += helpE * spartc[cwarp + (3 * delta + 4)];
    val4 += helpE * spartc[cwarp + (4 * delta + 4)];
    if (((warp & 7) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
      spartc[clwo + 3 * delta] = val3;
      spartc[clwo + 4 * delta] = val4;
    }
  }

  __syncthreads();
  if ((warp & 4) != 0) {
    const int cwarp = ((warp & ~7) | 3) * order;
    const T helpA = sfacA[tid % (warp_size * 4)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 4)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 4)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 4)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 4)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    val2 += helpE * spartc[cwarp + (2 * delta + 4)];
    val3 += helpE * spartc[cwarp + (3 * delta + 4)];
    val4 += helpE * spartc[cwarp + (4 * delta + 4)];
    if (((warp & 15) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
      spartc[clwo + 3 * delta] = val3;
      spartc[clwo + 4 * delta] = val4;
    }
  }

  __syncthreads();
  if ((warp & 8) != 0) {
    const int cwarp = ((warp & ~15) | 7) * order;
    const T helpA = sfacA[tid % (warp_size * 8)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 8)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 8)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 8)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 8)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    val2 += helpE * spartc[cwarp + (2 * delta + 4)];
    val3 += helpE * spartc[cwarp + (3 * delta + 4)];
    val4 += helpE * spartc[cwarp + (4 * delta + 4)];
    if ((warp == 15) && (clane >= 0)) {
      spartc[clane + (15 * order + 0 * delta)] = val0;
      spartc[clane + (15 * order + 1 * delta)] = val1;
      spartc[clane + (15 * order + 2 * delta)] = val2;
      spartc[clane + (15 * order + 3 * delta)] = val3;
      spartc[clane + (15 * order + 4 * delta)] = val4;
    }
  }

  __syncthreads();
  if ((warp & 16) != 0) {
    const int cwarp = 15 * order;
    const T helpA = sfacA[tid % (warp_size * 16)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 16)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 16)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 16)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 16)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    val2 += helpE * spartc[cwarp + (2 * delta + 4)];
    val3 += helpE * spartc[cwarp + (3 * delta + 4)];
    val4 += helpE * spartc[cwarp + (4 * delta + 4)];
    if ((warp == 31) && (clane >= 0)) {
      spartc[clane + (31 * order + 0 * delta)] = val0;
      spartc[clane + (31 * order + 2 * delta)] = val2;
      spartc[clane + (31 * order + 4 * delta)] = val4;
    }
  }

  __syncthreads();
 if (warp < 17) {
  val1 += sfacA[tid] * spartc[31 * order + (0 * delta + 0)];
  val3 += sfacA[tid] * spartc[31 * order + (2 * delta + 0)];
  val1 += sfacB[tid] * spartc[31 * order + (0 * delta + 1)];
  val3 += sfacB[tid] * spartc[31 * order + (2 * delta + 1)];
  val1 += sfacC[tid] * spartc[31 * order + (0 * delta + 2)];
  val3 += sfacC[tid] * spartc[31 * order + (2 * delta + 2)];
  val1 += sfacD[tid] * spartc[31 * order + (0 * delta + 3)];
  val3 += sfacD[tid] * spartc[31 * order + (2 * delta + 3)];
  val1 += sfacE[tid] * spartc[31 * order + (0 * delta + 4)];
  val3 += sfacE[tid] * spartc[31 * order + (2 * delta + 4)];
 }
  if ((warp == 31) && (clane >= 0)) {
    spartc[clane + (31 * order + 1 * delta)] = val1;
  }

  __syncthreads();
 if (warp < 17) {
  val2 += sfacA[tid] * spartc[31 * order + (1 * delta + 0)];
  val2 += sfacB[tid] * spartc[31 * order + (1 * delta + 1)];
  val2 += sfacC[tid] * spartc[31 * order + (1 * delta + 2)];
  val2 += sfacD[tid] * spartc[31 * order + (1 * delta + 3)];
  val2 += sfacE[tid] * spartc[31 * order + (1 * delta + 4)];
 }
  if ((warp == 31) && (clane >= 0)) {
    spartc[clane + (31 * order + 3 * delta)] = val3;
  }

  __syncthreads();
 if (warp < 17) {
  val4 += sfacA[tid] * spartc[31 * order + (3 * delta + 0)];
  val4 += sfacB[tid] * spartc[31 * order + (3 * delta + 1)];
  val4 += sfacC[tid] * spartc[31 * order + (3 * delta + 2)];
  val4 += sfacD[tid] * spartc[31 * order + (3 * delta + 3)];
  val4 += sfacE[tid] * spartc[31 * order + (3 * delta + 4)];
 }

  const int idx = tid - (block_size - order);
  if (idx >= 0) {
    fullcarry[chunk_id * order + idx] = val4;
    __threadfence();
    if (idx == 0) {
      status[chunk_id] = 2;
    }
  }

  if (chunk_id > 0) {
    __syncthreads();
    if (warp == 0) {
      const int cidm1 = chunk_id - 1;
      int flag = 1;
      do {
        if ((cidm1 - lane) >= 0) {
          flag = status[cidm1 - lane];
        }
      } while ((__any(flag == 0)) || (__all(flag != 2)));
      int mask = __ballot(flag == 2);
      const int pos = __ffs(mask) - 1;
      T fc;
      if (lane < order) {
        fc = fullcarry[(cidm1 - pos) * order + lane];
      }
      T X0 = __shfl(fc, 0);
      T X1 = __shfl(fc, 1);
      T X2 = __shfl(fc, 2);
      T X3 = __shfl(fc, 3);
      T X4 = __shfl(fc, 4);
      if (lane == 0) {
        sfullc[0] = X0;
        sfullc[1] = X1;
        sfullc[2] = X2;
        sfullc[3] = X3;
        sfullc[4] = X4;
      }
    }

    __syncthreads();
    T X0 = sfullc[0];
    val0 += sfacA[tid] * X0;
    T X1 = sfullc[1];
    val0 += sfacB[tid] * X1;
    T X2 = sfullc[2];
    val0 += sfacC[tid] * X2;
    T X3 = sfullc[3];
    val0 += sfacD[tid] * X3;
    T X4 = sfullc[4];
    val0 += sfacE[tid] * X4;
  }

  if (chunk_id == gridDim.x - 1) {
    if (offs + (0 * block_size) < items) output[offs + (0 * block_size)] = val0;
    if (offs + (1 * block_size) < items) output[offs + (1 * block_size)] = val1;
    if (offs + (2 * block_size) < items) output[offs + (2 * block_size)] = val2;
    if (offs + (3 * block_size) < items) output[offs + (3 * block_size)] = val3;
    if (offs + (4 * block_size) < items) output[offs + (4 * block_size)] = val4;
  } else {
    output[offs + (0 * block_size)] = val0;
    output[offs + (1 * block_size)] = val1;
    output[offs + (2 * block_size)] = val2;
    output[offs + (3 * block_size)] = val3;
    output[offs + (4 * block_size)] = val4;
  }
}

static __global__ __launch_bounds__(block_size, 2)
void Recurrence6(const int items, const T* const __restrict__ input, T* const __restrict__ output, volatile int* const __restrict__ status, volatile T* const __restrict__ partcarry, volatile T* const __restrict__ fullcarry)
{
  const int valsperthread = 6;
  const int chunk_size = valsperthread * block_size;
  __shared__ T spartc[chunk_size / warp_size * order];
  __shared__ T sfullc[order];
  __shared__ int cid;

  const int tid = threadIdx.x;
  const int warp = tid / warp_size;
  const int lane = tid % warp_size;

  __shared__ T sfacA[block_size];
  __shared__ T sfacB[block_size];
  __shared__ T sfacC[block_size];
  __shared__ T sfacD[block_size];
  __shared__ T sfacE[block_size];
  if (tid < 530) sfacA[tid] = facA[tid];
  else sfacA[tid] = 0;
  if (tid < 538) sfacB[tid] = facB[tid];
  else sfacB[tid] = 0;
  if (tid < 542) sfacC[tid] = facC[tid];
  else sfacC[tid] = 0;
  if (tid < 540) sfacD[tid] = facD[tid];
  else sfacD[tid] = 0;
  if (tid < 541) sfacE[tid] = facE[tid];
  else sfacE[tid] = 0;

  if (tid == 0) {
    cid = atomicInc(&counter, gridDim.x - 1);
  }

  __syncthreads();
  const int chunk_id = cid;
  const int offs = tid + chunk_id * chunk_size;

  T val0, val1, val2, val3, val4, val5;
  if (chunk_id == gridDim.x - 1) {
    val0 = 0;
    if (offs + (0 * block_size) < items) val0 = input[offs + (0 * block_size)];
    val1 = 0;
    if (offs + (1 * block_size) < items) val1 = input[offs + (1 * block_size)];
    val2 = 0;
    if (offs + (2 * block_size) < items) val2 = input[offs + (2 * block_size)];
    val3 = 0;
    if (offs + (3 * block_size) < items) val3 = input[offs + (3 * block_size)];
    val4 = 0;
    if (offs + (4 * block_size) < items) val4 = input[offs + (4 * block_size)];
    val5 = 0;
    if (offs + (5 * block_size) < items) val5 = input[offs + (5 * block_size)];
  } else {
    val0 = input[offs + (0 * block_size)];
    val1 = input[offs + (1 * block_size)];
    val2 = input[offs + (2 * block_size)];
    val3 = input[offs + (3 * block_size)];
    val4 = input[offs + (4 * block_size)];
    val5 = input[offs + (5 * block_size)];
  }

  val0 *= 2.085000e-01f;
  val1 *= 2.085000e-01f;
  val2 *= 2.085000e-01f;
  val3 *= 2.085000e-01f;
  val4 *= 2.085000e-01f;
  val5 *= 2.085000e-01f;

  const T sfA = sfacA[lane];
  const T sfB = sfacB[lane];
  const T sfC = sfacC[lane];
  const T sfD = sfacD[lane];
  const T sfE = sfacE[lane];

  int cond;
  T help, spc;

  help = -8.670000e-03f;
  cond = ((lane & 1) != 0);
  spc = help * __shfl(val0, 0, 2);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 2);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 2);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 0, 2);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 0, 2);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 0, 2);
  if (cond) val5 += spc;

  help = __shfl(sfD, lane % 2);
  cond = ((lane & 2) != 0);
  spc = help * __shfl(val0, 0, 4);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 4);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 4);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 0, 4);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 0, 4);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 0, 4);
  if (cond) val5 += spc;

  help = __shfl(sfE, lane % 2);
  cond = ((lane & 2) != 0);
  spc = help * __shfl(val0, 1, 4);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 1, 4);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 1, 4);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 1, 4);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 1, 4);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 1, 4);
  if (cond) val5 += spc;

  help = __shfl(sfB, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 0, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 0, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 0, 8);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 0, 8);
  if (cond) val5 += spc;

  help = __shfl(sfC, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 1, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 1, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 1, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 1, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 1, 8);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 1, 8);
  if (cond) val5 += spc;

  help = __shfl(sfD, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 2, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 2, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 2, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 2, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 2, 8);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 2, 8);
  if (cond) val5 += spc;

  help = __shfl(sfE, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 3, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 3, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 3, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 3, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 3, 8);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 3, 8);
  if (cond) val5 += spc;

  help = __shfl(sfA, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 3, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 3, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 3, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 3, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 3, 16);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 3, 16);
  if (cond) val5 += spc;

  help = __shfl(sfB, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 4, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 4, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 4, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 4, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 4, 16);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 4, 16);
  if (cond) val5 += spc;

  help = __shfl(sfC, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 5, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 5, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 5, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 5, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 5, 16);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 5, 16);
  if (cond) val5 += spc;

  help = __shfl(sfD, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 6, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 6, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 6, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 6, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 6, 16);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 6, 16);
  if (cond) val5 += spc;

  help = __shfl(sfE, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 7, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 7, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 7, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 7, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 7, 16);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 7, 16);
  if (cond) val5 += spc;

  help = __shfl(sfA, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 11, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 11, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 11, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 11, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 11, 32);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 11, 32);
  if (cond) val5 += spc;

  help = __shfl(sfB, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 12, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 12, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 12, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 12, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 12, 32);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 12, 32);
  if (cond) val5 += spc;

  help = __shfl(sfC, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 13, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 13, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 13, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 13, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 13, 32);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 13, 32);
  if (cond) val5 += spc;

  help = __shfl(sfD, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 14, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 14, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 14, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 14, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 14, 32);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 14, 32);
  if (cond) val5 += spc;

  help = __shfl(sfE, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 15, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 15, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 15, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 15, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 15, 32);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 15, 32);
  if (cond) val5 += spc;

  const int delta = block_size / warp_size * order;
  const int clane = lane - (warp_size - order);
  const int clwo = clane + warp * order;

  if (((warp & 1) == 0) && (clane >= 0)) {
    spartc[clwo + 0 * delta] = val0;
    spartc[clwo + 1 * delta] = val1;
    spartc[clwo + 2 * delta] = val2;
    spartc[clwo + 3 * delta] = val3;
    spartc[clwo + 4 * delta] = val4;
    spartc[clwo + 5 * delta] = val5;
  }

  __syncthreads();
  if ((warp & 1) != 0) {
    const int cwarp = ((warp & ~1) | 0) * order;
    const T helpA = sfacA[tid % (warp_size * 1)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 1)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 1)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 1)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 1)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    val2 += helpE * spartc[cwarp + (2 * delta + 4)];
    val3 += helpE * spartc[cwarp + (3 * delta + 4)];
    val4 += helpE * spartc[cwarp + (4 * delta + 4)];
    val5 += helpE * spartc[cwarp + (5 * delta + 4)];
    if (((warp & 3) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
      spartc[clwo + 3 * delta] = val3;
      spartc[clwo + 4 * delta] = val4;
      spartc[clwo + 5 * delta] = val5;
    }
  }

  __syncthreads();
  if ((warp & 2) != 0) {
    const int cwarp = ((warp & ~3) | 1) * order;
    const T helpA = sfacA[tid % (warp_size * 2)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 2)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 2)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 2)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 2)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    val2 += helpE * spartc[cwarp + (2 * delta + 4)];
    val3 += helpE * spartc[cwarp + (3 * delta + 4)];
    val4 += helpE * spartc[cwarp + (4 * delta + 4)];
    val5 += helpE * spartc[cwarp + (5 * delta + 4)];
    if (((warp & 7) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
      spartc[clwo + 3 * delta] = val3;
      spartc[clwo + 4 * delta] = val4;
      spartc[clwo + 5 * delta] = val5;
    }
  }

  __syncthreads();
  if ((warp & 4) != 0) {
    const int cwarp = ((warp & ~7) | 3) * order;
    const T helpA = sfacA[tid % (warp_size * 4)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 4)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 4)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 4)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 4)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    val2 += helpE * spartc[cwarp + (2 * delta + 4)];
    val3 += helpE * spartc[cwarp + (3 * delta + 4)];
    val4 += helpE * spartc[cwarp + (4 * delta + 4)];
    val5 += helpE * spartc[cwarp + (5 * delta + 4)];
    if (((warp & 15) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
      spartc[clwo + 3 * delta] = val3;
      spartc[clwo + 4 * delta] = val4;
      spartc[clwo + 5 * delta] = val5;
    }
  }

  __syncthreads();
  if ((warp & 8) != 0) {
    const int cwarp = ((warp & ~15) | 7) * order;
    const T helpA = sfacA[tid % (warp_size * 8)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 8)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 8)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 8)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 8)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    val2 += helpE * spartc[cwarp + (2 * delta + 4)];
    val3 += helpE * spartc[cwarp + (3 * delta + 4)];
    val4 += helpE * spartc[cwarp + (4 * delta + 4)];
    val5 += helpE * spartc[cwarp + (5 * delta + 4)];
    if ((warp == 15) && (clane >= 0)) {
      spartc[clane + (15 * order + 0 * delta)] = val0;
      spartc[clane + (15 * order + 1 * delta)] = val1;
      spartc[clane + (15 * order + 2 * delta)] = val2;
      spartc[clane + (15 * order + 3 * delta)] = val3;
      spartc[clane + (15 * order + 4 * delta)] = val4;
      spartc[clane + (15 * order + 5 * delta)] = val5;
    }
  }

  __syncthreads();
  if ((warp & 16) != 0) {
    const int cwarp = 15 * order;
    const T helpA = sfacA[tid % (warp_size * 16)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 16)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 16)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 16)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 16)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    val2 += helpE * spartc[cwarp + (2 * delta + 4)];
    val3 += helpE * spartc[cwarp + (3 * delta + 4)];
    val4 += helpE * spartc[cwarp + (4 * delta + 4)];
    val5 += helpE * spartc[cwarp + (5 * delta + 4)];
    if ((warp == 31) && (clane >= 0)) {
      spartc[clane + (31 * order + 0 * delta)] = val0;
      spartc[clane + (31 * order + 2 * delta)] = val2;
      spartc[clane + (31 * order + 4 * delta)] = val4;
    }
  }

  __syncthreads();
 if (warp < 17) {
  val1 += sfacA[tid] * spartc[31 * order + (0 * delta + 0)];
  val3 += sfacA[tid] * spartc[31 * order + (2 * delta + 0)];
  val5 += sfacA[tid] * spartc[31 * order + (4 * delta + 0)];
  val1 += sfacB[tid] * spartc[31 * order + (0 * delta + 1)];
  val3 += sfacB[tid] * spartc[31 * order + (2 * delta + 1)];
  val5 += sfacB[tid] * spartc[31 * order + (4 * delta + 1)];
  val1 += sfacC[tid] * spartc[31 * order + (0 * delta + 2)];
  val3 += sfacC[tid] * spartc[31 * order + (2 * delta + 2)];
  val5 += sfacC[tid] * spartc[31 * order + (4 * delta + 2)];
  val1 += sfacD[tid] * spartc[31 * order + (0 * delta + 3)];
  val3 += sfacD[tid] * spartc[31 * order + (2 * delta + 3)];
  val5 += sfacD[tid] * spartc[31 * order + (4 * delta + 3)];
  val1 += sfacE[tid] * spartc[31 * order + (0 * delta + 4)];
  val3 += sfacE[tid] * spartc[31 * order + (2 * delta + 4)];
  val5 += sfacE[tid] * spartc[31 * order + (4 * delta + 4)];
 }
  if ((warp == 31) && (clane >= 0)) {
    spartc[clane + (31 * order + 1 * delta)] = val1;
    spartc[clane + (31 * order + 5 * delta)] = val5;
  }

  __syncthreads();
 if (warp < 17) {
  val2 += sfacA[tid] * spartc[31 * order + (1 * delta + 0)];
  val2 += sfacB[tid] * spartc[31 * order + (1 * delta + 1)];
  val2 += sfacC[tid] * spartc[31 * order + (1 * delta + 2)];
  val2 += sfacD[tid] * spartc[31 * order + (1 * delta + 3)];
  val2 += sfacE[tid] * spartc[31 * order + (1 * delta + 4)];
 }
  if ((warp == 31) && (clane >= 0)) {
    spartc[clane + (31 * order + 3 * delta)] = val3;
  }

  __syncthreads();
 if (warp < 17) {
  val4 += sfacA[tid] * spartc[31 * order + (3 * delta + 0)];
  val4 += sfacB[tid] * spartc[31 * order + (3 * delta + 1)];
  val4 += sfacC[tid] * spartc[31 * order + (3 * delta + 2)];
  val4 += sfacD[tid] * spartc[31 * order + (3 * delta + 3)];
  val4 += sfacE[tid] * spartc[31 * order + (3 * delta + 4)];
 }

  const int idx = tid - (block_size - order);
  if (idx >= 0) {
    fullcarry[chunk_id * order + idx] = val5;
    __threadfence();
    if (idx == 0) {
      status[chunk_id] = 2;
    }
  }

  if (chunk_id > 0) {
    __syncthreads();
    if (warp == 0) {
      const int cidm1 = chunk_id - 1;
      int flag = 1;
      do {
        if ((cidm1 - lane) >= 0) {
          flag = status[cidm1 - lane];
        }
      } while ((__any(flag == 0)) || (__all(flag != 2)));
      int mask = __ballot(flag == 2);
      const int pos = __ffs(mask) - 1;
      T fc;
      if (lane < order) {
        fc = fullcarry[(cidm1 - pos) * order + lane];
      }
      T X0 = __shfl(fc, 0);
      T X1 = __shfl(fc, 1);
      T X2 = __shfl(fc, 2);
      T X3 = __shfl(fc, 3);
      T X4 = __shfl(fc, 4);
      if (lane == 0) {
        sfullc[0] = X0;
        sfullc[1] = X1;
        sfullc[2] = X2;
        sfullc[3] = X3;
        sfullc[4] = X4;
      }
    }

    __syncthreads();
    T X0 = sfullc[0];
    val0 += sfacA[tid] * X0;
    T X1 = sfullc[1];
    val0 += sfacB[tid] * X1;
    T X2 = sfullc[2];
    val0 += sfacC[tid] * X2;
    T X3 = sfullc[3];
    val0 += sfacD[tid] * X3;
    T X4 = sfullc[4];
    val0 += sfacE[tid] * X4;
  }

  if (chunk_id == gridDim.x - 1) {
    if (offs + (0 * block_size) < items) output[offs + (0 * block_size)] = val0;
    if (offs + (1 * block_size) < items) output[offs + (1 * block_size)] = val1;
    if (offs + (2 * block_size) < items) output[offs + (2 * block_size)] = val2;
    if (offs + (3 * block_size) < items) output[offs + (3 * block_size)] = val3;
    if (offs + (4 * block_size) < items) output[offs + (4 * block_size)] = val4;
    if (offs + (5 * block_size) < items) output[offs + (5 * block_size)] = val5;
  } else {
    output[offs + (0 * block_size)] = val0;
    output[offs + (1 * block_size)] = val1;
    output[offs + (2 * block_size)] = val2;
    output[offs + (3 * block_size)] = val3;
    output[offs + (4 * block_size)] = val4;
    output[offs + (5 * block_size)] = val5;
  }
}

static __global__ __launch_bounds__(block_size, 2)
void Recurrence7(const int items, const T* const __restrict__ input, T* const __restrict__ output, volatile int* const __restrict__ status, volatile T* const __restrict__ partcarry, volatile T* const __restrict__ fullcarry)
{
  const int valsperthread = 7;
  const int chunk_size = valsperthread * block_size;
  __shared__ T spartc[chunk_size / warp_size * order];
  __shared__ T sfullc[order];
  __shared__ int cid;

  const int tid = threadIdx.x;
  const int warp = tid / warp_size;
  const int lane = tid % warp_size;

  __shared__ T sfacA[block_size];
  __shared__ T sfacB[block_size];
  __shared__ T sfacC[block_size];
  __shared__ T sfacD[block_size];
  __shared__ T sfacE[block_size];
  if (tid < 530) sfacA[tid] = facA[tid];
  else sfacA[tid] = 0;
  if (tid < 538) sfacB[tid] = facB[tid];
  else sfacB[tid] = 0;
  if (tid < 542) sfacC[tid] = facC[tid];
  else sfacC[tid] = 0;
  if (tid < 540) sfacD[tid] = facD[tid];
  else sfacD[tid] = 0;
  if (tid < 541) sfacE[tid] = facE[tid];
  else sfacE[tid] = 0;

  if (tid == 0) {
    cid = atomicInc(&counter, gridDim.x - 1);
  }

  __syncthreads();
  const int chunk_id = cid;
  const int offs = tid + chunk_id * chunk_size;

  T val0, val1, val2, val3, val4, val5, val6;
  if (chunk_id == gridDim.x - 1) {
    val0 = 0;
    if (offs + (0 * block_size) < items) val0 = input[offs + (0 * block_size)];
    val1 = 0;
    if (offs + (1 * block_size) < items) val1 = input[offs + (1 * block_size)];
    val2 = 0;
    if (offs + (2 * block_size) < items) val2 = input[offs + (2 * block_size)];
    val3 = 0;
    if (offs + (3 * block_size) < items) val3 = input[offs + (3 * block_size)];
    val4 = 0;
    if (offs + (4 * block_size) < items) val4 = input[offs + (4 * block_size)];
    val5 = 0;
    if (offs + (5 * block_size) < items) val5 = input[offs + (5 * block_size)];
    val6 = 0;
    if (offs + (6 * block_size) < items) val6 = input[offs + (6 * block_size)];
  } else {
    val0 = input[offs + (0 * block_size)];
    val1 = input[offs + (1 * block_size)];
    val2 = input[offs + (2 * block_size)];
    val3 = input[offs + (3 * block_size)];
    val4 = input[offs + (4 * block_size)];
    val5 = input[offs + (5 * block_size)];
    val6 = input[offs + (6 * block_size)];
  }

  val0 *= 2.085000e-01f;
  val1 *= 2.085000e-01f;
  val2 *= 2.085000e-01f;
  val3 *= 2.085000e-01f;
  val4 *= 2.085000e-01f;
  val5 *= 2.085000e-01f;
  val6 *= 2.085000e-01f;

  const T sfA = sfacA[lane];
  const T sfB = sfacB[lane];
  const T sfC = sfacC[lane];
  const T sfD = sfacD[lane];
  const T sfE = sfacE[lane];

  int cond;
  T help, spc;

  help = -8.670000e-03f;
  cond = ((lane & 1) != 0);
  spc = help * __shfl(val0, 0, 2);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 2);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 2);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 0, 2);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 0, 2);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 0, 2);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 0, 2);
  if (cond) val6 += spc;

  help = __shfl(sfD, lane % 2);
  cond = ((lane & 2) != 0);
  spc = help * __shfl(val0, 0, 4);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 4);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 4);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 0, 4);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 0, 4);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 0, 4);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 0, 4);
  if (cond) val6 += spc;

  help = __shfl(sfE, lane % 2);
  cond = ((lane & 2) != 0);
  spc = help * __shfl(val0, 1, 4);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 1, 4);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 1, 4);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 1, 4);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 1, 4);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 1, 4);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 1, 4);
  if (cond) val6 += spc;

  help = __shfl(sfB, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 0, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 0, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 0, 8);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 0, 8);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 0, 8);
  if (cond) val6 += spc;

  help = __shfl(sfC, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 1, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 1, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 1, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 1, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 1, 8);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 1, 8);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 1, 8);
  if (cond) val6 += spc;

  help = __shfl(sfD, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 2, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 2, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 2, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 2, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 2, 8);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 2, 8);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 2, 8);
  if (cond) val6 += spc;

  help = __shfl(sfE, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 3, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 3, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 3, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 3, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 3, 8);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 3, 8);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 3, 8);
  if (cond) val6 += spc;

  help = __shfl(sfA, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 3, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 3, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 3, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 3, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 3, 16);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 3, 16);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 3, 16);
  if (cond) val6 += spc;

  help = __shfl(sfB, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 4, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 4, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 4, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 4, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 4, 16);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 4, 16);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 4, 16);
  if (cond) val6 += spc;

  help = __shfl(sfC, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 5, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 5, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 5, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 5, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 5, 16);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 5, 16);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 5, 16);
  if (cond) val6 += spc;

  help = __shfl(sfD, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 6, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 6, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 6, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 6, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 6, 16);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 6, 16);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 6, 16);
  if (cond) val6 += spc;

  help = __shfl(sfE, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 7, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 7, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 7, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 7, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 7, 16);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 7, 16);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 7, 16);
  if (cond) val6 += spc;

  help = __shfl(sfA, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 11, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 11, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 11, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 11, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 11, 32);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 11, 32);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 11, 32);
  if (cond) val6 += spc;

  help = __shfl(sfB, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 12, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 12, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 12, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 12, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 12, 32);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 12, 32);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 12, 32);
  if (cond) val6 += spc;

  help = __shfl(sfC, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 13, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 13, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 13, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 13, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 13, 32);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 13, 32);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 13, 32);
  if (cond) val6 += spc;

  help = __shfl(sfD, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 14, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 14, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 14, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 14, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 14, 32);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 14, 32);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 14, 32);
  if (cond) val6 += spc;

  help = __shfl(sfE, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 15, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 15, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 15, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 15, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 15, 32);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 15, 32);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 15, 32);
  if (cond) val6 += spc;

  const int delta = block_size / warp_size * order;
  const int clane = lane - (warp_size - order);
  const int clwo = clane + warp * order;

  if (((warp & 1) == 0) && (clane >= 0)) {
    spartc[clwo + 0 * delta] = val0;
    spartc[clwo + 1 * delta] = val1;
    spartc[clwo + 2 * delta] = val2;
    spartc[clwo + 3 * delta] = val3;
    spartc[clwo + 4 * delta] = val4;
    spartc[clwo + 5 * delta] = val5;
    spartc[clwo + 6 * delta] = val6;
  }

  __syncthreads();
  if ((warp & 1) != 0) {
    const int cwarp = ((warp & ~1) | 0) * order;
    const T helpA = sfacA[tid % (warp_size * 1)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    val6 += helpA * spartc[cwarp + (6 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 1)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    val6 += helpB * spartc[cwarp + (6 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 1)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    val6 += helpC * spartc[cwarp + (6 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 1)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    val6 += helpD * spartc[cwarp + (6 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 1)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    val2 += helpE * spartc[cwarp + (2 * delta + 4)];
    val3 += helpE * spartc[cwarp + (3 * delta + 4)];
    val4 += helpE * spartc[cwarp + (4 * delta + 4)];
    val5 += helpE * spartc[cwarp + (5 * delta + 4)];
    val6 += helpE * spartc[cwarp + (6 * delta + 4)];
    if (((warp & 3) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
      spartc[clwo + 3 * delta] = val3;
      spartc[clwo + 4 * delta] = val4;
      spartc[clwo + 5 * delta] = val5;
      spartc[clwo + 6 * delta] = val6;
    }
  }

  __syncthreads();
  if ((warp & 2) != 0) {
    const int cwarp = ((warp & ~3) | 1) * order;
    const T helpA = sfacA[tid % (warp_size * 2)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    val6 += helpA * spartc[cwarp + (6 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 2)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    val6 += helpB * spartc[cwarp + (6 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 2)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    val6 += helpC * spartc[cwarp + (6 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 2)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    val6 += helpD * spartc[cwarp + (6 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 2)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    val2 += helpE * spartc[cwarp + (2 * delta + 4)];
    val3 += helpE * spartc[cwarp + (3 * delta + 4)];
    val4 += helpE * spartc[cwarp + (4 * delta + 4)];
    val5 += helpE * spartc[cwarp + (5 * delta + 4)];
    val6 += helpE * spartc[cwarp + (6 * delta + 4)];
    if (((warp & 7) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
      spartc[clwo + 3 * delta] = val3;
      spartc[clwo + 4 * delta] = val4;
      spartc[clwo + 5 * delta] = val5;
      spartc[clwo + 6 * delta] = val6;
    }
  }

  __syncthreads();
  if ((warp & 4) != 0) {
    const int cwarp = ((warp & ~7) | 3) * order;
    const T helpA = sfacA[tid % (warp_size * 4)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    val6 += helpA * spartc[cwarp + (6 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 4)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    val6 += helpB * spartc[cwarp + (6 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 4)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    val6 += helpC * spartc[cwarp + (6 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 4)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    val6 += helpD * spartc[cwarp + (6 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 4)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    val2 += helpE * spartc[cwarp + (2 * delta + 4)];
    val3 += helpE * spartc[cwarp + (3 * delta + 4)];
    val4 += helpE * spartc[cwarp + (4 * delta + 4)];
    val5 += helpE * spartc[cwarp + (5 * delta + 4)];
    val6 += helpE * spartc[cwarp + (6 * delta + 4)];
    if (((warp & 15) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
      spartc[clwo + 3 * delta] = val3;
      spartc[clwo + 4 * delta] = val4;
      spartc[clwo + 5 * delta] = val5;
      spartc[clwo + 6 * delta] = val6;
    }
  }

  __syncthreads();
  if ((warp & 8) != 0) {
    const int cwarp = ((warp & ~15) | 7) * order;
    const T helpA = sfacA[tid % (warp_size * 8)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    val6 += helpA * spartc[cwarp + (6 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 8)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    val6 += helpB * spartc[cwarp + (6 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 8)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    val6 += helpC * spartc[cwarp + (6 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 8)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    val6 += helpD * spartc[cwarp + (6 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 8)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    val2 += helpE * spartc[cwarp + (2 * delta + 4)];
    val3 += helpE * spartc[cwarp + (3 * delta + 4)];
    val4 += helpE * spartc[cwarp + (4 * delta + 4)];
    val5 += helpE * spartc[cwarp + (5 * delta + 4)];
    val6 += helpE * spartc[cwarp + (6 * delta + 4)];
    if ((warp == 15) && (clane >= 0)) {
      spartc[clane + (15 * order + 0 * delta)] = val0;
      spartc[clane + (15 * order + 1 * delta)] = val1;
      spartc[clane + (15 * order + 2 * delta)] = val2;
      spartc[clane + (15 * order + 3 * delta)] = val3;
      spartc[clane + (15 * order + 4 * delta)] = val4;
      spartc[clane + (15 * order + 5 * delta)] = val5;
      spartc[clane + (15 * order + 6 * delta)] = val6;
    }
  }

  __syncthreads();
  if ((warp & 16) != 0) {
    const int cwarp = 15 * order;
    const T helpA = sfacA[tid % (warp_size * 16)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    val6 += helpA * spartc[cwarp + (6 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 16)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    val6 += helpB * spartc[cwarp + (6 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 16)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    val6 += helpC * spartc[cwarp + (6 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 16)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    val6 += helpD * spartc[cwarp + (6 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 16)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    val2 += helpE * spartc[cwarp + (2 * delta + 4)];
    val3 += helpE * spartc[cwarp + (3 * delta + 4)];
    val4 += helpE * spartc[cwarp + (4 * delta + 4)];
    val5 += helpE * spartc[cwarp + (5 * delta + 4)];
    val6 += helpE * spartc[cwarp + (6 * delta + 4)];
    if ((warp == 31) && (clane >= 0)) {
      spartc[clane + (31 * order + 0 * delta)] = val0;
      spartc[clane + (31 * order + 2 * delta)] = val2;
      spartc[clane + (31 * order + 4 * delta)] = val4;
      spartc[clane + (31 * order + 6 * delta)] = val6;
    }
  }

  __syncthreads();
 if (warp < 17) {
  val1 += sfacA[tid] * spartc[31 * order + (0 * delta + 0)];
  val3 += sfacA[tid] * spartc[31 * order + (2 * delta + 0)];
  val5 += sfacA[tid] * spartc[31 * order + (4 * delta + 0)];
  val1 += sfacB[tid] * spartc[31 * order + (0 * delta + 1)];
  val3 += sfacB[tid] * spartc[31 * order + (2 * delta + 1)];
  val5 += sfacB[tid] * spartc[31 * order + (4 * delta + 1)];
  val1 += sfacC[tid] * spartc[31 * order + (0 * delta + 2)];
  val3 += sfacC[tid] * spartc[31 * order + (2 * delta + 2)];
  val5 += sfacC[tid] * spartc[31 * order + (4 * delta + 2)];
  val1 += sfacD[tid] * spartc[31 * order + (0 * delta + 3)];
  val3 += sfacD[tid] * spartc[31 * order + (2 * delta + 3)];
  val5 += sfacD[tid] * spartc[31 * order + (4 * delta + 3)];
  val1 += sfacE[tid] * spartc[31 * order + (0 * delta + 4)];
  val3 += sfacE[tid] * spartc[31 * order + (2 * delta + 4)];
  val5 += sfacE[tid] * spartc[31 * order + (4 * delta + 4)];
 }
  if ((warp == 31) && (clane >= 0)) {
    spartc[clane + (31 * order + 1 * delta)] = val1;
    spartc[clane + (31 * order + 5 * delta)] = val5;
  }

  __syncthreads();
 if (warp < 17) {
  val2 += sfacA[tid] * spartc[31 * order + (1 * delta + 0)];
  val6 += sfacA[tid] * spartc[31 * order + (5 * delta + 0)];
  val2 += sfacB[tid] * spartc[31 * order + (1 * delta + 1)];
  val6 += sfacB[tid] * spartc[31 * order + (5 * delta + 1)];
  val2 += sfacC[tid] * spartc[31 * order + (1 * delta + 2)];
  val6 += sfacC[tid] * spartc[31 * order + (5 * delta + 2)];
  val2 += sfacD[tid] * spartc[31 * order + (1 * delta + 3)];
  val6 += sfacD[tid] * spartc[31 * order + (5 * delta + 3)];
  val2 += sfacE[tid] * spartc[31 * order + (1 * delta + 4)];
  val6 += sfacE[tid] * spartc[31 * order + (5 * delta + 4)];
 }
  if ((warp == 31) && (clane >= 0)) {
    spartc[clane + (31 * order + 3 * delta)] = val3;
  }

  __syncthreads();
 if (warp < 17) {
  val4 += sfacA[tid] * spartc[31 * order + (3 * delta + 0)];
  val4 += sfacB[tid] * spartc[31 * order + (3 * delta + 1)];
  val4 += sfacC[tid] * spartc[31 * order + (3 * delta + 2)];
  val4 += sfacD[tid] * spartc[31 * order + (3 * delta + 3)];
  val4 += sfacE[tid] * spartc[31 * order + (3 * delta + 4)];
 }

  const int idx = tid - (block_size - order);
  if (idx >= 0) {
    fullcarry[chunk_id * order + idx] = val6;
    __threadfence();
    if (idx == 0) {
      status[chunk_id] = 2;
    }
  }

  if (chunk_id > 0) {
    __syncthreads();
    if (warp == 0) {
      const int cidm1 = chunk_id - 1;
      int flag = 1;
      do {
        if ((cidm1 - lane) >= 0) {
          flag = status[cidm1 - lane];
        }
      } while ((__any(flag == 0)) || (__all(flag != 2)));
      int mask = __ballot(flag == 2);
      const int pos = __ffs(mask) - 1;
      T fc;
      if (lane < order) {
        fc = fullcarry[(cidm1 - pos) * order + lane];
      }
      T X0 = __shfl(fc, 0);
      T X1 = __shfl(fc, 1);
      T X2 = __shfl(fc, 2);
      T X3 = __shfl(fc, 3);
      T X4 = __shfl(fc, 4);
      if (lane == 0) {
        sfullc[0] = X0;
        sfullc[1] = X1;
        sfullc[2] = X2;
        sfullc[3] = X3;
        sfullc[4] = X4;
      }
    }

    __syncthreads();
    T X0 = sfullc[0];
    val0 += sfacA[tid] * X0;
    T X1 = sfullc[1];
    val0 += sfacB[tid] * X1;
    T X2 = sfullc[2];
    val0 += sfacC[tid] * X2;
    T X3 = sfullc[3];
    val0 += sfacD[tid] * X3;
    T X4 = sfullc[4];
    val0 += sfacE[tid] * X4;
  }

  if (chunk_id == gridDim.x - 1) {
    if (offs + (0 * block_size) < items) output[offs + (0 * block_size)] = val0;
    if (offs + (1 * block_size) < items) output[offs + (1 * block_size)] = val1;
    if (offs + (2 * block_size) < items) output[offs + (2 * block_size)] = val2;
    if (offs + (3 * block_size) < items) output[offs + (3 * block_size)] = val3;
    if (offs + (4 * block_size) < items) output[offs + (4 * block_size)] = val4;
    if (offs + (5 * block_size) < items) output[offs + (5 * block_size)] = val5;
    if (offs + (6 * block_size) < items) output[offs + (6 * block_size)] = val6;
  } else {
    output[offs + (0 * block_size)] = val0;
    output[offs + (1 * block_size)] = val1;
    output[offs + (2 * block_size)] = val2;
    output[offs + (3 * block_size)] = val3;
    output[offs + (4 * block_size)] = val4;
    output[offs + (5 * block_size)] = val5;
    output[offs + (6 * block_size)] = val6;
  }
}

static __global__ __launch_bounds__(block_size, 2)
void Recurrence8(const int items, const T* const __restrict__ input, T* const __restrict__ output, volatile int* const __restrict__ status, volatile T* const __restrict__ partcarry, volatile T* const __restrict__ fullcarry)
{
  const int valsperthread = 8;
  const int chunk_size = valsperthread * block_size;
  __shared__ T spartc[chunk_size / warp_size * order];
  __shared__ T sfullc[order];
  __shared__ int cid;

  const int tid = threadIdx.x;
  const int warp = tid / warp_size;
  const int lane = tid % warp_size;

  __shared__ T sfacA[block_size];
  __shared__ T sfacB[block_size];
  __shared__ T sfacC[block_size];
  __shared__ T sfacD[block_size];
  __shared__ T sfacE[block_size];
  if (tid < 530) sfacA[tid] = facA[tid];
  else sfacA[tid] = 0;
  if (tid < 538) sfacB[tid] = facB[tid];
  else sfacB[tid] = 0;
  if (tid < 542) sfacC[tid] = facC[tid];
  else sfacC[tid] = 0;
  if (tid < 540) sfacD[tid] = facD[tid];
  else sfacD[tid] = 0;
  if (tid < 541) sfacE[tid] = facE[tid];
  else sfacE[tid] = 0;

  if (tid == 0) {
    cid = atomicInc(&counter, gridDim.x - 1);
  }

  __syncthreads();
  const int chunk_id = cid;
  const int offs = tid + chunk_id * chunk_size;

  T val0, val1, val2, val3, val4, val5, val6, val7;
  if (chunk_id == gridDim.x - 1) {
    val0 = 0;
    if (offs + (0 * block_size) < items) val0 = input[offs + (0 * block_size)];
    val1 = 0;
    if (offs + (1 * block_size) < items) val1 = input[offs + (1 * block_size)];
    val2 = 0;
    if (offs + (2 * block_size) < items) val2 = input[offs + (2 * block_size)];
    val3 = 0;
    if (offs + (3 * block_size) < items) val3 = input[offs + (3 * block_size)];
    val4 = 0;
    if (offs + (4 * block_size) < items) val4 = input[offs + (4 * block_size)];
    val5 = 0;
    if (offs + (5 * block_size) < items) val5 = input[offs + (5 * block_size)];
    val6 = 0;
    if (offs + (6 * block_size) < items) val6 = input[offs + (6 * block_size)];
    val7 = 0;
    if (offs + (7 * block_size) < items) val7 = input[offs + (7 * block_size)];
  } else {
    val0 = input[offs + (0 * block_size)];
    val1 = input[offs + (1 * block_size)];
    val2 = input[offs + (2 * block_size)];
    val3 = input[offs + (3 * block_size)];
    val4 = input[offs + (4 * block_size)];
    val5 = input[offs + (5 * block_size)];
    val6 = input[offs + (6 * block_size)];
    val7 = input[offs + (7 * block_size)];
  }

  val0 *= 2.085000e-01f;
  val1 *= 2.085000e-01f;
  val2 *= 2.085000e-01f;
  val3 *= 2.085000e-01f;
  val4 *= 2.085000e-01f;
  val5 *= 2.085000e-01f;
  val6 *= 2.085000e-01f;
  val7 *= 2.085000e-01f;

  const T sfA = sfacA[lane];
  const T sfB = sfacB[lane];
  const T sfC = sfacC[lane];
  const T sfD = sfacD[lane];
  const T sfE = sfacE[lane];

  int cond;
  T help, spc;

  help = -8.670000e-03f;
  cond = ((lane & 1) != 0);
  spc = help * __shfl(val0, 0, 2);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 2);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 2);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 0, 2);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 0, 2);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 0, 2);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 0, 2);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 0, 2);
  if (cond) val7 += spc;

  help = __shfl(sfD, lane % 2);
  cond = ((lane & 2) != 0);
  spc = help * __shfl(val0, 0, 4);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 4);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 4);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 0, 4);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 0, 4);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 0, 4);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 0, 4);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 0, 4);
  if (cond) val7 += spc;

  help = __shfl(sfE, lane % 2);
  cond = ((lane & 2) != 0);
  spc = help * __shfl(val0, 1, 4);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 1, 4);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 1, 4);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 1, 4);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 1, 4);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 1, 4);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 1, 4);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 1, 4);
  if (cond) val7 += spc;

  help = __shfl(sfB, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 0, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 0, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 0, 8);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 0, 8);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 0, 8);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 0, 8);
  if (cond) val7 += spc;

  help = __shfl(sfC, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 1, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 1, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 1, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 1, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 1, 8);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 1, 8);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 1, 8);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 1, 8);
  if (cond) val7 += spc;

  help = __shfl(sfD, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 2, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 2, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 2, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 2, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 2, 8);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 2, 8);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 2, 8);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 2, 8);
  if (cond) val7 += spc;

  help = __shfl(sfE, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 3, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 3, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 3, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 3, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 3, 8);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 3, 8);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 3, 8);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 3, 8);
  if (cond) val7 += spc;

  help = __shfl(sfA, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 3, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 3, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 3, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 3, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 3, 16);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 3, 16);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 3, 16);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 3, 16);
  if (cond) val7 += spc;

  help = __shfl(sfB, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 4, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 4, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 4, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 4, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 4, 16);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 4, 16);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 4, 16);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 4, 16);
  if (cond) val7 += spc;

  help = __shfl(sfC, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 5, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 5, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 5, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 5, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 5, 16);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 5, 16);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 5, 16);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 5, 16);
  if (cond) val7 += spc;

  help = __shfl(sfD, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 6, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 6, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 6, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 6, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 6, 16);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 6, 16);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 6, 16);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 6, 16);
  if (cond) val7 += spc;

  help = __shfl(sfE, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 7, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 7, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 7, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 7, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 7, 16);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 7, 16);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 7, 16);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 7, 16);
  if (cond) val7 += spc;

  help = __shfl(sfA, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 11, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 11, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 11, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 11, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 11, 32);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 11, 32);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 11, 32);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 11, 32);
  if (cond) val7 += spc;

  help = __shfl(sfB, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 12, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 12, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 12, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 12, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 12, 32);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 12, 32);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 12, 32);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 12, 32);
  if (cond) val7 += spc;

  help = __shfl(sfC, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 13, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 13, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 13, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 13, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 13, 32);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 13, 32);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 13, 32);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 13, 32);
  if (cond) val7 += spc;

  help = __shfl(sfD, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 14, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 14, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 14, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 14, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 14, 32);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 14, 32);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 14, 32);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 14, 32);
  if (cond) val7 += spc;

  help = __shfl(sfE, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 15, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 15, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 15, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 15, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 15, 32);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 15, 32);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 15, 32);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 15, 32);
  if (cond) val7 += spc;

  const int delta = block_size / warp_size * order;
  const int clane = lane - (warp_size - order);
  const int clwo = clane + warp * order;

  if (((warp & 1) == 0) && (clane >= 0)) {
    spartc[clwo + 0 * delta] = val0;
    spartc[clwo + 1 * delta] = val1;
    spartc[clwo + 2 * delta] = val2;
    spartc[clwo + 3 * delta] = val3;
    spartc[clwo + 4 * delta] = val4;
    spartc[clwo + 5 * delta] = val5;
    spartc[clwo + 6 * delta] = val6;
    spartc[clwo + 7 * delta] = val7;
  }

  __syncthreads();
  if ((warp & 1) != 0) {
    const int cwarp = ((warp & ~1) | 0) * order;
    const T helpA = sfacA[tid % (warp_size * 1)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    val6 += helpA * spartc[cwarp + (6 * delta + 0)];
    val7 += helpA * spartc[cwarp + (7 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 1)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    val6 += helpB * spartc[cwarp + (6 * delta + 1)];
    val7 += helpB * spartc[cwarp + (7 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 1)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    val6 += helpC * spartc[cwarp + (6 * delta + 2)];
    val7 += helpC * spartc[cwarp + (7 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 1)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    val6 += helpD * spartc[cwarp + (6 * delta + 3)];
    val7 += helpD * spartc[cwarp + (7 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 1)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    val2 += helpE * spartc[cwarp + (2 * delta + 4)];
    val3 += helpE * spartc[cwarp + (3 * delta + 4)];
    val4 += helpE * spartc[cwarp + (4 * delta + 4)];
    val5 += helpE * spartc[cwarp + (5 * delta + 4)];
    val6 += helpE * spartc[cwarp + (6 * delta + 4)];
    val7 += helpE * spartc[cwarp + (7 * delta + 4)];
    if (((warp & 3) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
      spartc[clwo + 3 * delta] = val3;
      spartc[clwo + 4 * delta] = val4;
      spartc[clwo + 5 * delta] = val5;
      spartc[clwo + 6 * delta] = val6;
      spartc[clwo + 7 * delta] = val7;
    }
  }

  __syncthreads();
  if ((warp & 2) != 0) {
    const int cwarp = ((warp & ~3) | 1) * order;
    const T helpA = sfacA[tid % (warp_size * 2)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    val6 += helpA * spartc[cwarp + (6 * delta + 0)];
    val7 += helpA * spartc[cwarp + (7 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 2)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    val6 += helpB * spartc[cwarp + (6 * delta + 1)];
    val7 += helpB * spartc[cwarp + (7 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 2)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    val6 += helpC * spartc[cwarp + (6 * delta + 2)];
    val7 += helpC * spartc[cwarp + (7 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 2)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    val6 += helpD * spartc[cwarp + (6 * delta + 3)];
    val7 += helpD * spartc[cwarp + (7 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 2)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    val2 += helpE * spartc[cwarp + (2 * delta + 4)];
    val3 += helpE * spartc[cwarp + (3 * delta + 4)];
    val4 += helpE * spartc[cwarp + (4 * delta + 4)];
    val5 += helpE * spartc[cwarp + (5 * delta + 4)];
    val6 += helpE * spartc[cwarp + (6 * delta + 4)];
    val7 += helpE * spartc[cwarp + (7 * delta + 4)];
    if (((warp & 7) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
      spartc[clwo + 3 * delta] = val3;
      spartc[clwo + 4 * delta] = val4;
      spartc[clwo + 5 * delta] = val5;
      spartc[clwo + 6 * delta] = val6;
      spartc[clwo + 7 * delta] = val7;
    }
  }

  __syncthreads();
  if ((warp & 4) != 0) {
    const int cwarp = ((warp & ~7) | 3) * order;
    const T helpA = sfacA[tid % (warp_size * 4)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    val6 += helpA * spartc[cwarp + (6 * delta + 0)];
    val7 += helpA * spartc[cwarp + (7 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 4)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    val6 += helpB * spartc[cwarp + (6 * delta + 1)];
    val7 += helpB * spartc[cwarp + (7 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 4)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    val6 += helpC * spartc[cwarp + (6 * delta + 2)];
    val7 += helpC * spartc[cwarp + (7 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 4)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    val6 += helpD * spartc[cwarp + (6 * delta + 3)];
    val7 += helpD * spartc[cwarp + (7 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 4)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    val2 += helpE * spartc[cwarp + (2 * delta + 4)];
    val3 += helpE * spartc[cwarp + (3 * delta + 4)];
    val4 += helpE * spartc[cwarp + (4 * delta + 4)];
    val5 += helpE * spartc[cwarp + (5 * delta + 4)];
    val6 += helpE * spartc[cwarp + (6 * delta + 4)];
    val7 += helpE * spartc[cwarp + (7 * delta + 4)];
    if (((warp & 15) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
      spartc[clwo + 3 * delta] = val3;
      spartc[clwo + 4 * delta] = val4;
      spartc[clwo + 5 * delta] = val5;
      spartc[clwo + 6 * delta] = val6;
      spartc[clwo + 7 * delta] = val7;
    }
  }

  __syncthreads();
  if ((warp & 8) != 0) {
    const int cwarp = ((warp & ~15) | 7) * order;
    const T helpA = sfacA[tid % (warp_size * 8)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    val6 += helpA * spartc[cwarp + (6 * delta + 0)];
    val7 += helpA * spartc[cwarp + (7 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 8)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    val6 += helpB * spartc[cwarp + (6 * delta + 1)];
    val7 += helpB * spartc[cwarp + (7 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 8)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    val6 += helpC * spartc[cwarp + (6 * delta + 2)];
    val7 += helpC * spartc[cwarp + (7 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 8)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    val6 += helpD * spartc[cwarp + (6 * delta + 3)];
    val7 += helpD * spartc[cwarp + (7 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 8)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    val2 += helpE * spartc[cwarp + (2 * delta + 4)];
    val3 += helpE * spartc[cwarp + (3 * delta + 4)];
    val4 += helpE * spartc[cwarp + (4 * delta + 4)];
    val5 += helpE * spartc[cwarp + (5 * delta + 4)];
    val6 += helpE * spartc[cwarp + (6 * delta + 4)];
    val7 += helpE * spartc[cwarp + (7 * delta + 4)];
    if ((warp == 15) && (clane >= 0)) {
      spartc[clane + (15 * order + 0 * delta)] = val0;
      spartc[clane + (15 * order + 1 * delta)] = val1;
      spartc[clane + (15 * order + 2 * delta)] = val2;
      spartc[clane + (15 * order + 3 * delta)] = val3;
      spartc[clane + (15 * order + 4 * delta)] = val4;
      spartc[clane + (15 * order + 5 * delta)] = val5;
      spartc[clane + (15 * order + 6 * delta)] = val6;
      spartc[clane + (15 * order + 7 * delta)] = val7;
    }
  }

  __syncthreads();
  if ((warp & 16) != 0) {
    const int cwarp = 15 * order;
    const T helpA = sfacA[tid % (warp_size * 16)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    val6 += helpA * spartc[cwarp + (6 * delta + 0)];
    val7 += helpA * spartc[cwarp + (7 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 16)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    val6 += helpB * spartc[cwarp + (6 * delta + 1)];
    val7 += helpB * spartc[cwarp + (7 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 16)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    val6 += helpC * spartc[cwarp + (6 * delta + 2)];
    val7 += helpC * spartc[cwarp + (7 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 16)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    val6 += helpD * spartc[cwarp + (6 * delta + 3)];
    val7 += helpD * spartc[cwarp + (7 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 16)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    val2 += helpE * spartc[cwarp + (2 * delta + 4)];
    val3 += helpE * spartc[cwarp + (3 * delta + 4)];
    val4 += helpE * spartc[cwarp + (4 * delta + 4)];
    val5 += helpE * spartc[cwarp + (5 * delta + 4)];
    val6 += helpE * spartc[cwarp + (6 * delta + 4)];
    val7 += helpE * spartc[cwarp + (7 * delta + 4)];
    if ((warp == 31) && (clane >= 0)) {
      spartc[clane + (31 * order + 0 * delta)] = val0;
      spartc[clane + (31 * order + 2 * delta)] = val2;
      spartc[clane + (31 * order + 4 * delta)] = val4;
      spartc[clane + (31 * order + 6 * delta)] = val6;
    }
  }

  __syncthreads();
 if (warp < 17) {
  val1 += sfacA[tid] * spartc[31 * order + (0 * delta + 0)];
  val3 += sfacA[tid] * spartc[31 * order + (2 * delta + 0)];
  val5 += sfacA[tid] * spartc[31 * order + (4 * delta + 0)];
  val7 += sfacA[tid] * spartc[31 * order + (6 * delta + 0)];
  val1 += sfacB[tid] * spartc[31 * order + (0 * delta + 1)];
  val3 += sfacB[tid] * spartc[31 * order + (2 * delta + 1)];
  val5 += sfacB[tid] * spartc[31 * order + (4 * delta + 1)];
  val7 += sfacB[tid] * spartc[31 * order + (6 * delta + 1)];
  val1 += sfacC[tid] * spartc[31 * order + (0 * delta + 2)];
  val3 += sfacC[tid] * spartc[31 * order + (2 * delta + 2)];
  val5 += sfacC[tid] * spartc[31 * order + (4 * delta + 2)];
  val7 += sfacC[tid] * spartc[31 * order + (6 * delta + 2)];
  val1 += sfacD[tid] * spartc[31 * order + (0 * delta + 3)];
  val3 += sfacD[tid] * spartc[31 * order + (2 * delta + 3)];
  val5 += sfacD[tid] * spartc[31 * order + (4 * delta + 3)];
  val7 += sfacD[tid] * spartc[31 * order + (6 * delta + 3)];
  val1 += sfacE[tid] * spartc[31 * order + (0 * delta + 4)];
  val3 += sfacE[tid] * spartc[31 * order + (2 * delta + 4)];
  val5 += sfacE[tid] * spartc[31 * order + (4 * delta + 4)];
  val7 += sfacE[tid] * spartc[31 * order + (6 * delta + 4)];
 }
  if ((warp == 31) && (clane >= 0)) {
    spartc[clane + (31 * order + 1 * delta)] = val1;
    spartc[clane + (31 * order + 5 * delta)] = val5;
  }

  __syncthreads();
 if (warp < 17) {
  val2 += sfacA[tid] * spartc[31 * order + (1 * delta + 0)];
  val6 += sfacA[tid] * spartc[31 * order + (5 * delta + 0)];
  val2 += sfacB[tid] * spartc[31 * order + (1 * delta + 1)];
  val6 += sfacB[tid] * spartc[31 * order + (5 * delta + 1)];
  val2 += sfacC[tid] * spartc[31 * order + (1 * delta + 2)];
  val6 += sfacC[tid] * spartc[31 * order + (5 * delta + 2)];
  val2 += sfacD[tid] * spartc[31 * order + (1 * delta + 3)];
  val6 += sfacD[tid] * spartc[31 * order + (5 * delta + 3)];
  val2 += sfacE[tid] * spartc[31 * order + (1 * delta + 4)];
  val6 += sfacE[tid] * spartc[31 * order + (5 * delta + 4)];
 }
  if ((warp == 31) && (clane >= 0)) {
    spartc[clane + (31 * order + 3 * delta)] = val3;
  }

  __syncthreads();
 if (warp < 17) {
  val4 += sfacA[tid] * spartc[31 * order + (3 * delta + 0)];
  val4 += sfacB[tid] * spartc[31 * order + (3 * delta + 1)];
  val4 += sfacC[tid] * spartc[31 * order + (3 * delta + 2)];
  val4 += sfacD[tid] * spartc[31 * order + (3 * delta + 3)];
  val4 += sfacE[tid] * spartc[31 * order + (3 * delta + 4)];
 }

  const int idx = tid - (block_size - order);
  if (idx >= 0) {
    fullcarry[chunk_id * order + idx] = val7;
    __threadfence();
    if (idx == 0) {
      status[chunk_id] = 2;
    }
  }

  if (chunk_id > 0) {
    __syncthreads();
    if (warp == 0) {
      const int cidm1 = chunk_id - 1;
      int flag = 1;
      do {
        if ((cidm1 - lane) >= 0) {
          flag = status[cidm1 - lane];
        }
      } while ((__any(flag == 0)) || (__all(flag != 2)));
      int mask = __ballot(flag == 2);
      const int pos = __ffs(mask) - 1;
      T fc;
      if (lane < order) {
        fc = fullcarry[(cidm1 - pos) * order + lane];
      }
      T X0 = __shfl(fc, 0);
      T X1 = __shfl(fc, 1);
      T X2 = __shfl(fc, 2);
      T X3 = __shfl(fc, 3);
      T X4 = __shfl(fc, 4);
      if (lane == 0) {
        sfullc[0] = X0;
        sfullc[1] = X1;
        sfullc[2] = X2;
        sfullc[3] = X3;
        sfullc[4] = X4;
      }
    }

    __syncthreads();
    T X0 = sfullc[0];
    val0 += sfacA[tid] * X0;
    T X1 = sfullc[1];
    val0 += sfacB[tid] * X1;
    T X2 = sfullc[2];
    val0 += sfacC[tid] * X2;
    T X3 = sfullc[3];
    val0 += sfacD[tid] * X3;
    T X4 = sfullc[4];
    val0 += sfacE[tid] * X4;
  }

  if (chunk_id == gridDim.x - 1) {
    if (offs + (0 * block_size) < items) output[offs + (0 * block_size)] = val0;
    if (offs + (1 * block_size) < items) output[offs + (1 * block_size)] = val1;
    if (offs + (2 * block_size) < items) output[offs + (2 * block_size)] = val2;
    if (offs + (3 * block_size) < items) output[offs + (3 * block_size)] = val3;
    if (offs + (4 * block_size) < items) output[offs + (4 * block_size)] = val4;
    if (offs + (5 * block_size) < items) output[offs + (5 * block_size)] = val5;
    if (offs + (6 * block_size) < items) output[offs + (6 * block_size)] = val6;
    if (offs + (7 * block_size) < items) output[offs + (7 * block_size)] = val7;
  } else {
    output[offs + (0 * block_size)] = val0;
    output[offs + (1 * block_size)] = val1;
    output[offs + (2 * block_size)] = val2;
    output[offs + (3 * block_size)] = val3;
    output[offs + (4 * block_size)] = val4;
    output[offs + (5 * block_size)] = val5;
    output[offs + (6 * block_size)] = val6;
    output[offs + (7 * block_size)] = val7;
  }
}

static __global__ __launch_bounds__(block_size, 2)
void Recurrence9(const int items, const T* const __restrict__ input, T* const __restrict__ output, volatile int* const __restrict__ status, volatile T* const __restrict__ partcarry, volatile T* const __restrict__ fullcarry)
{
  const int valsperthread = 9;
  const int chunk_size = valsperthread * block_size;
  __shared__ T spartc[chunk_size / warp_size * order];
  __shared__ T sfullc[order];
  __shared__ int cid;

  const int tid = threadIdx.x;
  const int warp = tid / warp_size;
  const int lane = tid % warp_size;

  __shared__ T sfacA[block_size];
  __shared__ T sfacB[block_size];
  __shared__ T sfacC[block_size];
  __shared__ T sfacD[block_size];
  __shared__ T sfacE[block_size];
  if (tid < 530) sfacA[tid] = facA[tid];
  else sfacA[tid] = 0;
  if (tid < 538) sfacB[tid] = facB[tid];
  else sfacB[tid] = 0;
  if (tid < 542) sfacC[tid] = facC[tid];
  else sfacC[tid] = 0;
  if (tid < 540) sfacD[tid] = facD[tid];
  else sfacD[tid] = 0;
  if (tid < 541) sfacE[tid] = facE[tid];
  else sfacE[tid] = 0;

  if (tid == 0) {
    cid = atomicInc(&counter, gridDim.x - 1);
  }

  __syncthreads();
  const int chunk_id = cid;
  const int offs = tid + chunk_id * chunk_size;

  T val0, val1, val2, val3, val4, val5, val6, val7, val8;
  if (chunk_id == gridDim.x - 1) {
    val0 = 0;
    if (offs + (0 * block_size) < items) val0 = input[offs + (0 * block_size)];
    val1 = 0;
    if (offs + (1 * block_size) < items) val1 = input[offs + (1 * block_size)];
    val2 = 0;
    if (offs + (2 * block_size) < items) val2 = input[offs + (2 * block_size)];
    val3 = 0;
    if (offs + (3 * block_size) < items) val3 = input[offs + (3 * block_size)];
    val4 = 0;
    if (offs + (4 * block_size) < items) val4 = input[offs + (4 * block_size)];
    val5 = 0;
    if (offs + (5 * block_size) < items) val5 = input[offs + (5 * block_size)];
    val6 = 0;
    if (offs + (6 * block_size) < items) val6 = input[offs + (6 * block_size)];
    val7 = 0;
    if (offs + (7 * block_size) < items) val7 = input[offs + (7 * block_size)];
    val8 = 0;
    if (offs + (8 * block_size) < items) val8 = input[offs + (8 * block_size)];
  } else {
    val0 = input[offs + (0 * block_size)];
    val1 = input[offs + (1 * block_size)];
    val2 = input[offs + (2 * block_size)];
    val3 = input[offs + (3 * block_size)];
    val4 = input[offs + (4 * block_size)];
    val5 = input[offs + (5 * block_size)];
    val6 = input[offs + (6 * block_size)];
    val7 = input[offs + (7 * block_size)];
    val8 = input[offs + (8 * block_size)];
  }

  val0 *= 2.085000e-01f;
  val1 *= 2.085000e-01f;
  val2 *= 2.085000e-01f;
  val3 *= 2.085000e-01f;
  val4 *= 2.085000e-01f;
  val5 *= 2.085000e-01f;
  val6 *= 2.085000e-01f;
  val7 *= 2.085000e-01f;
  val8 *= 2.085000e-01f;

  const T sfA = sfacA[lane];
  const T sfB = sfacB[lane];
  const T sfC = sfacC[lane];
  const T sfD = sfacD[lane];
  const T sfE = sfacE[lane];

  int cond;
  T help, spc;

  help = -8.670000e-03f;
  cond = ((lane & 1) != 0);
  spc = help * __shfl(val0, 0, 2);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 2);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 2);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 0, 2);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 0, 2);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 0, 2);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 0, 2);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 0, 2);
  if (cond) val7 += spc;
  spc = help * __shfl(val8, 0, 2);
  if (cond) val8 += spc;

  help = __shfl(sfD, lane % 2);
  cond = ((lane & 2) != 0);
  spc = help * __shfl(val0, 0, 4);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 4);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 4);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 0, 4);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 0, 4);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 0, 4);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 0, 4);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 0, 4);
  if (cond) val7 += spc;
  spc = help * __shfl(val8, 0, 4);
  if (cond) val8 += spc;

  help = __shfl(sfE, lane % 2);
  cond = ((lane & 2) != 0);
  spc = help * __shfl(val0, 1, 4);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 1, 4);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 1, 4);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 1, 4);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 1, 4);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 1, 4);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 1, 4);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 1, 4);
  if (cond) val7 += spc;
  spc = help * __shfl(val8, 1, 4);
  if (cond) val8 += spc;

  help = __shfl(sfB, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 0, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 0, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 0, 8);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 0, 8);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 0, 8);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 0, 8);
  if (cond) val7 += spc;
  spc = help * __shfl(val8, 0, 8);
  if (cond) val8 += spc;

  help = __shfl(sfC, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 1, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 1, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 1, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 1, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 1, 8);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 1, 8);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 1, 8);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 1, 8);
  if (cond) val7 += spc;
  spc = help * __shfl(val8, 1, 8);
  if (cond) val8 += spc;

  help = __shfl(sfD, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 2, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 2, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 2, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 2, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 2, 8);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 2, 8);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 2, 8);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 2, 8);
  if (cond) val7 += spc;
  spc = help * __shfl(val8, 2, 8);
  if (cond) val8 += spc;

  help = __shfl(sfE, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 3, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 3, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 3, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 3, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 3, 8);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 3, 8);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 3, 8);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 3, 8);
  if (cond) val7 += spc;
  spc = help * __shfl(val8, 3, 8);
  if (cond) val8 += spc;

  help = __shfl(sfA, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 3, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 3, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 3, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 3, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 3, 16);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 3, 16);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 3, 16);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 3, 16);
  if (cond) val7 += spc;
  spc = help * __shfl(val8, 3, 16);
  if (cond) val8 += spc;

  help = __shfl(sfB, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 4, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 4, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 4, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 4, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 4, 16);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 4, 16);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 4, 16);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 4, 16);
  if (cond) val7 += spc;
  spc = help * __shfl(val8, 4, 16);
  if (cond) val8 += spc;

  help = __shfl(sfC, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 5, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 5, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 5, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 5, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 5, 16);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 5, 16);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 5, 16);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 5, 16);
  if (cond) val7 += spc;
  spc = help * __shfl(val8, 5, 16);
  if (cond) val8 += spc;

  help = __shfl(sfD, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 6, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 6, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 6, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 6, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 6, 16);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 6, 16);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 6, 16);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 6, 16);
  if (cond) val7 += spc;
  spc = help * __shfl(val8, 6, 16);
  if (cond) val8 += spc;

  help = __shfl(sfE, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 7, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 7, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 7, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 7, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 7, 16);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 7, 16);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 7, 16);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 7, 16);
  if (cond) val7 += spc;
  spc = help * __shfl(val8, 7, 16);
  if (cond) val8 += spc;

  help = __shfl(sfA, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 11, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 11, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 11, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 11, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 11, 32);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 11, 32);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 11, 32);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 11, 32);
  if (cond) val7 += spc;
  spc = help * __shfl(val8, 11, 32);
  if (cond) val8 += spc;

  help = __shfl(sfB, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 12, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 12, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 12, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 12, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 12, 32);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 12, 32);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 12, 32);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 12, 32);
  if (cond) val7 += spc;
  spc = help * __shfl(val8, 12, 32);
  if (cond) val8 += spc;

  help = __shfl(sfC, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 13, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 13, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 13, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 13, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 13, 32);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 13, 32);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 13, 32);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 13, 32);
  if (cond) val7 += spc;
  spc = help * __shfl(val8, 13, 32);
  if (cond) val8 += spc;

  help = __shfl(sfD, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 14, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 14, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 14, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 14, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 14, 32);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 14, 32);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 14, 32);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 14, 32);
  if (cond) val7 += spc;
  spc = help * __shfl(val8, 14, 32);
  if (cond) val8 += spc;

  help = __shfl(sfE, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 15, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 15, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 15, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 15, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 15, 32);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 15, 32);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 15, 32);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 15, 32);
  if (cond) val7 += spc;
  spc = help * __shfl(val8, 15, 32);
  if (cond) val8 += spc;

  const int delta = block_size / warp_size * order;
  const int clane = lane - (warp_size - order);
  const int clwo = clane + warp * order;

  if (((warp & 1) == 0) && (clane >= 0)) {
    spartc[clwo + 0 * delta] = val0;
    spartc[clwo + 1 * delta] = val1;
    spartc[clwo + 2 * delta] = val2;
    spartc[clwo + 3 * delta] = val3;
    spartc[clwo + 4 * delta] = val4;
    spartc[clwo + 5 * delta] = val5;
    spartc[clwo + 6 * delta] = val6;
    spartc[clwo + 7 * delta] = val7;
    spartc[clwo + 8 * delta] = val8;
  }

  __syncthreads();
  if ((warp & 1) != 0) {
    const int cwarp = ((warp & ~1) | 0) * order;
    const T helpA = sfacA[tid % (warp_size * 1)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    val6 += helpA * spartc[cwarp + (6 * delta + 0)];
    val7 += helpA * spartc[cwarp + (7 * delta + 0)];
    val8 += helpA * spartc[cwarp + (8 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 1)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    val6 += helpB * spartc[cwarp + (6 * delta + 1)];
    val7 += helpB * spartc[cwarp + (7 * delta + 1)];
    val8 += helpB * spartc[cwarp + (8 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 1)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    val6 += helpC * spartc[cwarp + (6 * delta + 2)];
    val7 += helpC * spartc[cwarp + (7 * delta + 2)];
    val8 += helpC * spartc[cwarp + (8 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 1)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    val6 += helpD * spartc[cwarp + (6 * delta + 3)];
    val7 += helpD * spartc[cwarp + (7 * delta + 3)];
    val8 += helpD * spartc[cwarp + (8 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 1)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    val2 += helpE * spartc[cwarp + (2 * delta + 4)];
    val3 += helpE * spartc[cwarp + (3 * delta + 4)];
    val4 += helpE * spartc[cwarp + (4 * delta + 4)];
    val5 += helpE * spartc[cwarp + (5 * delta + 4)];
    val6 += helpE * spartc[cwarp + (6 * delta + 4)];
    val7 += helpE * spartc[cwarp + (7 * delta + 4)];
    val8 += helpE * spartc[cwarp + (8 * delta + 4)];
    if (((warp & 3) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
      spartc[clwo + 3 * delta] = val3;
      spartc[clwo + 4 * delta] = val4;
      spartc[clwo + 5 * delta] = val5;
      spartc[clwo + 6 * delta] = val6;
      spartc[clwo + 7 * delta] = val7;
      spartc[clwo + 8 * delta] = val8;
    }
  }

  __syncthreads();
  if ((warp & 2) != 0) {
    const int cwarp = ((warp & ~3) | 1) * order;
    const T helpA = sfacA[tid % (warp_size * 2)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    val6 += helpA * spartc[cwarp + (6 * delta + 0)];
    val7 += helpA * spartc[cwarp + (7 * delta + 0)];
    val8 += helpA * spartc[cwarp + (8 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 2)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    val6 += helpB * spartc[cwarp + (6 * delta + 1)];
    val7 += helpB * spartc[cwarp + (7 * delta + 1)];
    val8 += helpB * spartc[cwarp + (8 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 2)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    val6 += helpC * spartc[cwarp + (6 * delta + 2)];
    val7 += helpC * spartc[cwarp + (7 * delta + 2)];
    val8 += helpC * spartc[cwarp + (8 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 2)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    val6 += helpD * spartc[cwarp + (6 * delta + 3)];
    val7 += helpD * spartc[cwarp + (7 * delta + 3)];
    val8 += helpD * spartc[cwarp + (8 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 2)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    val2 += helpE * spartc[cwarp + (2 * delta + 4)];
    val3 += helpE * spartc[cwarp + (3 * delta + 4)];
    val4 += helpE * spartc[cwarp + (4 * delta + 4)];
    val5 += helpE * spartc[cwarp + (5 * delta + 4)];
    val6 += helpE * spartc[cwarp + (6 * delta + 4)];
    val7 += helpE * spartc[cwarp + (7 * delta + 4)];
    val8 += helpE * spartc[cwarp + (8 * delta + 4)];
    if (((warp & 7) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
      spartc[clwo + 3 * delta] = val3;
      spartc[clwo + 4 * delta] = val4;
      spartc[clwo + 5 * delta] = val5;
      spartc[clwo + 6 * delta] = val6;
      spartc[clwo + 7 * delta] = val7;
      spartc[clwo + 8 * delta] = val8;
    }
  }

  __syncthreads();
  if ((warp & 4) != 0) {
    const int cwarp = ((warp & ~7) | 3) * order;
    const T helpA = sfacA[tid % (warp_size * 4)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    val6 += helpA * spartc[cwarp + (6 * delta + 0)];
    val7 += helpA * spartc[cwarp + (7 * delta + 0)];
    val8 += helpA * spartc[cwarp + (8 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 4)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    val6 += helpB * spartc[cwarp + (6 * delta + 1)];
    val7 += helpB * spartc[cwarp + (7 * delta + 1)];
    val8 += helpB * spartc[cwarp + (8 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 4)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    val6 += helpC * spartc[cwarp + (6 * delta + 2)];
    val7 += helpC * spartc[cwarp + (7 * delta + 2)];
    val8 += helpC * spartc[cwarp + (8 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 4)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    val6 += helpD * spartc[cwarp + (6 * delta + 3)];
    val7 += helpD * spartc[cwarp + (7 * delta + 3)];
    val8 += helpD * spartc[cwarp + (8 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 4)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    val2 += helpE * spartc[cwarp + (2 * delta + 4)];
    val3 += helpE * spartc[cwarp + (3 * delta + 4)];
    val4 += helpE * spartc[cwarp + (4 * delta + 4)];
    val5 += helpE * spartc[cwarp + (5 * delta + 4)];
    val6 += helpE * spartc[cwarp + (6 * delta + 4)];
    val7 += helpE * spartc[cwarp + (7 * delta + 4)];
    val8 += helpE * spartc[cwarp + (8 * delta + 4)];
    if (((warp & 15) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
      spartc[clwo + 3 * delta] = val3;
      spartc[clwo + 4 * delta] = val4;
      spartc[clwo + 5 * delta] = val5;
      spartc[clwo + 6 * delta] = val6;
      spartc[clwo + 7 * delta] = val7;
      spartc[clwo + 8 * delta] = val8;
    }
  }

  __syncthreads();
  if ((warp & 8) != 0) {
    const int cwarp = ((warp & ~15) | 7) * order;
    const T helpA = sfacA[tid % (warp_size * 8)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    val6 += helpA * spartc[cwarp + (6 * delta + 0)];
    val7 += helpA * spartc[cwarp + (7 * delta + 0)];
    val8 += helpA * spartc[cwarp + (8 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 8)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    val6 += helpB * spartc[cwarp + (6 * delta + 1)];
    val7 += helpB * spartc[cwarp + (7 * delta + 1)];
    val8 += helpB * spartc[cwarp + (8 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 8)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    val6 += helpC * spartc[cwarp + (6 * delta + 2)];
    val7 += helpC * spartc[cwarp + (7 * delta + 2)];
    val8 += helpC * spartc[cwarp + (8 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 8)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    val6 += helpD * spartc[cwarp + (6 * delta + 3)];
    val7 += helpD * spartc[cwarp + (7 * delta + 3)];
    val8 += helpD * spartc[cwarp + (8 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 8)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    val2 += helpE * spartc[cwarp + (2 * delta + 4)];
    val3 += helpE * spartc[cwarp + (3 * delta + 4)];
    val4 += helpE * spartc[cwarp + (4 * delta + 4)];
    val5 += helpE * spartc[cwarp + (5 * delta + 4)];
    val6 += helpE * spartc[cwarp + (6 * delta + 4)];
    val7 += helpE * spartc[cwarp + (7 * delta + 4)];
    val8 += helpE * spartc[cwarp + (8 * delta + 4)];
    if ((warp == 15) && (clane >= 0)) {
      spartc[clane + (15 * order + 0 * delta)] = val0;
      spartc[clane + (15 * order + 1 * delta)] = val1;
      spartc[clane + (15 * order + 2 * delta)] = val2;
      spartc[clane + (15 * order + 3 * delta)] = val3;
      spartc[clane + (15 * order + 4 * delta)] = val4;
      spartc[clane + (15 * order + 5 * delta)] = val5;
      spartc[clane + (15 * order + 6 * delta)] = val6;
      spartc[clane + (15 * order + 7 * delta)] = val7;
      spartc[clane + (15 * order + 8 * delta)] = val8;
    }
  }

  __syncthreads();
  if ((warp & 16) != 0) {
    const int cwarp = 15 * order;
    const T helpA = sfacA[tid % (warp_size * 16)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    val6 += helpA * spartc[cwarp + (6 * delta + 0)];
    val7 += helpA * spartc[cwarp + (7 * delta + 0)];
    val8 += helpA * spartc[cwarp + (8 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 16)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    val6 += helpB * spartc[cwarp + (6 * delta + 1)];
    val7 += helpB * spartc[cwarp + (7 * delta + 1)];
    val8 += helpB * spartc[cwarp + (8 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 16)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    val6 += helpC * spartc[cwarp + (6 * delta + 2)];
    val7 += helpC * spartc[cwarp + (7 * delta + 2)];
    val8 += helpC * spartc[cwarp + (8 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 16)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    val6 += helpD * spartc[cwarp + (6 * delta + 3)];
    val7 += helpD * spartc[cwarp + (7 * delta + 3)];
    val8 += helpD * spartc[cwarp + (8 * delta + 3)];
    const T helpE = sfacE[tid % (warp_size * 16)];
    val0 += helpE * spartc[cwarp + (0 * delta + 4)];
    val1 += helpE * spartc[cwarp + (1 * delta + 4)];
    val2 += helpE * spartc[cwarp + (2 * delta + 4)];
    val3 += helpE * spartc[cwarp + (3 * delta + 4)];
    val4 += helpE * spartc[cwarp + (4 * delta + 4)];
    val5 += helpE * spartc[cwarp + (5 * delta + 4)];
    val6 += helpE * spartc[cwarp + (6 * delta + 4)];
    val7 += helpE * spartc[cwarp + (7 * delta + 4)];
    val8 += helpE * spartc[cwarp + (8 * delta + 4)];
    if ((warp == 31) && (clane >= 0)) {
      spartc[clane + (31 * order + 0 * delta)] = val0;
      spartc[clane + (31 * order + 2 * delta)] = val2;
      spartc[clane + (31 * order + 4 * delta)] = val4;
      spartc[clane + (31 * order + 6 * delta)] = val6;
      spartc[clane + (31 * order + 8 * delta)] = val8;
    }
  }

  __syncthreads();
 if (warp < 17) {
  val1 += sfacA[tid] * spartc[31 * order + (0 * delta + 0)];
  val3 += sfacA[tid] * spartc[31 * order + (2 * delta + 0)];
  val5 += sfacA[tid] * spartc[31 * order + (4 * delta + 0)];
  val7 += sfacA[tid] * spartc[31 * order + (6 * delta + 0)];
  val1 += sfacB[tid] * spartc[31 * order + (0 * delta + 1)];
  val3 += sfacB[tid] * spartc[31 * order + (2 * delta + 1)];
  val5 += sfacB[tid] * spartc[31 * order + (4 * delta + 1)];
  val7 += sfacB[tid] * spartc[31 * order + (6 * delta + 1)];
  val1 += sfacC[tid] * spartc[31 * order + (0 * delta + 2)];
  val3 += sfacC[tid] * spartc[31 * order + (2 * delta + 2)];
  val5 += sfacC[tid] * spartc[31 * order + (4 * delta + 2)];
  val7 += sfacC[tid] * spartc[31 * order + (6 * delta + 2)];
  val1 += sfacD[tid] * spartc[31 * order + (0 * delta + 3)];
  val3 += sfacD[tid] * spartc[31 * order + (2 * delta + 3)];
  val5 += sfacD[tid] * spartc[31 * order + (4 * delta + 3)];
  val7 += sfacD[tid] * spartc[31 * order + (6 * delta + 3)];
  val1 += sfacE[tid] * spartc[31 * order + (0 * delta + 4)];
  val3 += sfacE[tid] * spartc[31 * order + (2 * delta + 4)];
  val5 += sfacE[tid] * spartc[31 * order + (4 * delta + 4)];
  val7 += sfacE[tid] * spartc[31 * order + (6 * delta + 4)];
 }
  if ((warp == 31) && (clane >= 0)) {
    spartc[clane + (31 * order + 1 * delta)] = val1;
    spartc[clane + (31 * order + 5 * delta)] = val5;
  }

  __syncthreads();
 if (warp < 17) {
  val2 += sfacA[tid] * spartc[31 * order + (1 * delta + 0)];
  val6 += sfacA[tid] * spartc[31 * order + (5 * delta + 0)];
  val2 += sfacB[tid] * spartc[31 * order + (1 * delta + 1)];
  val6 += sfacB[tid] * spartc[31 * order + (5 * delta + 1)];
  val2 += sfacC[tid] * spartc[31 * order + (1 * delta + 2)];
  val6 += sfacC[tid] * spartc[31 * order + (5 * delta + 2)];
  val2 += sfacD[tid] * spartc[31 * order + (1 * delta + 3)];
  val6 += sfacD[tid] * spartc[31 * order + (5 * delta + 3)];
  val2 += sfacE[tid] * spartc[31 * order + (1 * delta + 4)];
  val6 += sfacE[tid] * spartc[31 * order + (5 * delta + 4)];
 }
  if ((warp == 31) && (clane >= 0)) {
    spartc[clane + (31 * order + 3 * delta)] = val3;
  }

  __syncthreads();
 if (warp < 17) {
  val4 += sfacA[tid] * spartc[31 * order + (3 * delta + 0)];
  val4 += sfacB[tid] * spartc[31 * order + (3 * delta + 1)];
  val4 += sfacC[tid] * spartc[31 * order + (3 * delta + 2)];
  val4 += sfacD[tid] * spartc[31 * order + (3 * delta + 3)];
  val4 += sfacE[tid] * spartc[31 * order + (3 * delta + 4)];
 }
  if ((warp == 31) && (clane >= 0)) {
    spartc[clane + (31 * order + 7 * delta)] = val7;
  }

  __syncthreads();
 if (warp < 17) {
  val8 += sfacA[tid] * spartc[31 * order + (7 * delta + 0)];
  val8 += sfacB[tid] * spartc[31 * order + (7 * delta + 1)];
  val8 += sfacC[tid] * spartc[31 * order + (7 * delta + 2)];
  val8 += sfacD[tid] * spartc[31 * order + (7 * delta + 3)];
  val8 += sfacE[tid] * spartc[31 * order + (7 * delta + 4)];
 }

  const int idx = tid - (block_size - order);
  if (idx >= 0) {
    fullcarry[chunk_id * order + idx] = val8;
    __threadfence();
    if (idx == 0) {
      status[chunk_id] = 2;
    }
  }

  if (chunk_id > 0) {
    __syncthreads();
    if (warp == 0) {
      const int cidm1 = chunk_id - 1;
      int flag = 1;
      do {
        if ((cidm1 - lane) >= 0) {
          flag = status[cidm1 - lane];
        }
      } while ((__any(flag == 0)) || (__all(flag != 2)));
      int mask = __ballot(flag == 2);
      const int pos = __ffs(mask) - 1;
      T fc;
      if (lane < order) {
        fc = fullcarry[(cidm1 - pos) * order + lane];
      }
      T X0 = __shfl(fc, 0);
      T X1 = __shfl(fc, 1);
      T X2 = __shfl(fc, 2);
      T X3 = __shfl(fc, 3);
      T X4 = __shfl(fc, 4);
      if (lane == 0) {
        sfullc[0] = X0;
        sfullc[1] = X1;
        sfullc[2] = X2;
        sfullc[3] = X3;
        sfullc[4] = X4;
      }
    }

    __syncthreads();
    T X0 = sfullc[0];
    val0 += sfacA[tid] * X0;
    T X1 = sfullc[1];
    val0 += sfacB[tid] * X1;
    T X2 = sfullc[2];
    val0 += sfacC[tid] * X2;
    T X3 = sfullc[3];
    val0 += sfacD[tid] * X3;
    T X4 = sfullc[4];
    val0 += sfacE[tid] * X4;
  }

  if (chunk_id == gridDim.x - 1) {
    if (offs + (0 * block_size) < items) output[offs + (0 * block_size)] = val0;
    if (offs + (1 * block_size) < items) output[offs + (1 * block_size)] = val1;
    if (offs + (2 * block_size) < items) output[offs + (2 * block_size)] = val2;
    if (offs + (3 * block_size) < items) output[offs + (3 * block_size)] = val3;
    if (offs + (4 * block_size) < items) output[offs + (4 * block_size)] = val4;
    if (offs + (5 * block_size) < items) output[offs + (5 * block_size)] = val5;
    if (offs + (6 * block_size) < items) output[offs + (6 * block_size)] = val6;
    if (offs + (7 * block_size) < items) output[offs + (7 * block_size)] = val7;
    if (offs + (8 * block_size) < items) output[offs + (8 * block_size)] = val8;
  } else {
    output[offs + (0 * block_size)] = val0;
    output[offs + (1 * block_size)] = val1;
    output[offs + (2 * block_size)] = val2;
    output[offs + (3 * block_size)] = val3;
    output[offs + (4 * block_size)] = val4;
    output[offs + (5 * block_size)] = val5;
    output[offs + (6 * block_size)] = val6;
    output[offs + (7 * block_size)] = val7;
    output[offs + (8 * block_size)] = val8;
  }
}

struct GPUTimer
{
  cudaEvent_t beg, end;
  GPUTimer() {cudaEventCreate(&beg);  cudaEventCreate(&end);}
  ~GPUTimer() {cudaEventDestroy(beg);  cudaEventDestroy(end);}
  void start() {cudaEventRecord(beg, 0);}
  double stop() {cudaEventRecord(end, 0);  cudaEventSynchronize(end);  float ms;  cudaEventElapsedTime(&ms, beg, end);  return 0.001 * ms;}
};

int main(int argc, char *argv[])
{
  printf("Parallel Linear Recurrence Computation\n");
  printf("Copyright (c) 2018 Texas State University\n");

  if (argc != 2) {
    fprintf(stderr, "USAGE: %s problem_size\n", argv[0]);
    return -1;
  }

  const int n = atoi(argv[1]);
  if (n < 1) {fprintf(stderr, "ERROR: problem_size must be at least 1\n");  return -1;};

  int *d_status;
  T *h_in, *h_out, *h_sol, *d_in, *d_out, *d_partcarry, *d_fullcarry;

  const size_t size = n * sizeof(T);
  h_in = (T *)malloc(size);  assert(h_in != NULL);
  h_out = (T *)malloc(size);  assert(h_out != NULL);
  h_sol = (T *)malloc(size);  assert(h_sol != NULL);

  for (int i = 0; i < n; i++) {
    h_in[i] = (i & 32) / 16 - 1;
    h_sol[i] = 0;
  }
  for (int i = 0; i < n; i++) {
    if ((i - 0) >= 0) {
      h_sol[i] += 2.085000e-01f * h_in[i - 0];
    }
  }
  for (int i = 1; i < n; i++) {
    if ((i - 1) >= 0) {
      h_sol[i] += -8.670000e-03f * h_sol[i - 1];
    }
    if ((i - 2) >= 0) {
      h_sol[i] += -1.736000e-01f * h_sol[i - 2];
    }
    if ((i - 3) >= 0) {
      h_sol[i] += -1.133900e-01f * h_sol[i - 3];
    }
    if ((i - 4) >= 0) {
      h_sol[i] += -3.767000e-01f * h_sol[i - 4];
    }
    if ((i - 5) >= 0) {
      h_sol[i] += -1.190000e-01f * h_sol[i - 5];
    }
  }

  cudaSetDevice(device);
  cudaDeviceProp deviceProp;
  cudaGetDeviceProperties(&deviceProp, device);

  const int SMs = deviceProp.multiProcessorCount;
  int valsperthread = 1;
  while ((valsperthread < 9) && (block_size * 2 * SMs * valsperthread < n)) {
    valsperthread++;
  }
  const int chunk_size = valsperthread * block_size;
  const int iterations = 5;

  assert(cudaSuccess == cudaMalloc(&d_in, size));
  assert(cudaSuccess == cudaMalloc(&d_out, size));
  assert(cudaSuccess == cudaMalloc(&d_status, (n + chunk_size - 1) / chunk_size * sizeof(int)));
  assert(cudaSuccess == cudaMalloc(&d_partcarry, (n + chunk_size - 1) / chunk_size * order * sizeof(T)));
  assert(cudaSuccess == cudaMalloc(&d_fullcarry, (n + chunk_size - 1) / chunk_size * order * sizeof(T)));
  assert(cudaSuccess == cudaMemcpy(d_in, h_in, size, cudaMemcpyHostToDevice));
  assert(cudaSuccess == cudaMemcpy(d_out, d_in, size, cudaMemcpyDeviceToDevice));

  cudaMemset(d_status, 0, (n + chunk_size - 1) / chunk_size * sizeof(int));
  switch (valsperthread) {
    case 1:  Recurrence1<<<(n + chunk_size - 1) / chunk_size, block_size>>>(n, d_in, d_out, d_status, d_partcarry, d_fullcarry); break;
    case 2:  Recurrence2<<<(n + chunk_size - 1) / chunk_size, block_size>>>(n, d_in, d_out, d_status, d_partcarry, d_fullcarry); break;
    case 3:  Recurrence3<<<(n + chunk_size - 1) / chunk_size, block_size>>>(n, d_in, d_out, d_status, d_partcarry, d_fullcarry); break;
    case 4:  Recurrence4<<<(n + chunk_size - 1) / chunk_size, block_size>>>(n, d_in, d_out, d_status, d_partcarry, d_fullcarry); break;
    case 5:  Recurrence5<<<(n + chunk_size - 1) / chunk_size, block_size>>>(n, d_in, d_out, d_status, d_partcarry, d_fullcarry); break;
    case 6:  Recurrence6<<<(n + chunk_size - 1) / chunk_size, block_size>>>(n, d_in, d_out, d_status, d_partcarry, d_fullcarry); break;
    case 7:  Recurrence7<<<(n + chunk_size - 1) / chunk_size, block_size>>>(n, d_in, d_out, d_status, d_partcarry, d_fullcarry); break;
    case 8:  Recurrence8<<<(n + chunk_size - 1) / chunk_size, block_size>>>(n, d_in, d_out, d_status, d_partcarry, d_fullcarry); break;
    case 9:  Recurrence9<<<(n + chunk_size - 1) / chunk_size, block_size>>>(n, d_in, d_out, d_status, d_partcarry, d_fullcarry); break;
  }
  GPUTimer timer;
  timer.start();
  for (long i = 0; i < iterations; i++) {
    cudaMemset(d_status, 0, (n + chunk_size - 1) / chunk_size * sizeof(int));
    switch (valsperthread) {
      case 1:  Recurrence1<<<(n + chunk_size - 1) / chunk_size, block_size>>>(n, d_in, d_out, d_status, d_partcarry, d_fullcarry); break;
      case 2:  Recurrence2<<<(n + chunk_size - 1) / chunk_size, block_size>>>(n, d_in, d_out, d_status, d_partcarry, d_fullcarry); break;
      case 3:  Recurrence3<<<(n + chunk_size - 1) / chunk_size, block_size>>>(n, d_in, d_out, d_status, d_partcarry, d_fullcarry); break;
      case 4:  Recurrence4<<<(n + chunk_size - 1) / chunk_size, block_size>>>(n, d_in, d_out, d_status, d_partcarry, d_fullcarry); break;
      case 5:  Recurrence5<<<(n + chunk_size - 1) / chunk_size, block_size>>>(n, d_in, d_out, d_status, d_partcarry, d_fullcarry); break;
      case 6:  Recurrence6<<<(n + chunk_size - 1) / chunk_size, block_size>>>(n, d_in, d_out, d_status, d_partcarry, d_fullcarry); break;
      case 7:  Recurrence7<<<(n + chunk_size - 1) / chunk_size, block_size>>>(n, d_in, d_out, d_status, d_partcarry, d_fullcarry); break;
      case 8:  Recurrence8<<<(n + chunk_size - 1) / chunk_size, block_size>>>(n, d_in, d_out, d_status, d_partcarry, d_fullcarry); break;
      case 9:  Recurrence9<<<(n + chunk_size - 1) / chunk_size, block_size>>>(n, d_in, d_out, d_status, d_partcarry, d_fullcarry); break;
    }
  }
  double runtime = timer.stop() / iterations;
  double throughput = 0.000000001 * n / runtime;
  assert(cudaSuccess == cudaMemcpy(h_out, d_out, size, cudaMemcpyDeviceToHost));

  for (int i = 0; i < n; i++) {
    T s = h_sol[i];
    T o = h_out[i];
    if (fabsf(o - s) > 0.001) {
      printf("result not correct at index %d: %e != %e\n", i, h_sol[i], h_out[i]);
      return -1;
    }
  }
  printf("size = %d\tthroughput = %7.4f gigaitems/s\truntime = %7.4f s\tPassed!\n", n, throughput, runtime);

  printf("first elements of result are:\n");
  for (int i = 0; (i < 8) && (i < n); i++) {
    printf(" %f", h_out[i]);
  }
  printf("\n");

  free(h_in);  free(h_out);  free(h_sol);
  cudaFree(d_in);  cudaFree(d_out);  cudaFree(d_status);  cudaFree(d_partcarry);  cudaFree(d_fullcarry);

  return 0;
}
