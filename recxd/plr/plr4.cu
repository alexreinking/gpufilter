/*
PLR - Parallelized Linear Recurrences [float]
Copyright (c) 2018 Texas State University. All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted for academic, research, experimental, or personal use provided that the following conditions are met:
* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
* Neither the name of Texas State University nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

For all other uses, please contact the Office for Commercialization and Industry Relations at Texas State University http://www.txstate.edu/ocir/.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Authors: Sepideh Maleki and Martin Burtscher


non-recursive coefficients: (0.236670)
recursive coefficients: (-0.009840, -0.197090, -0.128710, -0.427660)

*/

#include <cstdio>
#include <cassert>
#include <cuda.h>

typedef float T;
static const int device = 0;
static const int order = 4;
static const int warp_size = 32;
static const int block_size = 1024;

static __device__ const T facA[511] = {-4.276600e-01f, 4.208175e-03f, 8.424610e-02f, 5.338575e-02f, 1.652220e-01f, -2.479056e-02f, -7.521964e-02f, -3.847054e-02f, -5.226448e-02f, 2.837989e-02f, 4.714152e-02f, 1.712201e-02f, 9.239047e-03f, -2.167002e-02f, -2.397201e-02f, -4.004727e-03f, 3.602027e-03f, 1.310669e-02f, 9.928423e-03f, -1.431848e-03f, -5.170108e-03f, -6.550015e-03f, -2.978267e-03f, 2.598037e-03f, 3.615523e-03f, 2.636888e-03f, 2.007619e-04f, -2.098111e-03f, -1.904531e-03f, -7.212745e-04f, 5.666513e-04f, 1.278990e-03f, 7.830604e-04f, -2.425499e-05f, -5.610476e-04f, -6.374596e-04f, -2.149123e-04f, 2.103370e-04f, 3.622724e-04f, 2.552572e-04f, -9.075084e-06f, -1.868001e-04f, -1.841568e-04f, -6.936671e-05f, 6.490214e-05f, 1.166226e-04f, 7.374558e-05f, -2.398996e-06f, -5.727746e-05f, -5.833020e-05f, -1.936647e-05f, 2.008500e-05f, 3.562226e-05f, 2.312907e-05f, -1.551257e-06f, -1.771774e-05f, -1.773108e-05f, -6.025255e-06f, 6.497767e-06f, 1.098291e-05f, 6.969666e-06f, -4.927708e-07f, -5.561248e-06f, -5.442175e-06f, -1.767605e-06f, 2.016518e-06f, 3.407320e-06f, 2.123945e-06f, -1.960603e-07f, -1.717620e-06f, -1.675005e-06f, -5.280838e-07f, 6.402450e-07f, 1.047927e-06f, 6.478047e-07f, -6.947599e-08f, -5.356781e-07f, -5.125713e-07f, -1.574774e-07f, 2.012315e-07f, 3.241182e-07f, 1.966251e-07f, -2.436897e-08f, -1.662890e-07f, -1.574809e-07f, -4.662866e-08f, 6.332142e-08f, 9.995146e-08f, 5.988630e-08f, -8.497603e-09f, -5.166416e-08f, -4.827004e-08f, -1.385978e-08f, 1.993370e-08f, 3.084301e-08f, 1.819483e-08f, -2.896280e-09f, -1.605217e-08f, -1.480340e-08f, -4.099033e-09f, 6.262634e-09f, 9.516469e-09f, 5.530462e-09f, -9.830918e-10f, -4.983468e-09f, -4.538844e-09f, -1.211770e-09f, 1.968336e-09f, 2.934884e-09f, 1.680231e-09f, -3.300888e-10f, -1.547436e-09f, -1.391111e-09f, -3.574090e-10f, 6.180272e-10f, 9.051867e-10f, 5.102105e-10f, -1.101205e-10f, -4.802859e-10f, -4.263517e-10f, -1.051682e-10f, 1.939762e-10f, 2.790937e-10f, 1.548927e-10f, -3.652117e-11f, -1.490465e-10f, -1.306289e-10f, -3.087981e-11f, 6.085191e-11f, 8.604176e-11f, 4.699932e-11f, -1.204664e-11f, -4.624292e-11f, -4.001660e-11f, -9.041424e-12f, 1.907963e-11f, 2.652101e-11f, 1.425585e-11f, -3.956388e-12f, -1.434387e-11f, -1.225594e-11f, -2.639799e-12f, 5.979687e-12f, 8.173198e-12f, 4.322183e-12f, -1.294095e-12f, -4.448370e-12f, -3.752833e-12f, -7.682044e-13f, 1.873187e-12f, 2.518390e-12f, 1.309844e-12f, -4.218061e-13f, -1.379236e-12f, -1.148899e-12f, -2.227386e-13f, 5.865394e-13f, 7.758469e-13f, 3.967716e-13f, -1.370530e-13f, -4.275498e-13f, -3.516483e-13f, -6.431725e-14f, 1.835813e-13f, 2.389764e-13f, 1.201306e-13f, -4.440478e-14f, -1.325086e-13f, -1.076070e-13f, -1.848474e-14f, 5.743549e-14f, 7.359673e-14f, 3.635425e-14f, -1.435024e-14f, -4.105935e-14f, -3.292122e-14f, -5.283905e-15f, 1.796221e-14f, 2.266139e-14f, 1.099602e-14f, -4.626735e-15f, -1.272014e-14f, -1.006962e-14f, -1.500952e-15f, 5.615269e-15f, 6.976525e-15f, 3.324198e-15f, -1.488558e-15f, -3.939893e-15f, -3.079290e-15f, -4.232202e-16f, 1.754762e-15f, 2.147416e-15f, 1.004385e-15f, -4.779784e-16f, -1.220086e-15f, -9.414278e-16f, -1.182842e-16f, 5.481594e-16f, 6.608720e-16f, 3.032956e-16f, -1.532039e-16f, -3.777557e-16f, -2.877536e-16f, -3.270515e-17f, 1.711753e-16f, 2.033493e-16f, 9.153230e-17f, -4.902407e-17f, -1.169356e-16f, -8.793267e-17f, -8.922715e-18f, 5.343487e-17f, 6.255928e-17f, 2.760667e-17f, -1.566317e-17f, -3.619083e-17f, -2.686418e-17f, -2.393065e-18f, 1.667484e-17f, 1.924263e-17f, 8.320956e-18f, -4.997209e-18f, -1.119869e-17f, -8.205198e-18f, -6.274605e-19f, 5.201826e-18f, 5.917801e-18f, 2.506337e-18f, -1.592189e-18f, -3.464600e-18f, -2.505501e-18f, -1.594372e-19f, 1.622222e-18f, 1.819615e-18f, 7.543949e-19f, -5.066624e-19f, -1.071660e-18f, -7.648713e-19f, -3.867217e-20f, 5.057416e-19f, 5.593982e-19f, 2.269012e-19f, -1.610400e-19f, -3.314209e-19f, -2.334361e-19f, -8.692363e-21f, 1.576210e-19f, 1.719432e-19f, 6.819265e-20f, -5.112933e-20f, -1.024760e-19f, -7.122486e-20f, -1.684566e-21f, 4.910994e-20f, 5.284100e-20f, 2.047781e-20f, -1.621645e-20f, -3.167992e-20f, -2.172585e-20f, -2.127429e-22f, 1.529669e-20f, 1.623598e-20f, 6.144072e-21f, -5.138263e-21f, -9.791891e-21f, -6.625230e-21f, 2.884792e-23f, 4.763227e-21f, 4.987778e-21f, 1.841769e-21f, -1.626576e-21f, -3.026007e-21f, -2.019769e-21f, 3.797604e-23f, 1.482802e-21f, 1.531991e-21f, 5.515663e-22f, -5.144598e-22f, -9.349634e-22f, -6.155685e-22f, 2.066240e-23f, 4.614721e-22f, 4.704630e-22f, 1.650137e-22f, -1.625798e-22f, -2.888292e-22f, -1.875522e-22f, 9.126761e-24f, 1.435789e-22f, 1.444489e-22f, 4.931451e-23f, -5.133789e-23f, -8.920923e-23f, -5.712630e-23f, 3.662227e-24f, 4.466027e-23f, 4.434270e-23f, 1.472084e-23f, -1.619877e-23f, -2.754869e-23f, -1.739462e-23f, 1.390163e-24f, 1.388798e-23f, 1.360969e-23f, 4.388954e-24f, -5.107560e-24f, -8.505800e-24f, -5.294876e-24f, 5.089236e-25f, 4.317640e-24f, 4.176305e-24f, 1.306845e-24f, -1.609337e-24f, -2.625744e-24f, -1.611221e-24f, 1.816150e-25f, 1.341977e-24f, 1.281307e-24f, 3.885807e-25f, -5.067517e-25f, -8.104257e-25f, -4.901275e-25f, 6.359326e-26f, 4.170007e-25f, 3.930341e-25f, 1.153687e-25f, -1.594668e-25f, -2.500908e-25f, -1.490439e-25f, 2.194338e-26f, 1.295459e-25f, 1.205377e-25f, 3.419747e-26f, -5.015143e-26f, -7.716249e-26f, -4.530708e-26f, 7.483879e-27f, 4.023528e-26f, 3.695987e-26f, 1.011912e-26f, -1.576323e-26f, -2.380339e-26f, -1.376769e-26f, 2.528227e-27f, 1.249363e-26f, 1.133057e-26f, 2.988619e-27f, -4.951827e-27f, -7.341687e-27f, -4.182099e-27f, 8.473618e-28f, 3.878559e-27f, 3.472852e-27f, 8.808544e-28f, -1.554724e-27f, -2.264004e-27f, -1.269876e-27f, 2.821105e-28f, 1.203797e-27f, 1.064223e-27f, 2.590364e-28f, -4.878848e-28f, -6.980447e-28f, -3.854403e-28f, 9.338650e-29f, 3.735417e-28f, 3.260546e-28f, 7.598792e-29f, -1.530260e-28f, -2.151860e-28f, -1.169436e-28f, 3.076072e-29f, 1.158854e-28f, 9.987531e-29f, 2.223025e-29f, -4.797392e-29f, -6.632381e-29f, -3.546613e-29f, 1.008848e-29f, 3.594381e-29f, 3.058686e-29f, 6.483815e-30f, -1.503293e-29f, -2.043854e-29f, -1.075135e-29f, 3.296045e-30f, 1.114618e-29f, 9.365255e-30f, 1.884735e-30f, -4.708555e-30f, -6.297306e-30f, -3.257755e-30f, 1.073205e-30f, 3.455697e-30f, 2.866890e-30f, 5.457855e-31f, -1.474155e-30f, -1.939924e-30f, -9.866719e-31f, 3.483764e-31f, 1.071160e-30f, 8.774207e-31f, 1.573718e-31f, -4.613350e-31f, -5.975019e-31f, -2.986891e-31f, 1.127776e-31f, 3.319579e-31f, 2.684781e-31f, 4.515436e-32f, -1.443154e-31f, -1.840003e-31f, -9.037549e-32f, 3.641805e-32f, 1.028544e-31f, 8.213209e-32f, 1.288286e-32f, -4.512711e-32f, -5.665295e-32f, -2.733120e-32f, 1.173350e-32f, 3.186211e-32f, 2.511992e-32f, 3.651357e-33f, -1.410573e-32f, -1.744018e-32f, -8.261041e-33f, 3.772583e-33f, 9.868230e-33f, 7.681105e-33f, 1.026836e-33f, -4.407496e-33f, -5.367891e-33f, -2.495572e-33f, 1.210666e-33f, 3.055750e-33f, 2.348159e-33f, 2.860678e-34f, -1.376673e-33f, -1.651888e-33f, -7.534502e-34f, 3.878364e-34f, 9.460435e-34f, 7.176753e-34f, 7.878446e-35f, -4.298493e-34f, -5.082548e-34f, -2.273412e-34f, 1.240419e-34f, 2.928329e-34f, 2.192924e-34f, 2.138701e-35f, -1.341691e-34f, -1.563530e-34f, -6.855342e-35f, 3.961271e-35f, 9.062434e-35f, 6.699041e-35f, 5.698665e-36f, -4.186424e-35f, -4.808995e-35f, -2.065836e-35f, 1.263258e-35f, 2.804057e-35f, 2.045941e-35f, 1.480980e-36f, -1.305847e-35f, -1.478855e-35f, -6.221075e-36f, 4.023290e-36f, 8.674542e-36f, 6.246879e-36f, 3.715322e-37f, -4.071954e-36f, -4.546948e-36f, -1.872076e-36f, 1.279791e-36f, 2.683024e-36f, 1.906868e-36f, 8.832951e-38f, -1.269341e-36f, -1.397773e-36f, -5.629313e-37f, 4.066283e-37f, 8.297007e-37f, 5.819200e-37f, 1.915427e-38f, -3.955685e-37f, -4.296115e-37f, -1.691393e-37f, 1.290586e-37f, 2.565299e-37f, 1.775372e-37f, 0.000000e+00f, -1.232356e-37f, -1.320191e-37f, -5.077771e-38f, 4.091983e-38f, 7.930023e-38f, 5.414968e-38f, 0.000000e+00f, -3.838169e-38f, -4.056197e-38f, -1.523077e-38f, 1.296173e-38f, 2.450933e-38f, 1.651128e-38f, 0.000000e+00f, -1.195056e-38f, -1.246012e-38f};

static __device__ const T facB[512] = {-1.287100e-01f, -4.263935e-01f, 2.956317e-02f, 1.003133e-01f, 1.031115e-01f, 1.577610e-01f, -4.742892e-02f, -8.679786e-02f, -5.420024e-02f, -4.372316e-02f, 4.256777e-02f, 5.229462e-02f, 1.990262e-02f, 2.717162e-03f, -2.888472e-02f, -2.517728e-02f, -2.920649e-03f, 7.546660e-03f, 1.609478e-02f, 9.497490e-03f, -2.987861e-03f, -7.141423e-03f, -7.446365e-03f, -2.196353e-03f, 3.686178e-03f, 4.409130e-03f, 2.697311e-03f, -4.306923e-04f, -2.671305e-03f, -2.121609e-03f, -5.507334e-04f, 9.515806e-04f, 1.514663e-03f, 7.757607e-04f, -1.931097e-04f, -7.528997e-04f, -7.021403e-04f, -1.516086e-04f, 3.193677e-04f, 4.390955e-04f, 2.525260e-04f, -6.529507e-05f, -2.422246e-04f, -2.050337e-04f, -4.983354e-05f, 1.000013e-04f, 1.388173e-04f, 7.302358e-05f, -1.963741e-05f, -7.483271e-05f, -6.415880e-05f, -1.332163e-05f, 3.080600e-05f, 4.258326e-05f, 2.266221e-05f, -6.883643e-06f, -2.305414e-05f, -1.954446e-05f, -4.069666e-06f, 9.803221e-06f, 1.308053e-05f, 6.821361e-06f, -2.166503e-06f, -7.199144e-06f, -5.974161e-06f, -1.160708e-06f, 3.041997e-06f, 4.046551e-06f, 2.064939e-06f, -7.130010e-07f, -2.221735e-06f, -1.833939e-06f, -3.353936e-07f, 9.556328e-07f, 1.242893e-06f, 6.268950e-07f, -2.306954e-07f, -6.899434e-07f, -5.599663e-07f, -9.691409e-08f, 2.987792e-07f, 3.832953e-07f, 1.892910e-07f, -7.441588e-08f, -2.136850e-07f, -1.715144e-07f, -2.757123e-08f, 9.340316e-08f, 1.179751e-07f, 5.732884e-08f, -2.404663e-08f, -6.619169e-08f, -5.244133e-08f, -7.860466e-09f, 2.921632e-08f, 3.631899e-08f, 1.732316e-08f, -7.727397e-09f, -2.050745e-08f, -1.603706e-08f, -2.214209e-09f, 9.126744e-09f, 1.118094e-08f, 5.234589e-09f, -2.482934e-09f, -6.349495e-09f, -4.903543e-09f, -6.193729e-10f, 2.851629e-09f, 3.440572e-09f, 1.580886e-09f, -7.958104e-10f, -1.966110e-09f, -1.498678e-09f, -1.714053e-10f, 8.904554e-10f, 1.058742e-09f, 4.770684e-10f, -2.546691e-10f, -6.086022e-10f, -4.580035e-10f, -4.678843e-11f, 2.779733e-10f, 3.257107e-10f, 1.439012e-10f, -8.137872e-11f, -1.883610e-10f, -1.399226e-10f, -1.256562e-11f, 8.674735e-11f, 1.001869e-10f, 4.337374e-11f, -2.596407e-11f, -5.828646e-11f, -4.273774e-11f, -3.299158e-12f, 2.706149e-11f, 3.081151e-11f, 1.306512e-11f, -8.273366e-12f, -1.803246e-11f, -1.305042e-11f, -8.401318e-13f, 8.439521e-12f, 9.474019e-12f, 3.932708e-12f, -2.632892e-12f, -5.577836e-12f, -3.984035e-12f, -2.044437e-13f, 2.631131e-12f, 2.912606e-12f, 1.182897e-12f, -8.369057e-13f, -1.725013e-12f, -1.215936e-12f, -4.621184e-14f, 8.200410e-13f, 8.952608e-13f, 3.555237e-13f, -2.657298e-13f, -5.333831e-13f, -3.710055e-13f, -9.066004e-15f, 2.555044e-13f, 2.751314e-13f, 1.067664e-13f, -8.428504e-14f, -1.648944e-13f, -1.131703e-13f, -1.198772e-15f, 7.958543e-14f, 8.453804e-14f, 3.203536e-14f, -2.670760e-14f, -5.096744e-14f, -3.451148e-14f, 1.220617e-16f, 2.478246e-14f, 2.597079e-14f, 9.603542e-15f, -8.455033e-15f, -1.575073e-14f, -1.052135e-14f, 1.890387e-16f, 7.714949e-15f, 7.976988e-15f, 2.876196e-15f, -2.674322e-15f, -4.866647e-15f, -3.206664e-15f, 1.048990e-16f, 2.401056e-15f, 2.449699e-15f, 8.605311e-16f, -8.451799e-16f, -1.503422e-15f, -9.770271e-16f, 4.669174e-17f, 7.470579e-16f, 7.521530e-16f, 2.571869e-16f, -2.668946e-16f, -4.643591e-16f, -2.975967e-16f, 1.881234e-17f, 2.323760e-16f, 2.308972e-16f, 7.677787e-17f, -8.421741e-17f, -1.434001e-16f, -9.061809e-17f, 7.159212e-18f, 7.226292e-17f, 7.086788e-17f, 2.289263e-17f, -2.655528e-17f, -4.427597e-17f, -2.758441e-17f, 2.625451e-18f, 2.246617e-17f, 2.174693e-17f, 6.816979e-18f, -8.367603e-18f, -1.366815e-17f, -8.394040e-18f, 9.380983e-19f, 6.982867e-18f, 6.672117e-18f, 2.027146e-18f, -2.634906e-18f, -4.218664e-18f, -2.553486e-18f, 3.287924e-19f, 2.169859e-18f, 2.046660e-18f, 6.019082e-19f, -8.291929e-19f, -1.301858e-18f, -7.765101e-19f, 1.135375e-19f, 6.741000e-19f, 6.276871e-19f, 1.784341e-19f, -2.607855e-19f, -4.016767e-19f, -2.360522e-19f, 3.874579e-20f, 2.093696e-19f, 1.924667e-19f, 5.280458e-20f, -8.197085e-20f, -1.239121e-19f, -7.173186e-20f, 1.309573e-20f, 6.501314e-20f, 5.900407e-20f, 1.559725e-20f, -2.575095e-20f, -3.821860e-20f, -2.178987e-20f, 4.391001e-21f, 2.018313e-20f, 1.808512e-20f, 4.597642e-21f, -8.085262e-21f, -1.178584e-20f, -6.616547e-21f, 1.462405e-21f, 6.264364e-21f, 5.542082e-21f, 1.352229e-21f, -2.537293e-21f, -3.633883e-21f, -2.008340e-21f, 4.842450e-22f, 1.943875e-21f, 1.697992e-21f, 3.967328e-22f, -7.958495e-22f, -1.120227e-21f, -6.093499e-22f, 1.595486e-22f, 6.030642e-22f, 5.201261e-22f, 1.160831e-22f, -2.495068e-22f, -3.452756e-22f, -1.848054e-22f, 5.233877e-23f, 1.870528e-22f, 1.592908e-22f, 3.386368e-23f, -7.818660e-23f, -1.064021e-22f, -5.602409e-23f, 1.710333e-23f, 5.800579e-23f, 4.877312e-23f, 9.845604e-24f, -2.448991e-23f, -3.278383e-23f, -1.697623e-23f, 5.569938e-24f, 1.798400e-23f, 1.493060e-23f, 2.851765e-24f, -7.667494e-24f, -1.009936e-23f, -5.141709e-24f, 1.808375e-24f, 5.574554e-24f, 4.569616e-24f, 8.224932e-25f, -2.399589e-24f, -3.110662e-24f, -1.556561e-24f, 5.855007e-25f, 1.727603e-24f, 1.398255e-24f, 2.360670e-25f, -7.506600e-25f, -9.579360e-25f, -4.709882e-25f, 1.890952e-25f, 5.352896e-25f, 4.277558e-25f, 6.737503e-26f, -2.347349e-25f, -2.949475e-25f, -1.424397e-25f, 6.093194e-26f, 1.658233e-25f, 1.308299e-25f, 1.910372e-26f, -7.337451e-26f, -9.079825e-26f, -4.305471e-26f, 1.959322e-26f, 5.135884e-26f, 4.000535e-26f, 5.374967e-27f, -2.292718e-26f, -2.794696e-26f, -1.300678e-26f, 6.288352e-27f, 1.590372e-26f, 1.223004e-26f, 1.498300e-27f, -7.161406e-27f, -8.600344e-27f, -3.927074e-27f, 2.014666e-27f, 4.923760e-27f, 3.737957e-27f, 4.129394e-28f, -2.236106e-27f, -2.646190e-27f, -1.184971e-27f, 6.444093e-28f, 1.524089e-27f, 1.142184e-27f, 1.122009e-28f, -6.979707e-28f, -8.140482e-28f, -3.573344e-28f, 2.058089e-28f, 4.716722e-28f, 3.489242e-28f, 2.993267e-29f, -2.177892e-28f, -2.503818e-28f, -1.076857e-28f, 6.563800e-29f, 1.459443e-28f, 1.065658e-28f, 7.791852e-30f, -6.793496e-29f, -7.699781e-29f, -3.242986e-29f, 2.090625e-29f, 4.514933e-29f, 3.253825e-29f, 1.959452e-30f, -2.118418e-29f, -2.367430e-29f, -9.759361e-30f, 6.650637e-30f, 1.396478e-29f, 9.932489e-30f, 4.676312e-31f, -6.603814e-30f, -7.277771e-30f, -2.934758e-30f, 2.113244e-30f, 4.318526e-30f, 3.031151e-30f, 1.021183e-31f, -2.058002e-30f, -2.236876e-30f, -8.818231e-31f, 6.707565e-31f, 1.335232e-30f, 9.247838e-31f, 1.852673e-32f, -6.411614e-31f, -6.873965e-31f, -2.647471e-31f, 2.126848e-31f, 4.127600e-31f, 2.820680e-31f, 1.720653e-33f, -1.996928e-31f, -2.112001e-31f, -7.941498e-32f, 6.737348e-32f, 1.275731e-31f, 8.600936e-32f, -6.987550e-34f, -6.217759e-32f, -6.487865e-32f, -2.379984e-32f, 2.132283e-32f, 3.942229e-32f, 2.621885e-32f, -5.939567e-34f, -1.935459e-32f, -1.992645e-32f, -7.125630e-33f, 6.742562e-33f, 1.217996e-32f, 7.990143e-33f, -2.996603e-34f, -6.023036e-33f, -6.118967e-33f, -2.131204e-33f, 2.130336e-33f, 3.762460e-33f, 2.434254e-33f, -1.282610e-34f, -1.873831e-33f, -1.878649e-33f, -6.367253e-34f, 6.725613e-34f, 1.162038e-33f, 7.413865e-34f, -5.058462e-35f, -5.828155e-34f, -5.766762e-34f, -1.900090e-34f, 2.121740e-34f, 3.588320e-34f, 2.257291e-34f, -1.899304e-35f, -1.812256e-34f, -1.769851e-34f, -5.663141e-35f, 6.688735e-35f, 1.107860e-34f, 6.870549e-35f, -6.900961e-36f, -5.633758e-35f, -5.430736e-35f, -1.685641e-35f, 2.107178e-35f, 3.419811e-35f, 2.090513e-35f, -2.449149e-36f, -1.750929e-35f, -1.666087e-35f, -5.010207e-36f, 6.634014e-36f, 1.055462e-35f, 6.358695e-36f, -8.539795e-37f, -5.440420e-36f, -5.110374e-36f, -1.486905e-36f, 2.087284e-36f, 3.256921e-36f, 1.933451e-36f, -2.936963e-37f, -1.690020e-36f, -1.567195e-36f, -4.405507e-37f, 6.563382e-37f, 1.004837e-36f, 5.876846e-37f, -9.989760e-38f, -5.248660e-37f, -4.805161e-37f, -1.302972e-37f, 2.062648e-37f, 3.099621e-37f, 1.785653e-37f, -3.367293e-38f, -1.629685e-37f, -1.473013e-37f, -3.846230e-38f, 6.478633e-38f, 9.559730e-38f, 5.423595e-38f, 0.000000e+00f, -5.058937e-38f, -4.514587e-38f, 0.000000e+00f, 2.033815e-38f, 2.947863e-38f, 1.646682e-38f, 0.000000e+00f, -1.570061e-38f, -1.383379e-38f};

static __device__ const T facC[513] = {-1.970900e-01f, -1.267706e-01f, -3.875681e-01f, 5.416635e-02f, 1.764570e-01f, 9.168664e-02f, 1.230955e-01f, -6.515834e-02f, -1.108843e-01f, -4.112117e-02f, -2.199768e-02f, 5.045856e-02f, 5.655249e-02f, 9.915848e-03f, -8.330497e-03f, -3.073032e-02f, -2.351726e-02f, 3.119655e-03f, 1.212224e-02f, 1.543490e-02f, 7.114810e-03f, -6.006479e-03f, -8.513977e-03f, -6.249041e-03f, -5.301153e-04f, 4.901404e-03f, 4.501652e-03f, 1.730382e-03f, -1.308408e-03f, -3.003709e-03f, -1.860463e-03f, 3.869802e-05f, 1.312459e-03f, 1.503485e-03f, 5.171980e-04f, -4.868872e-04f, -8.519433e-04f, -6.052051e-04f, 1.534709e-05f, 4.370047e-04f, 4.349131e-04f, 1.664379e-04f, -1.501650e-04f, -2.741927e-04f, -1.751231e-04f, 3.912763e-06f, 1.339874e-04f, 1.377117e-04f, 4.662687e-05f, -4.651926e-05f, -8.375787e-05f, -5.490248e-05f, 3.095127e-06f, 4.146518e-05f, 4.186835e-05f, 1.449686e-05f, -1.505513e-05f, -2.583092e-05f, -1.654992e-05f, 9.918831e-07f, 1.301524e-05f, 1.285343e-05f, 4.258422e-06f, -4.674565e-06f, -8.013756e-06f, -5.044834e-06f, 4.095788e-07f, 4.020832e-06f, 3.956195e-06f, 1.273362e-06f, -1.484938e-06f, -2.465106e-06f, -1.538878e-06f, 1.475507e-07f, 1.254178e-06f, 1.210874e-06f, 3.800242e-07f, -4.669174e-07f, -7.625179e-07f, -4.672274e-07f, 5.245798e-08f, 3.893952e-07f, 3.720646e-07f, 1.126556e-07f, -1.469920e-07f, -2.351741e-07f, -1.423323e-07f, 1.849206e-08f, 1.210022e-07f, 1.140589e-07f, 3.351906e-08f, -4.629220e-08f, -7.257906e-08f, -4.325475e-08f, 6.353741e-09f, 3.760153e-08f, 3.498422e-08f, 9.925404e-09f, -1.454964e-08f, -2.239652e-08f, -1.315088e-08f, 2.171521e-09f, 1.167549e-08f, 1.072787e-08f, 2.937923e-09f, -4.574691e-09f, -6.907946e-09f, -3.996422e-09f, 7.331882e-10f, 3.625974e-09f, 3.288448e-09f, 8.677395e-10f, -1.436913e-09f, -2.130824e-09f, -1.213856e-09f, 2.457560e-10f, 1.125589e-09f, 1.007992e-09f, 2.557253e-10f, -4.511559e-10f, -6.570696e-10f, -3.686082e-10f, 8.183373e-11f, 3.493565e-10f, 3.088796e-10f, 7.521211e-11f, -1.415799e-10f, -2.025921e-10f, -1.118785e-10f, 2.708729e-11f, 1.084073e-10f, 9.463506e-11f, 2.206237e-11f, -4.440597e-11f, -6.245325e-11f, -3.394476e-11f, 8.923228e-12f, 3.363138e-11f, 2.898818e-11f, 6.454655e-12f, -1.392160e-11f, -1.924903e-11f, -1.029464e-11f, 2.926541e-12f, 1.043143e-11f, 8.877625e-12f, 1.882647e-12f, -4.362410e-12f, -5.931868e-12f, -3.120764e-12f, 9.561731e-13f, 3.234781e-12f, 2.718214e-12f, 5.472664e-13f, -1.366383e-12f, -1.827663e-12f, -9.456252e-13f, 3.113424e-13f, 1.002896e-12f, 8.320990e-13f, 1.584846e-13f, -4.277893e-13f, -5.630241e-13f, -2.864009e-13f, 1.010678e-13f, 3.108674e-13f, 2.546671e-13f, 4.569897e-14f, -1.338764e-13f, -1.734132e-13f, -8.670077e-14f, 3.271877e-14f, 9.633952e-14f, 7.792463e-14f, 1.311288e-14f, -4.187956e-14f, -5.340256e-14f, -2.623348e-14f, 1.056571e-14f, 2.985005e-14f, 2.383853e-14f, 3.741381e-15f, -1.309568e-14f, -1.644245e-14f, -7.933516e-15f, 3.404216e-15f, 9.246927e-15f, 7.290976e-15f, 1.060471e-15f, -4.093432e-15f, -5.061691e-15f, -2.397970e-15f, 1.094550e-15f, 2.863933e-15f, 2.229420e-15f, 2.982463e-16f, -1.279043e-15f, -1.557934e-15f, -7.244043e-16f, 3.512589e-16f, 8.868336e-16f, 6.815480e-16f, 8.309571e-17f, -3.995077e-16f, -4.794315e-16f, -2.187095e-16f, 1.125272e-16f, 2.745593e-16f, 2.083041e-16f, 2.288731e-17f, -1.247418e-16f, -1.475122e-16f, -6.599228e-17f, 3.599008e-17f, 8.498564e-17f, 6.364940e-17f, 6.213849e-18f, -3.893582e-17f, -4.537883e-17f, -1.989970e-17f, 1.149354e-17f, 2.630094e-17f, 1.944394e-17f, 1.655991e-18f, -1.214902e-17f, -1.395732e-17f, -5.996746e-18f, 3.665356e-18f, 8.137929e-18f, 5.938347e-18f, 4.304625e-19f, -3.789583e-18f, -4.292141e-18f, -1.805875e-18f, 1.167374e-18f, 2.517528e-18f, 1.813161e-18f, 1.080267e-19f, -1.181689e-18f, -1.319681e-18f, -5.434358e-19f, 3.713398e-19f, 7.786690e-19f, 5.534708e-19f, 2.569660e-20f, -3.683661e-19f, -4.056826e-19f, -1.634116e-19f, 1.179869e-19f, 2.407966e-19f, 1.689034e-19f, 5.577873e-21f, -1.147953e-19f, -1.246884e-19f, -4.909922e-20f, 3.744784e-20f, 7.445048e-20f, 5.153061e-20f, 9.973536e-22f, -3.576345e-20f, -3.831665e-20f, -1.474030e-20f, 1.187346e-20f, 2.301466e-20f, 1.571712e-20f, 8.498554e-23f, -1.113854e-20f, -1.177255e-20f, -4.421384e-21f, 3.761055e-21f, 7.113156e-21f, 4.792464e-21f, -4.232616e-23f, -3.468117e-21f, -3.616382e-21f, -1.324981e-21f, 1.190273e-21f, 2.198068e-21f, 1.460900e-21f, -3.415114e-23f, -1.079538e-21f, -1.110705e-21f, -3.966775e-22f, 3.763646e-22f, 6.791120e-22f, 4.452001e-22f, -1.702571e-23f, -3.359415e-22f, -3.410695e-22f, -1.186361e-22f, 1.189090e-22f, 2.097797e-22f, 1.356314e-22f, -7.248972e-24f, -1.045136e-22f, -1.047144e-22f, -3.544213e-23f, 3.753895e-23f, 6.478999e-23f, 4.130782e-23f, -2.850388e-24f, -3.250634e-23f, -3.214317e-23f, -1.057587e-23f, 1.184205e-23f, 2.000668e-23f, 1.257675e-23f, -1.068187e-24f, -1.010767e-23f, -9.864822e-24f, -3.151896e-24f, 3.733052e-24f, 6.176823e-24f, 3.827943e-24f, -3.875984e-25f, -3.142131e-24f, -3.026964e-24f, -9.381021e-25f, 1.175999e-24f, 1.906683e-24f, 1.164715e-24f, -1.374231e-25f, -9.765385e-25f, -9.286287e-25f, -2.788107e-25f, 3.702276e-25f, 5.884580e-25f, 3.542645e-25f, -4.788097e-26f, -3.034228e-25f, -2.848348e-25f, -8.273761e-26f, 1.164825e-25f, 1.815834e-25f, 1.077173e-25f, -1.645712e-26f, -9.425459e-26f, -8.734926e-26f, -2.451202e-26f, 3.662642e-26f, 5.602231e-26f, 3.274077e-26f, -5.594984e-27f, -2.927211e-26f, -2.678181e-26f, -7.249012e-27f, 1.151012e-26f, 1.728105e-26f, 9.947954e-27f, -1.885164e-27f, -9.088755e-27f, -8.209833e-27f, -2.139615e-27f, 3.615153e-27f, 5.329708e-27f, 3.021452e-27f, -6.304417e-28f, -2.821337e-27f, -2.516178e-27f, -6.301935e-28f, 1.134864e-27f, 1.643468e-27f, 9.173389e-28f, -2.094975e-28f, -8.756034e-28f, -7.710105e-28f, -1.851853e-28f, 3.560733e-28f, 5.066918e-28f, 2.784012e-28f, -6.923719e-29f, -2.716834e-28f, -2.362055e-28f, -5.427921e-29f, 1.116662e-28f, 1.561892e-28f, 8.445672e-29f, -2.277390e-29f, -8.427975e-29f, -7.234849e-29f, -1.586493e-29f, 3.500240e-29f, 4.813745e-29f, 2.561023e-29f, -7.459779e-30f, -2.613902e-29f, -2.215530e-29f, -4.622576e-30f, 1.096668e-29f, 1.483337e-29f, 7.762522e-30f, -2.434523e-30f, -8.105171e-30f, -6.783179e-30f, -1.342178e-30f, 3.434468e-30f, 4.570055e-30f, 2.351777e-30f, -7.919081e-31f, -2.512716e-30f, -2.076325e-30f, -3.881724e-31f, 1.075121e-30f, 1.407757e-30f, 7.121746e-31f, -2.568358e-31f, -7.788141e-31f, -6.354222e-31f, -1.117622e-31f, 3.364147e-31f, 4.335697e-31f, 2.155593e-31f, -8.307707e-32f, -2.413430e-31f, -1.944166e-31f, -3.201388e-32f, 1.052246e-31f, 1.335103e-31f, 6.521225e-32f, -2.680763e-32f, -7.477335e-32f, -5.947119e-32f, -9.115982e-33f, 3.289951e-32f, 4.110504e-32f, 1.971813e-32f, -8.631374e-33f, -2.316175e-32f, -1.818783e-32f, -2.577794e-33f, 1.028245e-32f, 1.265319e-32f, 5.958922e-33f, -2.773487e-33f, -7.173136e-33f, -5.561025e-33f, -7.229435e-34f, 3.212500e-33f, 3.894297e-33f, 1.799806e-33f, -8.895439e-34f, -2.221063e-33f, -1.699913e-33f, -2.007355e-34f, 1.003306e-33f, 1.198346e-33f, 5.432879e-34f, -2.848170e-34f, -6.875871e-34f, -5.195108e-34f, -5.505515e-35f, 3.132363e-34f, 3.686883e-34f, 1.638965e-34f, -9.104928e-35f, -2.128189e-34f, -1.587293e-34f, -1.486663e-35f, 9.776031e-35f, 1.134123e-34f, 4.941211e-35f, -2.906351e-35f, -6.585812e-35f, -4.848556e-35f, -3.933745e-36f, 3.050063e-35f, 3.488063e-35f, 1.488705e-35f, -9.264544e-36f, -2.037631e-35f, -1.480671e-35f, -1.012491e-36f, 9.512928e-36f, 1.072585e-35f, 4.482112e-36f, -2.949469e-36f, -6.303180e-36f, -4.520575e-36f, -2.504176e-37f, 2.966076e-36f, 3.297630e-36f, 1.348468e-36f, -9.378687e-37f, -1.949451e-36f, -1.379798e-36f, -5.817810e-38f, 9.245197e-37f, 1.013665e-36f, 4.053846e-37f, -2.978867e-37f, -6.028149e-37f, -4.210388e-37f, -1.207396e-38f, 2.880839e-37f, 3.115366e-37f, 1.217715e-37f, -9.451472e-38f, -1.863698e-37f, -1.284432e-37f, 0.000000e+00f, 8.974154e-38f, 9.572945e-38f, 3.654752e-38f, -2.995804e-38f, -5.760857e-38f, -3.917238e-38f, 0.000000e+00f, 2.794748e-38f, 2.941055e-38f, 0.000000e+00f, 0.000000e+00f, -1.780408e-38f, -1.194336e-38f};

static __device__ const T facD[514] = {-9.840000e-03f, -1.969932e-01f, -1.248322e-01f, -3.863398e-01f, 5.796793e-02f, 1.758866e-01f, 8.995591e-02f, 1.222104e-01f, -6.636088e-02f, -1.102313e-01f, -4.003650e-02f, -2.160372e-02f, 5.067114e-02f, 5.605389e-02f, 9.364277e-03f, -8.422641e-03f, -3.064744e-02f, -2.321569e-02f, 3.348098e-03f, 1.208930e-02f, 1.531594e-02f, 6.964102e-03f, -6.075006e-03f, -8.454200e-03f, -6.165852e-03f, -4.694436e-04f, 4.906025e-03f, 4.453377e-03f, 1.686561e-03f, -1.325004e-03f, -2.990671e-03f, -1.831035e-03f, 5.671545e-05f, 1.311901e-03f, 1.490576e-03f, 5.025308e-04f, -4.918322e-04f, -8.471038e-04f, -5.968697e-04f, 2.122029e-05f, 4.367959e-04f, 4.306151e-04f, 1.622007e-04f, -1.517611e-04f, -2.726994e-04f, -1.724398e-04f, 5.609567e-06f, 1.339322e-04f, 1.363939e-04f, 4.528476e-05f, -4.696487e-05f, -8.329574e-05f, -5.408286e-05f, 3.627301e-06f, 4.142949e-05f, 4.146069e-05f, 1.408889e-05f, -1.519376e-05f, -2.568141e-05f, -1.629722e-05f, 1.152247e-06f, 1.300390e-05f, 1.272547e-05f, 4.133205e-06f, -4.715237e-06f, -7.967359e-06f, -4.966436e-06f, 4.584483e-07f, 4.016320e-06f, 3.916674e-06f, 1.234822e-06f, -1.497089e-06f, -2.450374e-06f, -1.514766e-06f, 1.624558e-07f, 1.252579e-06f, 1.198549e-06f, 3.682306e-07f, -4.705407e-07f, -7.578877e-07f, -4.597699e-07f, 5.698206e-08f, 3.888345e-07f, 3.682385e-07f, 1.090322e-07f, -1.480648e-07f, -2.337171e-07f, -1.400325e-07f, 1.986996e-08f, 1.208066e-07f, 1.128701e-07f, 3.240843e-08f, -4.661108e-08f, -7.212040e-08f, -4.254509e-08f, 6.772376e-09f, 3.753488e-08f, 3.461487e-08f, 9.584800e-09f, -1.464395e-08f, -2.225242e-08f, -1.293192e-08f, 2.298767e-09f, 1.165287e-08f, 1.061321e-08f, 2.833490e-09f, -4.602570e-09f, -6.862657e-09f, -3.928894e-09f, 7.718477e-10f, 3.618378e-09f, 3.252844e-09f, 8.357319e-10f, -1.445136e-09f, -2.116604e-09f, -1.193029e-09f, 2.574953e-10f, 1.123055e-09f, 9.969408e-10f, 2.459155e-10f, -4.535757e-10f, -6.526064e-10f, -3.621866e-10f, 8.539761e-11f, 3.485162e-10f, 3.054503e-10f, 7.220648e-11f, -1.422904e-10f, -2.011920e-10f, -1.098988e-10f, 2.816871e-11f, 1.081301e-10f, 9.357106e-11f, 2.114163e-11f, -4.461401e-11f, -6.201425e-11f, -3.333454e-11f, 9.251240e-12f, 3.354035e-11f, 2.865814e-11f, 6.172659e-12f, -1.398234e-11f, -1.911144e-11f, -1.010659e-11f, 3.025989e-12f, 1.040165e-11f, 8.775272e-12f, 1.796298e-12f, -4.380085e-12f, -5.888767e-12f, -3.062818e-12f, 9.863112e-13f, 3.225076e-12f, 2.686479e-12f, 5.208314e-13f, -1.371508e-12f, -1.814168e-12f, -9.277737e-13f, 3.204717e-13f, 9.997423e-13f, 8.222614e-13f, 1.503935e-13f, -4.292691e-13f, -5.588001e-13f, -2.809022e-13f, 1.038319e-13f, 3.098457e-13f, 2.516182e-13f, 4.322301e-14f, -1.343017e-13f, -1.720917e-13f, -8.500737e-14f, 3.355524e-14f, 9.600931e-14f, 7.697989e-14f, 1.235540e-14f, -4.200114e-14f, -5.298926e-14f, -2.571206e-14f, 1.081872e-14f, 2.974359e-14f, 2.354585e-14f, 3.509688e-15f, -1.313022e-14f, -1.631325e-14f, -7.772991e-15f, 3.480702e-15f, 9.212676e-15f, 7.200322e-15f, 9.896187e-16f, -4.103170e-15f, -5.021315e-15f, -2.348560e-15f, 1.117659e-15f, 2.852935e-15f, 2.201346e-15f, 2.765850e-16f, -1.281764e-15f, -1.545321e-15f, -7.091981e-16f, 3.582373e-16f, 8.833084e-16f, 6.728560e-16f, 7.647479e-17f, -4.002601e-16f, -4.754928e-16f, -2.140306e-16f, 1.146332e-16f, 2.734312e-16f, 2.056135e-16f, 2.086408e-17f, -1.249470e-16f, -1.462827e-16f, -6.455284e-17f, 3.662526e-17f, 8.462522e-17f, 6.281668e-17f, 5.595730e-18f, -3.899087e-17f, -4.499515e-17f, -1.945694e-17f, 1.168499e-17f, 2.618595e-17f, 1.918626e-17f, 1.467198e-18f, -1.216346e-17f, -1.383763e-17f, -5.860583e-18f, 3.723023e-18f, 8.101293e-18f, 5.858629e-18f, 3.728138e-19f, -3.793251e-18f, -4.254815e-18f, -1.764007e-18f, 1.184731e-18f, 2.505869e-18f, 1.788503e-18f, 9.042764e-20f, -1.182579e-18f, -1.308044e-18f, -5.305647e-19f, 3.765606e-19f, 7.749635e-19f, 5.458451e-19f, 2.032549e-20f, -3.685661e-19f, -4.020559e-19f, -1.594553e-19f, 1.195560e-19f, 2.396202e-19f, 1.665456e-19f, 3.939053e-21f, -1.148340e-19f, -1.235584e-19f, -4.788341e-20f, 3.791902e-20f, 7.407735e-20f, 5.080168e-20f, 4.974700e-22f, -3.576834e-20f, -3.796469e-20f, -1.436672e-20f, 1.201482e-20f, 2.289643e-20f, 1.549181e-20f, -6.745319e-23f, -1.113788e-20f, -1.166295e-20f, -4.306620e-21f, 3.803431e-21f, 7.075729e-21f, 4.722838e-21f, -8.879893e-23f, -3.467243e-21f, -3.582264e-21f, -1.289731e-21f, 1.202964e-21f, 2.186230e-21f, 1.439387e-21f, -4.831469e-23f, -1.079063e-21f, -1.100086e-21f, -3.858526e-22f, 3.801612e-22f, 6.753710e-22f, 4.385544e-22f, -2.134109e-23f, -3.357314e-22f, -3.377658e-22f, -1.153124e-22f, 1.200437e-22f, 2.085984e-22f, 1.335788e-22f, -8.563385e-24f, -1.044293e-22f, -1.036868e-22f, -3.442184e-23f, 3.787766e-23f, 6.441726e-23f, 4.067395e-23f, -3.250620e-24f, -3.247435e-23f, -3.182361e-23f, -1.026272e-23f, 1.194303e-23f, 1.988916e-23f, 1.238104e-23f, -1.190017e-24f, -1.009596e-23f, -9.765475e-24f, -3.055803e-24f, 3.763120e-24f, 6.139791e-24f, 3.767526e-24f, -4.246704e-25f, -3.137951e-24f, -2.996086e-24f, -9.086206e-25f, 1.184940e-24f, 1.895023e-24f, 1.146068e-24f, -1.487002e-25f, -9.750749e-25f, -9.190337e-25f, -2.697673e-25f, 3.728819e-25f, 5.847886e-25f, 3.485101e-25f, -5.131025e-26f, -3.029178e-25f, -2.818540e-25f, -7.996417e-26f, 1.172693e-25f, 1.804294e-25f, 1.059418e-25f, -1.749957e-26f, -9.408236e-26f, -8.642347e-26f, -2.366161e-26f, 3.685923e-26f, 5.565960e-26f, 3.219307e-26f, -5.911757e-27f, -2.921393e-26f, -2.649434e-26f, -6.988308e-27f, 1.157888e-26f, 1.716710e-26f, 9.779029e-27f, -1.981388e-27f, -9.069253e-27f, -8.120589e-27f, -2.059709e-27f, 3.635418e-27f, 5.293933e-27f, 2.969359e-27f, -6.596594e-28f, -2.814845e-27f, -2.488479e-27f, -6.057069e-28f, 1.140823e-27f, 1.632242e-27f, 9.012774e-28f, -2.183658e-28f, -8.734543e-28f, -7.624154e-28f, -1.776832e-28f, 3.578215e-28f, 5.031706e-28f, 2.734499e-28f, -7.192787e-29f, -2.709755e-28f, -2.335390e-28f, -5.198116e-29f, 1.121776e-28f, 1.550853e-28f, 8.293066e-29f, -2.358992e-29f, -8.404759e-29f, -7.152143e-29f, -1.516115e-29f, 3.515158e-29f, 4.779154e-29f, 2.513996e-29f, -7.707152e-30f, -2.606317e-29f, -2.189883e-29f, -4.407091e-30f, 1.101004e-29f, 1.472503e-29f, 7.617626e-30f, -2.509478e-30f, -8.080475e-30f, -6.703665e-30f, -1.276214e-30f, 3.447025e-30f, 4.536135e-30f, 2.307141e-30f, -8.146102e-31f, -2.504699e-30f, -2.051678e-30f, -3.679839e-31f, 1.078742e-30f, 1.397142e-30f, 6.984266e-31f, -2.637082e-31f, -7.762190e-31f, -6.277840e-31f, -1.055849e-31f, 3.374535e-31f, 4.302491e-31f, 2.113256e-31f, -8.515647e-32f, -2.405049e-31f, -1.920500e-31f, -3.012412e-32f, 1.055210e-31f, 1.324719e-31f, 6.390872e-32f, -2.743648e-32f, -7.450335e-32f, -5.873807e-32f, -8.538003e-33f, 3.298351e-32f, 4.078047e-32f, 1.931685e-32f, -8.821447e-33f, -2.307494e-32f, -1.796077e-32f, -2.401061e-33f, 1.030607e-32f, 1.255177e-32f, 5.835411e-33f, -2.830906e-33f, -7.145278e-33f, -5.490714e-33f, -6.689145e-34f, 3.219081e-33f, 3.862620e-33f, 1.761798e-33f, -9.068797e-34f, -2.212139e-33f, -1.678145e-33f, -1.842225e-34f, 1.005119e-33f, 1.188455e-33f, 5.315933e-34f, -2.900478e-34f, -6.847329e-34f, -5.127729e-34f, -5.000946e-35f, 3.137283e-34f, 3.656011e-34f, 1.602989e-34f, -9.262659e-35f, -2.119074e-34f, -1.566441e-34f, -1.332526e-35f, 9.789140e-35f, 1.124490e-34f, 4.830559e-35f, -2.953882e-35f, -6.556743e-35f, -4.784036e-35f, -3.462993e-36f, 3.053469e-35f, 3.458016e-35f, 1.454678e-35f, -9.407681e-36f, -2.028373e-35f, -1.460712e-35f, -8.687588e-37f, 9.521473e-36f, 1.063215e-35f, 4.377490e-36f, -2.992541e-36f, -6.273730e-36f, -4.458840e-36f, -2.065425e-37f, 2.968107e-36f, 3.268422e-36f, 1.316306e-36f, -9.508209e-37f, -1.940094e-36f, -1.360707e-36f, -4.478877e-38f, 9.249601e-37f, 1.004563e-36f, 3.954996e-37f, -3.017783e-37f, -5.998452e-37f, -4.151362e-37f, 0.000000e+00f, 2.881624e-37f, 3.087010e-37f, 1.187339e-37f, -9.568301e-38f, -1.854282e-37f, -1.266185e-37f, 0.000000e+00f, 8.974810e-38f, 9.484629e-38f, 3.561423e-38f, -3.030847e-38f, -5.731031e-38f, -3.860844e-38f, 0.000000e+00f, 2.794407e-38f, 2.913557e-38f, 0.000000e+00f, 0.000000e+00f, -1.770969e-38f, -1.176909e-38f};

// shared memory size is 21012 bytes

static __device__ unsigned int counter = 0;

static __global__ __launch_bounds__(block_size, 2)
void Recurrence1(const int items, const T* const __restrict__ input, T* const __restrict__ output, volatile int* const __restrict__ status, volatile T* const __restrict__ partcarry, volatile T* const __restrict__ fullcarry)
{
  const int valsperthread = 1;
  const int chunk_size = valsperthread * block_size;
  __shared__ T spartc[chunk_size / warp_size * order];
  __shared__ T sfullc[order];
  __shared__ int cid;

  const int tid = threadIdx.x;
  const int warp = tid / warp_size;
  const int lane = tid % warp_size;

  __shared__ T sfacA[block_size];
  __shared__ T sfacB[block_size];
  __shared__ T sfacC[block_size];
  __shared__ T sfacD[block_size];
  if (tid < 511) sfacA[tid] = facA[tid];
  else sfacA[tid] = 0;
  if (tid < 512) sfacB[tid] = facB[tid];
  else sfacB[tid] = 0;
  if (tid < 513) sfacC[tid] = facC[tid];
  else sfacC[tid] = 0;
  if (tid < 514) sfacD[tid] = facD[tid];
  else sfacD[tid] = 0;

  if (tid == 0) {
    cid = atomicInc(&counter, gridDim.x - 1);
  }

  __syncthreads();
  const int chunk_id = cid;
  const int offs = tid + chunk_id * chunk_size;

  T val0;
  if (chunk_id == gridDim.x - 1) {
    val0 = 0;
    if (offs + (0 * block_size) < items) val0 = input[offs + (0 * block_size)];
  } else {
    val0 = input[offs + (0 * block_size)];
  }

  val0 *= 2.366700e-01f;

  const T sfA = sfacA[lane];
  const T sfB = sfacB[lane];
  const T sfC = sfacC[lane];
  const T sfD = sfacD[lane];

  int cond;
  T help, spc;

  help = -9.840000e-03f;
  cond = ((lane & 1) != 0);
  spc = help * __shfl(val0, 0, 2);
  if (cond) val0 += spc;

  help = __shfl(sfC, lane % 2);
  cond = ((lane & 2) != 0);
  spc = help * __shfl(val0, 0, 4);
  if (cond) val0 += spc;

  help = __shfl(sfD, lane % 2);
  cond = ((lane & 2) != 0);
  spc = help * __shfl(val0, 1, 4);
  if (cond) val0 += spc;

  help = __shfl(sfA, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 0, 8);
  if (cond) val0 += spc;

  help = __shfl(sfB, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 1, 8);
  if (cond) val0 += spc;

  help = __shfl(sfC, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 2, 8);
  if (cond) val0 += spc;

  help = __shfl(sfD, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 3, 8);
  if (cond) val0 += spc;

  help = __shfl(sfA, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 4, 16);
  if (cond) val0 += spc;

  help = __shfl(sfB, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 5, 16);
  if (cond) val0 += spc;

  help = __shfl(sfC, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 6, 16);
  if (cond) val0 += spc;

  help = __shfl(sfD, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 7, 16);
  if (cond) val0 += spc;

  help = __shfl(sfA, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 12, 32);
  if (cond) val0 += spc;

  help = __shfl(sfB, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 13, 32);
  if (cond) val0 += spc;

  help = __shfl(sfC, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 14, 32);
  if (cond) val0 += spc;

  help = __shfl(sfD, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 15, 32);
  if (cond) val0 += spc;

  const int delta = block_size / warp_size * order;
  const int clane = lane - (warp_size - order);
  const int clwo = clane + warp * order;

  if (((warp & 1) == 0) && (clane >= 0)) {
    spartc[clwo + 0 * delta] = val0;
  }

  __syncthreads();
  if ((warp & 1) != 0) {
    const int cwarp = ((warp & ~1) | 0) * order;
    const T helpA = sfacA[tid % (warp_size * 1)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 1)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 1)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 1)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    if (((warp & 3) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
    }
  }

  __syncthreads();
  if ((warp & 2) != 0) {
    const int cwarp = ((warp & ~3) | 1) * order;
    const T helpA = sfacA[tid % (warp_size * 2)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 2)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 2)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 2)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    if (((warp & 7) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
    }
  }

  __syncthreads();
  if ((warp & 4) != 0) {
    const int cwarp = ((warp & ~7) | 3) * order;
    const T helpA = sfacA[tid % (warp_size * 4)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 4)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 4)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 4)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    if (((warp & 15) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
    }
  }

  __syncthreads();
  if ((warp & 8) != 0) {
    const int cwarp = ((warp & ~15) | 7) * order;
    const T helpA = sfacA[tid % (warp_size * 8)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 8)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 8)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 8)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    if ((warp == 15) && (clane >= 0)) {
      spartc[clane + (15 * order + 0 * delta)] = val0;
    }
  }

  __syncthreads();
  if ((warp & 16) != 0) {
    const int cwarp = 15 * order;
    const T helpA = sfacA[tid % (warp_size * 16)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 16)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 16)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 16)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    if ((warp == 31) && (clane >= 0)) {
      spartc[clane + (31 * order + 0 * delta)] = val0;
    }
  }

  const int idx = tid - (block_size - order);
  if (idx >= 0) {
    fullcarry[chunk_id * order + idx] = val0;
    __threadfence();
    if (idx == 0) {
      status[chunk_id] = 2;
    }
  }

  if (chunk_id > 0) {
    __syncthreads();
    if (warp == 0) {
      const int cidm1 = chunk_id - 1;
      int flag = 1;
      do {
        if ((cidm1 - lane) >= 0) {
          flag = status[cidm1 - lane];
        }
      } while ((__any(flag == 0)) || (__all(flag != 2)));
      int mask = __ballot(flag == 2);
      const int pos = __ffs(mask) - 1;
      T fc;
      if (lane < order) {
        fc = fullcarry[(cidm1 - pos) * order + lane];
      }
      T X0 = __shfl(fc, 0);
      T X1 = __shfl(fc, 1);
      T X2 = __shfl(fc, 2);
      T X3 = __shfl(fc, 3);
      if (lane == 0) {
        sfullc[0] = X0;
        sfullc[1] = X1;
        sfullc[2] = X2;
        sfullc[3] = X3;
      }
    }

    __syncthreads();
    T X0 = sfullc[0];
    val0 += sfacA[tid] * X0;
    T X1 = sfullc[1];
    val0 += sfacB[tid] * X1;
    T X2 = sfullc[2];
    val0 += sfacC[tid] * X2;
    T X3 = sfullc[3];
    val0 += sfacD[tid] * X3;
  }

  if (chunk_id == gridDim.x - 1) {
    if (offs + (0 * block_size) < items) output[offs + (0 * block_size)] = val0;
  } else {
    output[offs + (0 * block_size)] = val0;
  }
}

static __global__ __launch_bounds__(block_size, 2)
void Recurrence2(const int items, const T* const __restrict__ input, T* const __restrict__ output, volatile int* const __restrict__ status, volatile T* const __restrict__ partcarry, volatile T* const __restrict__ fullcarry)
{
  const int valsperthread = 2;
  const int chunk_size = valsperthread * block_size;
  __shared__ T spartc[chunk_size / warp_size * order];
  __shared__ T sfullc[order];
  __shared__ int cid;

  const int tid = threadIdx.x;
  const int warp = tid / warp_size;
  const int lane = tid % warp_size;

  __shared__ T sfacA[block_size];
  __shared__ T sfacB[block_size];
  __shared__ T sfacC[block_size];
  __shared__ T sfacD[block_size];
  if (tid < 511) sfacA[tid] = facA[tid];
  else sfacA[tid] = 0;
  if (tid < 512) sfacB[tid] = facB[tid];
  else sfacB[tid] = 0;
  if (tid < 513) sfacC[tid] = facC[tid];
  else sfacC[tid] = 0;
  if (tid < 514) sfacD[tid] = facD[tid];
  else sfacD[tid] = 0;

  if (tid == 0) {
    cid = atomicInc(&counter, gridDim.x - 1);
  }

  __syncthreads();
  const int chunk_id = cid;
  const int offs = tid + chunk_id * chunk_size;

  T val0, val1;
  if (chunk_id == gridDim.x - 1) {
    val0 = 0;
    if (offs + (0 * block_size) < items) val0 = input[offs + (0 * block_size)];
    val1 = 0;
    if (offs + (1 * block_size) < items) val1 = input[offs + (1 * block_size)];
  } else {
    val0 = input[offs + (0 * block_size)];
    val1 = input[offs + (1 * block_size)];
  }

  val0 *= 2.366700e-01f;
  val1 *= 2.366700e-01f;

  const T sfA = sfacA[lane];
  const T sfB = sfacB[lane];
  const T sfC = sfacC[lane];
  const T sfD = sfacD[lane];

  int cond;
  T help, spc;

  help = -9.840000e-03f;
  cond = ((lane & 1) != 0);
  spc = help * __shfl(val0, 0, 2);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 2);
  if (cond) val1 += spc;

  help = __shfl(sfC, lane % 2);
  cond = ((lane & 2) != 0);
  spc = help * __shfl(val0, 0, 4);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 4);
  if (cond) val1 += spc;

  help = __shfl(sfD, lane % 2);
  cond = ((lane & 2) != 0);
  spc = help * __shfl(val0, 1, 4);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 1, 4);
  if (cond) val1 += spc;

  help = __shfl(sfA, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 0, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 8);
  if (cond) val1 += spc;

  help = __shfl(sfB, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 1, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 1, 8);
  if (cond) val1 += spc;

  help = __shfl(sfC, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 2, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 2, 8);
  if (cond) val1 += spc;

  help = __shfl(sfD, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 3, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 3, 8);
  if (cond) val1 += spc;

  help = __shfl(sfA, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 4, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 4, 16);
  if (cond) val1 += spc;

  help = __shfl(sfB, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 5, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 5, 16);
  if (cond) val1 += spc;

  help = __shfl(sfC, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 6, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 6, 16);
  if (cond) val1 += spc;

  help = __shfl(sfD, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 7, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 7, 16);
  if (cond) val1 += spc;

  help = __shfl(sfA, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 12, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 12, 32);
  if (cond) val1 += spc;

  help = __shfl(sfB, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 13, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 13, 32);
  if (cond) val1 += spc;

  help = __shfl(sfC, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 14, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 14, 32);
  if (cond) val1 += spc;

  help = __shfl(sfD, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 15, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 15, 32);
  if (cond) val1 += spc;

  const int delta = block_size / warp_size * order;
  const int clane = lane - (warp_size - order);
  const int clwo = clane + warp * order;

  if (((warp & 1) == 0) && (clane >= 0)) {
    spartc[clwo + 0 * delta] = val0;
    spartc[clwo + 1 * delta] = val1;
  }

  __syncthreads();
  if ((warp & 1) != 0) {
    const int cwarp = ((warp & ~1) | 0) * order;
    const T helpA = sfacA[tid % (warp_size * 1)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 1)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 1)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 1)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    if (((warp & 3) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
    }
  }

  __syncthreads();
  if ((warp & 2) != 0) {
    const int cwarp = ((warp & ~3) | 1) * order;
    const T helpA = sfacA[tid % (warp_size * 2)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 2)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 2)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 2)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    if (((warp & 7) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
    }
  }

  __syncthreads();
  if ((warp & 4) != 0) {
    const int cwarp = ((warp & ~7) | 3) * order;
    const T helpA = sfacA[tid % (warp_size * 4)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 4)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 4)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 4)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    if (((warp & 15) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
    }
  }

  __syncthreads();
  if ((warp & 8) != 0) {
    const int cwarp = ((warp & ~15) | 7) * order;
    const T helpA = sfacA[tid % (warp_size * 8)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 8)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 8)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 8)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    if ((warp == 15) && (clane >= 0)) {
      spartc[clane + (15 * order + 0 * delta)] = val0;
      spartc[clane + (15 * order + 1 * delta)] = val1;
    }
  }

  __syncthreads();
  if ((warp & 16) != 0) {
    const int cwarp = 15 * order;
    const T helpA = sfacA[tid % (warp_size * 16)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 16)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 16)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 16)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    if ((warp == 31) && (clane >= 0)) {
      spartc[clane + (31 * order + 0 * delta)] = val0;
    }
  }

  __syncthreads();
 if (warp < 17) {
  val1 += sfacA[tid] * spartc[31 * order + (0 * delta + 0)];
  val1 += sfacB[tid] * spartc[31 * order + (0 * delta + 1)];
  val1 += sfacC[tid] * spartc[31 * order + (0 * delta + 2)];
  val1 += sfacD[tid] * spartc[31 * order + (0 * delta + 3)];
 }

  const int idx = tid - (block_size - order);
  if (idx >= 0) {
    fullcarry[chunk_id * order + idx] = val1;
    __threadfence();
    if (idx == 0) {
      status[chunk_id] = 2;
    }
  }

  if (chunk_id > 0) {
    __syncthreads();
    if (warp == 0) {
      const int cidm1 = chunk_id - 1;
      int flag = 1;
      do {
        if ((cidm1 - lane) >= 0) {
          flag = status[cidm1 - lane];
        }
      } while ((__any(flag == 0)) || (__all(flag != 2)));
      int mask = __ballot(flag == 2);
      const int pos = __ffs(mask) - 1;
      T fc;
      if (lane < order) {
        fc = fullcarry[(cidm1 - pos) * order + lane];
      }
      T X0 = __shfl(fc, 0);
      T X1 = __shfl(fc, 1);
      T X2 = __shfl(fc, 2);
      T X3 = __shfl(fc, 3);
      if (lane == 0) {
        sfullc[0] = X0;
        sfullc[1] = X1;
        sfullc[2] = X2;
        sfullc[3] = X3;
      }
    }

    __syncthreads();
    T X0 = sfullc[0];
    val0 += sfacA[tid] * X0;
    T X1 = sfullc[1];
    val0 += sfacB[tid] * X1;
    T X2 = sfullc[2];
    val0 += sfacC[tid] * X2;
    T X3 = sfullc[3];
    val0 += sfacD[tid] * X3;
  }

  if (chunk_id == gridDim.x - 1) {
    if (offs + (0 * block_size) < items) output[offs + (0 * block_size)] = val0;
    if (offs + (1 * block_size) < items) output[offs + (1 * block_size)] = val1;
  } else {
    output[offs + (0 * block_size)] = val0;
    output[offs + (1 * block_size)] = val1;
  }
}

static __global__ __launch_bounds__(block_size, 2)
void Recurrence3(const int items, const T* const __restrict__ input, T* const __restrict__ output, volatile int* const __restrict__ status, volatile T* const __restrict__ partcarry, volatile T* const __restrict__ fullcarry)
{
  const int valsperthread = 3;
  const int chunk_size = valsperthread * block_size;
  __shared__ T spartc[chunk_size / warp_size * order];
  __shared__ T sfullc[order];
  __shared__ int cid;

  const int tid = threadIdx.x;
  const int warp = tid / warp_size;
  const int lane = tid % warp_size;

  __shared__ T sfacA[block_size];
  __shared__ T sfacB[block_size];
  __shared__ T sfacC[block_size];
  __shared__ T sfacD[block_size];
  if (tid < 511) sfacA[tid] = facA[tid];
  else sfacA[tid] = 0;
  if (tid < 512) sfacB[tid] = facB[tid];
  else sfacB[tid] = 0;
  if (tid < 513) sfacC[tid] = facC[tid];
  else sfacC[tid] = 0;
  if (tid < 514) sfacD[tid] = facD[tid];
  else sfacD[tid] = 0;

  if (tid == 0) {
    cid = atomicInc(&counter, gridDim.x - 1);
  }

  __syncthreads();
  const int chunk_id = cid;
  const int offs = tid + chunk_id * chunk_size;

  T val0, val1, val2;
  if (chunk_id == gridDim.x - 1) {
    val0 = 0;
    if (offs + (0 * block_size) < items) val0 = input[offs + (0 * block_size)];
    val1 = 0;
    if (offs + (1 * block_size) < items) val1 = input[offs + (1 * block_size)];
    val2 = 0;
    if (offs + (2 * block_size) < items) val2 = input[offs + (2 * block_size)];
  } else {
    val0 = input[offs + (0 * block_size)];
    val1 = input[offs + (1 * block_size)];
    val2 = input[offs + (2 * block_size)];
  }

  val0 *= 2.366700e-01f;
  val1 *= 2.366700e-01f;
  val2 *= 2.366700e-01f;

  const T sfA = sfacA[lane];
  const T sfB = sfacB[lane];
  const T sfC = sfacC[lane];
  const T sfD = sfacD[lane];

  int cond;
  T help, spc;

  help = -9.840000e-03f;
  cond = ((lane & 1) != 0);
  spc = help * __shfl(val0, 0, 2);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 2);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 2);
  if (cond) val2 += spc;

  help = __shfl(sfC, lane % 2);
  cond = ((lane & 2) != 0);
  spc = help * __shfl(val0, 0, 4);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 4);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 4);
  if (cond) val2 += spc;

  help = __shfl(sfD, lane % 2);
  cond = ((lane & 2) != 0);
  spc = help * __shfl(val0, 1, 4);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 1, 4);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 1, 4);
  if (cond) val2 += spc;

  help = __shfl(sfA, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 0, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 8);
  if (cond) val2 += spc;

  help = __shfl(sfB, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 1, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 1, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 1, 8);
  if (cond) val2 += spc;

  help = __shfl(sfC, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 2, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 2, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 2, 8);
  if (cond) val2 += spc;

  help = __shfl(sfD, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 3, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 3, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 3, 8);
  if (cond) val2 += spc;

  help = __shfl(sfA, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 4, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 4, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 4, 16);
  if (cond) val2 += spc;

  help = __shfl(sfB, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 5, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 5, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 5, 16);
  if (cond) val2 += spc;

  help = __shfl(sfC, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 6, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 6, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 6, 16);
  if (cond) val2 += spc;

  help = __shfl(sfD, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 7, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 7, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 7, 16);
  if (cond) val2 += spc;

  help = __shfl(sfA, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 12, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 12, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 12, 32);
  if (cond) val2 += spc;

  help = __shfl(sfB, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 13, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 13, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 13, 32);
  if (cond) val2 += spc;

  help = __shfl(sfC, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 14, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 14, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 14, 32);
  if (cond) val2 += spc;

  help = __shfl(sfD, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 15, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 15, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 15, 32);
  if (cond) val2 += spc;

  const int delta = block_size / warp_size * order;
  const int clane = lane - (warp_size - order);
  const int clwo = clane + warp * order;

  if (((warp & 1) == 0) && (clane >= 0)) {
    spartc[clwo + 0 * delta] = val0;
    spartc[clwo + 1 * delta] = val1;
    spartc[clwo + 2 * delta] = val2;
  }

  __syncthreads();
  if ((warp & 1) != 0) {
    const int cwarp = ((warp & ~1) | 0) * order;
    const T helpA = sfacA[tid % (warp_size * 1)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 1)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 1)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 1)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    if (((warp & 3) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
    }
  }

  __syncthreads();
  if ((warp & 2) != 0) {
    const int cwarp = ((warp & ~3) | 1) * order;
    const T helpA = sfacA[tid % (warp_size * 2)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 2)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 2)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 2)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    if (((warp & 7) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
    }
  }

  __syncthreads();
  if ((warp & 4) != 0) {
    const int cwarp = ((warp & ~7) | 3) * order;
    const T helpA = sfacA[tid % (warp_size * 4)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 4)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 4)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 4)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    if (((warp & 15) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
    }
  }

  __syncthreads();
  if ((warp & 8) != 0) {
    const int cwarp = ((warp & ~15) | 7) * order;
    const T helpA = sfacA[tid % (warp_size * 8)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 8)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 8)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 8)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    if ((warp == 15) && (clane >= 0)) {
      spartc[clane + (15 * order + 0 * delta)] = val0;
      spartc[clane + (15 * order + 1 * delta)] = val1;
      spartc[clane + (15 * order + 2 * delta)] = val2;
    }
  }

  __syncthreads();
  if ((warp & 16) != 0) {
    const int cwarp = 15 * order;
    const T helpA = sfacA[tid % (warp_size * 16)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 16)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 16)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 16)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    if ((warp == 31) && (clane >= 0)) {
      spartc[clane + (31 * order + 0 * delta)] = val0;
      spartc[clane + (31 * order + 2 * delta)] = val2;
    }
  }

  __syncthreads();
 if (warp < 17) {
  val1 += sfacA[tid] * spartc[31 * order + (0 * delta + 0)];
  val1 += sfacB[tid] * spartc[31 * order + (0 * delta + 1)];
  val1 += sfacC[tid] * spartc[31 * order + (0 * delta + 2)];
  val1 += sfacD[tid] * spartc[31 * order + (0 * delta + 3)];
 }
  if ((warp == 31) && (clane >= 0)) {
    spartc[clane + (31 * order + 1 * delta)] = val1;
  }

  __syncthreads();
 if (warp < 17) {
  val2 += sfacA[tid] * spartc[31 * order + (1 * delta + 0)];
  val2 += sfacB[tid] * spartc[31 * order + (1 * delta + 1)];
  val2 += sfacC[tid] * spartc[31 * order + (1 * delta + 2)];
  val2 += sfacD[tid] * spartc[31 * order + (1 * delta + 3)];
 }

  const int idx = tid - (block_size - order);
  if (idx >= 0) {
    fullcarry[chunk_id * order + idx] = val2;
    __threadfence();
    if (idx == 0) {
      status[chunk_id] = 2;
    }
  }

  if (chunk_id > 0) {
    __syncthreads();
    if (warp == 0) {
      const int cidm1 = chunk_id - 1;
      int flag = 1;
      do {
        if ((cidm1 - lane) >= 0) {
          flag = status[cidm1 - lane];
        }
      } while ((__any(flag == 0)) || (__all(flag != 2)));
      int mask = __ballot(flag == 2);
      const int pos = __ffs(mask) - 1;
      T fc;
      if (lane < order) {
        fc = fullcarry[(cidm1 - pos) * order + lane];
      }
      T X0 = __shfl(fc, 0);
      T X1 = __shfl(fc, 1);
      T X2 = __shfl(fc, 2);
      T X3 = __shfl(fc, 3);
      if (lane == 0) {
        sfullc[0] = X0;
        sfullc[1] = X1;
        sfullc[2] = X2;
        sfullc[3] = X3;
      }
    }

    __syncthreads();
    T X0 = sfullc[0];
    val0 += sfacA[tid] * X0;
    T X1 = sfullc[1];
    val0 += sfacB[tid] * X1;
    T X2 = sfullc[2];
    val0 += sfacC[tid] * X2;
    T X3 = sfullc[3];
    val0 += sfacD[tid] * X3;
  }

  if (chunk_id == gridDim.x - 1) {
    if (offs + (0 * block_size) < items) output[offs + (0 * block_size)] = val0;
    if (offs + (1 * block_size) < items) output[offs + (1 * block_size)] = val1;
    if (offs + (2 * block_size) < items) output[offs + (2 * block_size)] = val2;
  } else {
    output[offs + (0 * block_size)] = val0;
    output[offs + (1 * block_size)] = val1;
    output[offs + (2 * block_size)] = val2;
  }
}

static __global__ __launch_bounds__(block_size, 2)
void Recurrence4(const int items, const T* const __restrict__ input, T* const __restrict__ output, volatile int* const __restrict__ status, volatile T* const __restrict__ partcarry, volatile T* const __restrict__ fullcarry)
{
  const int valsperthread = 4;
  const int chunk_size = valsperthread * block_size;
  __shared__ T spartc[chunk_size / warp_size * order];
  __shared__ T sfullc[order];
  __shared__ int cid;

  const int tid = threadIdx.x;
  const int warp = tid / warp_size;
  const int lane = tid % warp_size;

  __shared__ T sfacA[block_size];
  __shared__ T sfacB[block_size];
  __shared__ T sfacC[block_size];
  __shared__ T sfacD[block_size];
  if (tid < 511) sfacA[tid] = facA[tid];
  else sfacA[tid] = 0;
  if (tid < 512) sfacB[tid] = facB[tid];
  else sfacB[tid] = 0;
  if (tid < 513) sfacC[tid] = facC[tid];
  else sfacC[tid] = 0;
  if (tid < 514) sfacD[tid] = facD[tid];
  else sfacD[tid] = 0;

  if (tid == 0) {
    cid = atomicInc(&counter, gridDim.x - 1);
  }

  __syncthreads();
  const int chunk_id = cid;
  const int offs = tid + chunk_id * chunk_size;

  T val0, val1, val2, val3;
  if (chunk_id == gridDim.x - 1) {
    val0 = 0;
    if (offs + (0 * block_size) < items) val0 = input[offs + (0 * block_size)];
    val1 = 0;
    if (offs + (1 * block_size) < items) val1 = input[offs + (1 * block_size)];
    val2 = 0;
    if (offs + (2 * block_size) < items) val2 = input[offs + (2 * block_size)];
    val3 = 0;
    if (offs + (3 * block_size) < items) val3 = input[offs + (3 * block_size)];
  } else {
    val0 = input[offs + (0 * block_size)];
    val1 = input[offs + (1 * block_size)];
    val2 = input[offs + (2 * block_size)];
    val3 = input[offs + (3 * block_size)];
  }

  val0 *= 2.366700e-01f;
  val1 *= 2.366700e-01f;
  val2 *= 2.366700e-01f;
  val3 *= 2.366700e-01f;

  const T sfA = sfacA[lane];
  const T sfB = sfacB[lane];
  const T sfC = sfacC[lane];
  const T sfD = sfacD[lane];

  int cond;
  T help, spc;

  help = -9.840000e-03f;
  cond = ((lane & 1) != 0);
  spc = help * __shfl(val0, 0, 2);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 2);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 2);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 0, 2);
  if (cond) val3 += spc;

  help = __shfl(sfC, lane % 2);
  cond = ((lane & 2) != 0);
  spc = help * __shfl(val0, 0, 4);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 4);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 4);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 0, 4);
  if (cond) val3 += spc;

  help = __shfl(sfD, lane % 2);
  cond = ((lane & 2) != 0);
  spc = help * __shfl(val0, 1, 4);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 1, 4);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 1, 4);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 1, 4);
  if (cond) val3 += spc;

  help = __shfl(sfA, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 0, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 0, 8);
  if (cond) val3 += spc;

  help = __shfl(sfB, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 1, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 1, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 1, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 1, 8);
  if (cond) val3 += spc;

  help = __shfl(sfC, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 2, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 2, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 2, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 2, 8);
  if (cond) val3 += spc;

  help = __shfl(sfD, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 3, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 3, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 3, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 3, 8);
  if (cond) val3 += spc;

  help = __shfl(sfA, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 4, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 4, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 4, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 4, 16);
  if (cond) val3 += spc;

  help = __shfl(sfB, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 5, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 5, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 5, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 5, 16);
  if (cond) val3 += spc;

  help = __shfl(sfC, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 6, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 6, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 6, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 6, 16);
  if (cond) val3 += spc;

  help = __shfl(sfD, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 7, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 7, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 7, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 7, 16);
  if (cond) val3 += spc;

  help = __shfl(sfA, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 12, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 12, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 12, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 12, 32);
  if (cond) val3 += spc;

  help = __shfl(sfB, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 13, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 13, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 13, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 13, 32);
  if (cond) val3 += spc;

  help = __shfl(sfC, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 14, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 14, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 14, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 14, 32);
  if (cond) val3 += spc;

  help = __shfl(sfD, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 15, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 15, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 15, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 15, 32);
  if (cond) val3 += spc;

  const int delta = block_size / warp_size * order;
  const int clane = lane - (warp_size - order);
  const int clwo = clane + warp * order;

  if (((warp & 1) == 0) && (clane >= 0)) {
    spartc[clwo + 0 * delta] = val0;
    spartc[clwo + 1 * delta] = val1;
    spartc[clwo + 2 * delta] = val2;
    spartc[clwo + 3 * delta] = val3;
  }

  __syncthreads();
  if ((warp & 1) != 0) {
    const int cwarp = ((warp & ~1) | 0) * order;
    const T helpA = sfacA[tid % (warp_size * 1)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 1)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 1)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 1)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    if (((warp & 3) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
      spartc[clwo + 3 * delta] = val3;
    }
  }

  __syncthreads();
  if ((warp & 2) != 0) {
    const int cwarp = ((warp & ~3) | 1) * order;
    const T helpA = sfacA[tid % (warp_size * 2)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 2)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 2)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 2)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    if (((warp & 7) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
      spartc[clwo + 3 * delta] = val3;
    }
  }

  __syncthreads();
  if ((warp & 4) != 0) {
    const int cwarp = ((warp & ~7) | 3) * order;
    const T helpA = sfacA[tid % (warp_size * 4)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 4)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 4)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 4)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    if (((warp & 15) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
      spartc[clwo + 3 * delta] = val3;
    }
  }

  __syncthreads();
  if ((warp & 8) != 0) {
    const int cwarp = ((warp & ~15) | 7) * order;
    const T helpA = sfacA[tid % (warp_size * 8)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 8)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 8)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 8)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    if ((warp == 15) && (clane >= 0)) {
      spartc[clane + (15 * order + 0 * delta)] = val0;
      spartc[clane + (15 * order + 1 * delta)] = val1;
      spartc[clane + (15 * order + 2 * delta)] = val2;
      spartc[clane + (15 * order + 3 * delta)] = val3;
    }
  }

  __syncthreads();
  if ((warp & 16) != 0) {
    const int cwarp = 15 * order;
    const T helpA = sfacA[tid % (warp_size * 16)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 16)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 16)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 16)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    if ((warp == 31) && (clane >= 0)) {
      spartc[clane + (31 * order + 0 * delta)] = val0;
      spartc[clane + (31 * order + 2 * delta)] = val2;
    }
  }

  __syncthreads();
 if (warp < 17) {
  val1 += sfacA[tid] * spartc[31 * order + (0 * delta + 0)];
  val3 += sfacA[tid] * spartc[31 * order + (2 * delta + 0)];
  val1 += sfacB[tid] * spartc[31 * order + (0 * delta + 1)];
  val3 += sfacB[tid] * spartc[31 * order + (2 * delta + 1)];
  val1 += sfacC[tid] * spartc[31 * order + (0 * delta + 2)];
  val3 += sfacC[tid] * spartc[31 * order + (2 * delta + 2)];
  val1 += sfacD[tid] * spartc[31 * order + (0 * delta + 3)];
  val3 += sfacD[tid] * spartc[31 * order + (2 * delta + 3)];
 }
  if ((warp == 31) && (clane >= 0)) {
    spartc[clane + (31 * order + 1 * delta)] = val1;
  }

  __syncthreads();
 if (warp < 17) {
  val2 += sfacA[tid] * spartc[31 * order + (1 * delta + 0)];
  val2 += sfacB[tid] * spartc[31 * order + (1 * delta + 1)];
  val2 += sfacC[tid] * spartc[31 * order + (1 * delta + 2)];
  val2 += sfacD[tid] * spartc[31 * order + (1 * delta + 3)];
 }

  const int idx = tid - (block_size - order);
  if (idx >= 0) {
    fullcarry[chunk_id * order + idx] = val3;
    __threadfence();
    if (idx == 0) {
      status[chunk_id] = 2;
    }
  }

  if (chunk_id > 0) {
    __syncthreads();
    if (warp == 0) {
      const int cidm1 = chunk_id - 1;
      int flag = 1;
      do {
        if ((cidm1 - lane) >= 0) {
          flag = status[cidm1 - lane];
        }
      } while ((__any(flag == 0)) || (__all(flag != 2)));
      int mask = __ballot(flag == 2);
      const int pos = __ffs(mask) - 1;
      T fc;
      if (lane < order) {
        fc = fullcarry[(cidm1 - pos) * order + lane];
      }
      T X0 = __shfl(fc, 0);
      T X1 = __shfl(fc, 1);
      T X2 = __shfl(fc, 2);
      T X3 = __shfl(fc, 3);
      if (lane == 0) {
        sfullc[0] = X0;
        sfullc[1] = X1;
        sfullc[2] = X2;
        sfullc[3] = X3;
      }
    }

    __syncthreads();
    T X0 = sfullc[0];
    val0 += sfacA[tid] * X0;
    T X1 = sfullc[1];
    val0 += sfacB[tid] * X1;
    T X2 = sfullc[2];
    val0 += sfacC[tid] * X2;
    T X3 = sfullc[3];
    val0 += sfacD[tid] * X3;
  }

  if (chunk_id == gridDim.x - 1) {
    if (offs + (0 * block_size) < items) output[offs + (0 * block_size)] = val0;
    if (offs + (1 * block_size) < items) output[offs + (1 * block_size)] = val1;
    if (offs + (2 * block_size) < items) output[offs + (2 * block_size)] = val2;
    if (offs + (3 * block_size) < items) output[offs + (3 * block_size)] = val3;
  } else {
    output[offs + (0 * block_size)] = val0;
    output[offs + (1 * block_size)] = val1;
    output[offs + (2 * block_size)] = val2;
    output[offs + (3 * block_size)] = val3;
  }
}

static __global__ __launch_bounds__(block_size, 2)
void Recurrence5(const int items, const T* const __restrict__ input, T* const __restrict__ output, volatile int* const __restrict__ status, volatile T* const __restrict__ partcarry, volatile T* const __restrict__ fullcarry)
{
  const int valsperthread = 5;
  const int chunk_size = valsperthread * block_size;
  __shared__ T spartc[chunk_size / warp_size * order];
  __shared__ T sfullc[order];
  __shared__ int cid;

  const int tid = threadIdx.x;
  const int warp = tid / warp_size;
  const int lane = tid % warp_size;

  __shared__ T sfacA[block_size];
  __shared__ T sfacB[block_size];
  __shared__ T sfacC[block_size];
  __shared__ T sfacD[block_size];
  if (tid < 511) sfacA[tid] = facA[tid];
  else sfacA[tid] = 0;
  if (tid < 512) sfacB[tid] = facB[tid];
  else sfacB[tid] = 0;
  if (tid < 513) sfacC[tid] = facC[tid];
  else sfacC[tid] = 0;
  if (tid < 514) sfacD[tid] = facD[tid];
  else sfacD[tid] = 0;

  if (tid == 0) {
    cid = atomicInc(&counter, gridDim.x - 1);
  }

  __syncthreads();
  const int chunk_id = cid;
  const int offs = tid + chunk_id * chunk_size;

  T val0, val1, val2, val3, val4;
  if (chunk_id == gridDim.x - 1) {
    val0 = 0;
    if (offs + (0 * block_size) < items) val0 = input[offs + (0 * block_size)];
    val1 = 0;
    if (offs + (1 * block_size) < items) val1 = input[offs + (1 * block_size)];
    val2 = 0;
    if (offs + (2 * block_size) < items) val2 = input[offs + (2 * block_size)];
    val3 = 0;
    if (offs + (3 * block_size) < items) val3 = input[offs + (3 * block_size)];
    val4 = 0;
    if (offs + (4 * block_size) < items) val4 = input[offs + (4 * block_size)];
  } else {
    val0 = input[offs + (0 * block_size)];
    val1 = input[offs + (1 * block_size)];
    val2 = input[offs + (2 * block_size)];
    val3 = input[offs + (3 * block_size)];
    val4 = input[offs + (4 * block_size)];
  }

  val0 *= 2.366700e-01f;
  val1 *= 2.366700e-01f;
  val2 *= 2.366700e-01f;
  val3 *= 2.366700e-01f;
  val4 *= 2.366700e-01f;

  const T sfA = sfacA[lane];
  const T sfB = sfacB[lane];
  const T sfC = sfacC[lane];
  const T sfD = sfacD[lane];

  int cond;
  T help, spc;

  help = -9.840000e-03f;
  cond = ((lane & 1) != 0);
  spc = help * __shfl(val0, 0, 2);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 2);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 2);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 0, 2);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 0, 2);
  if (cond) val4 += spc;

  help = __shfl(sfC, lane % 2);
  cond = ((lane & 2) != 0);
  spc = help * __shfl(val0, 0, 4);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 4);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 4);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 0, 4);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 0, 4);
  if (cond) val4 += spc;

  help = __shfl(sfD, lane % 2);
  cond = ((lane & 2) != 0);
  spc = help * __shfl(val0, 1, 4);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 1, 4);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 1, 4);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 1, 4);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 1, 4);
  if (cond) val4 += spc;

  help = __shfl(sfA, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 0, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 0, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 0, 8);
  if (cond) val4 += spc;

  help = __shfl(sfB, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 1, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 1, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 1, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 1, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 1, 8);
  if (cond) val4 += spc;

  help = __shfl(sfC, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 2, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 2, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 2, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 2, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 2, 8);
  if (cond) val4 += spc;

  help = __shfl(sfD, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 3, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 3, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 3, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 3, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 3, 8);
  if (cond) val4 += spc;

  help = __shfl(sfA, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 4, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 4, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 4, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 4, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 4, 16);
  if (cond) val4 += spc;

  help = __shfl(sfB, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 5, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 5, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 5, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 5, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 5, 16);
  if (cond) val4 += spc;

  help = __shfl(sfC, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 6, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 6, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 6, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 6, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 6, 16);
  if (cond) val4 += spc;

  help = __shfl(sfD, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 7, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 7, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 7, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 7, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 7, 16);
  if (cond) val4 += spc;

  help = __shfl(sfA, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 12, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 12, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 12, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 12, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 12, 32);
  if (cond) val4 += spc;

  help = __shfl(sfB, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 13, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 13, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 13, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 13, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 13, 32);
  if (cond) val4 += spc;

  help = __shfl(sfC, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 14, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 14, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 14, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 14, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 14, 32);
  if (cond) val4 += spc;

  help = __shfl(sfD, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 15, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 15, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 15, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 15, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 15, 32);
  if (cond) val4 += spc;

  const int delta = block_size / warp_size * order;
  const int clane = lane - (warp_size - order);
  const int clwo = clane + warp * order;

  if (((warp & 1) == 0) && (clane >= 0)) {
    spartc[clwo + 0 * delta] = val0;
    spartc[clwo + 1 * delta] = val1;
    spartc[clwo + 2 * delta] = val2;
    spartc[clwo + 3 * delta] = val3;
    spartc[clwo + 4 * delta] = val4;
  }

  __syncthreads();
  if ((warp & 1) != 0) {
    const int cwarp = ((warp & ~1) | 0) * order;
    const T helpA = sfacA[tid % (warp_size * 1)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 1)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 1)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 1)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    if (((warp & 3) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
      spartc[clwo + 3 * delta] = val3;
      spartc[clwo + 4 * delta] = val4;
    }
  }

  __syncthreads();
  if ((warp & 2) != 0) {
    const int cwarp = ((warp & ~3) | 1) * order;
    const T helpA = sfacA[tid % (warp_size * 2)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 2)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 2)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 2)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    if (((warp & 7) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
      spartc[clwo + 3 * delta] = val3;
      spartc[clwo + 4 * delta] = val4;
    }
  }

  __syncthreads();
  if ((warp & 4) != 0) {
    const int cwarp = ((warp & ~7) | 3) * order;
    const T helpA = sfacA[tid % (warp_size * 4)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 4)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 4)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 4)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    if (((warp & 15) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
      spartc[clwo + 3 * delta] = val3;
      spartc[clwo + 4 * delta] = val4;
    }
  }

  __syncthreads();
  if ((warp & 8) != 0) {
    const int cwarp = ((warp & ~15) | 7) * order;
    const T helpA = sfacA[tid % (warp_size * 8)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 8)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 8)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 8)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    if ((warp == 15) && (clane >= 0)) {
      spartc[clane + (15 * order + 0 * delta)] = val0;
      spartc[clane + (15 * order + 1 * delta)] = val1;
      spartc[clane + (15 * order + 2 * delta)] = val2;
      spartc[clane + (15 * order + 3 * delta)] = val3;
      spartc[clane + (15 * order + 4 * delta)] = val4;
    }
  }

  __syncthreads();
  if ((warp & 16) != 0) {
    const int cwarp = 15 * order;
    const T helpA = sfacA[tid % (warp_size * 16)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 16)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 16)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 16)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    if ((warp == 31) && (clane >= 0)) {
      spartc[clane + (31 * order + 0 * delta)] = val0;
      spartc[clane + (31 * order + 2 * delta)] = val2;
      spartc[clane + (31 * order + 4 * delta)] = val4;
    }
  }

  __syncthreads();
 if (warp < 17) {
  val1 += sfacA[tid] * spartc[31 * order + (0 * delta + 0)];
  val3 += sfacA[tid] * spartc[31 * order + (2 * delta + 0)];
  val1 += sfacB[tid] * spartc[31 * order + (0 * delta + 1)];
  val3 += sfacB[tid] * spartc[31 * order + (2 * delta + 1)];
  val1 += sfacC[tid] * spartc[31 * order + (0 * delta + 2)];
  val3 += sfacC[tid] * spartc[31 * order + (2 * delta + 2)];
  val1 += sfacD[tid] * spartc[31 * order + (0 * delta + 3)];
  val3 += sfacD[tid] * spartc[31 * order + (2 * delta + 3)];
 }
  if ((warp == 31) && (clane >= 0)) {
    spartc[clane + (31 * order + 1 * delta)] = val1;
  }

  __syncthreads();
 if (warp < 17) {
  val2 += sfacA[tid] * spartc[31 * order + (1 * delta + 0)];
  val2 += sfacB[tid] * spartc[31 * order + (1 * delta + 1)];
  val2 += sfacC[tid] * spartc[31 * order + (1 * delta + 2)];
  val2 += sfacD[tid] * spartc[31 * order + (1 * delta + 3)];
 }
  if ((warp == 31) && (clane >= 0)) {
    spartc[clane + (31 * order + 3 * delta)] = val3;
  }

  __syncthreads();
 if (warp < 17) {
  val4 += sfacA[tid] * spartc[31 * order + (3 * delta + 0)];
  val4 += sfacB[tid] * spartc[31 * order + (3 * delta + 1)];
  val4 += sfacC[tid] * spartc[31 * order + (3 * delta + 2)];
  val4 += sfacD[tid] * spartc[31 * order + (3 * delta + 3)];
 }

  const int idx = tid - (block_size - order);
  if (idx >= 0) {
    fullcarry[chunk_id * order + idx] = val4;
    __threadfence();
    if (idx == 0) {
      status[chunk_id] = 2;
    }
  }

  if (chunk_id > 0) {
    __syncthreads();
    if (warp == 0) {
      const int cidm1 = chunk_id - 1;
      int flag = 1;
      do {
        if ((cidm1 - lane) >= 0) {
          flag = status[cidm1 - lane];
        }
      } while ((__any(flag == 0)) || (__all(flag != 2)));
      int mask = __ballot(flag == 2);
      const int pos = __ffs(mask) - 1;
      T fc;
      if (lane < order) {
        fc = fullcarry[(cidm1 - pos) * order + lane];
      }
      T X0 = __shfl(fc, 0);
      T X1 = __shfl(fc, 1);
      T X2 = __shfl(fc, 2);
      T X3 = __shfl(fc, 3);
      if (lane == 0) {
        sfullc[0] = X0;
        sfullc[1] = X1;
        sfullc[2] = X2;
        sfullc[3] = X3;
      }
    }

    __syncthreads();
    T X0 = sfullc[0];
    val0 += sfacA[tid] * X0;
    T X1 = sfullc[1];
    val0 += sfacB[tid] * X1;
    T X2 = sfullc[2];
    val0 += sfacC[tid] * X2;
    T X3 = sfullc[3];
    val0 += sfacD[tid] * X3;
  }

  if (chunk_id == gridDim.x - 1) {
    if (offs + (0 * block_size) < items) output[offs + (0 * block_size)] = val0;
    if (offs + (1 * block_size) < items) output[offs + (1 * block_size)] = val1;
    if (offs + (2 * block_size) < items) output[offs + (2 * block_size)] = val2;
    if (offs + (3 * block_size) < items) output[offs + (3 * block_size)] = val3;
    if (offs + (4 * block_size) < items) output[offs + (4 * block_size)] = val4;
  } else {
    output[offs + (0 * block_size)] = val0;
    output[offs + (1 * block_size)] = val1;
    output[offs + (2 * block_size)] = val2;
    output[offs + (3 * block_size)] = val3;
    output[offs + (4 * block_size)] = val4;
  }
}

static __global__ __launch_bounds__(block_size, 2)
void Recurrence6(const int items, const T* const __restrict__ input, T* const __restrict__ output, volatile int* const __restrict__ status, volatile T* const __restrict__ partcarry, volatile T* const __restrict__ fullcarry)
{
  const int valsperthread = 6;
  const int chunk_size = valsperthread * block_size;
  __shared__ T spartc[chunk_size / warp_size * order];
  __shared__ T sfullc[order];
  __shared__ int cid;

  const int tid = threadIdx.x;
  const int warp = tid / warp_size;
  const int lane = tid % warp_size;

  __shared__ T sfacA[block_size];
  __shared__ T sfacB[block_size];
  __shared__ T sfacC[block_size];
  __shared__ T sfacD[block_size];
  if (tid < 511) sfacA[tid] = facA[tid];
  else sfacA[tid] = 0;
  if (tid < 512) sfacB[tid] = facB[tid];
  else sfacB[tid] = 0;
  if (tid < 513) sfacC[tid] = facC[tid];
  else sfacC[tid] = 0;
  if (tid < 514) sfacD[tid] = facD[tid];
  else sfacD[tid] = 0;

  if (tid == 0) {
    cid = atomicInc(&counter, gridDim.x - 1);
  }

  __syncthreads();
  const int chunk_id = cid;
  const int offs = tid + chunk_id * chunk_size;

  T val0, val1, val2, val3, val4, val5;
  if (chunk_id == gridDim.x - 1) {
    val0 = 0;
    if (offs + (0 * block_size) < items) val0 = input[offs + (0 * block_size)];
    val1 = 0;
    if (offs + (1 * block_size) < items) val1 = input[offs + (1 * block_size)];
    val2 = 0;
    if (offs + (2 * block_size) < items) val2 = input[offs + (2 * block_size)];
    val3 = 0;
    if (offs + (3 * block_size) < items) val3 = input[offs + (3 * block_size)];
    val4 = 0;
    if (offs + (4 * block_size) < items) val4 = input[offs + (4 * block_size)];
    val5 = 0;
    if (offs + (5 * block_size) < items) val5 = input[offs + (5 * block_size)];
  } else {
    val0 = input[offs + (0 * block_size)];
    val1 = input[offs + (1 * block_size)];
    val2 = input[offs + (2 * block_size)];
    val3 = input[offs + (3 * block_size)];
    val4 = input[offs + (4 * block_size)];
    val5 = input[offs + (5 * block_size)];
  }

  val0 *= 2.366700e-01f;
  val1 *= 2.366700e-01f;
  val2 *= 2.366700e-01f;
  val3 *= 2.366700e-01f;
  val4 *= 2.366700e-01f;
  val5 *= 2.366700e-01f;

  const T sfA = sfacA[lane];
  const T sfB = sfacB[lane];
  const T sfC = sfacC[lane];
  const T sfD = sfacD[lane];

  int cond;
  T help, spc;

  help = -9.840000e-03f;
  cond = ((lane & 1) != 0);
  spc = help * __shfl(val0, 0, 2);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 2);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 2);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 0, 2);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 0, 2);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 0, 2);
  if (cond) val5 += spc;

  help = __shfl(sfC, lane % 2);
  cond = ((lane & 2) != 0);
  spc = help * __shfl(val0, 0, 4);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 4);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 4);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 0, 4);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 0, 4);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 0, 4);
  if (cond) val5 += spc;

  help = __shfl(sfD, lane % 2);
  cond = ((lane & 2) != 0);
  spc = help * __shfl(val0, 1, 4);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 1, 4);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 1, 4);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 1, 4);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 1, 4);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 1, 4);
  if (cond) val5 += spc;

  help = __shfl(sfA, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 0, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 0, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 0, 8);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 0, 8);
  if (cond) val5 += spc;

  help = __shfl(sfB, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 1, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 1, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 1, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 1, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 1, 8);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 1, 8);
  if (cond) val5 += spc;

  help = __shfl(sfC, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 2, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 2, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 2, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 2, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 2, 8);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 2, 8);
  if (cond) val5 += spc;

  help = __shfl(sfD, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 3, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 3, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 3, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 3, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 3, 8);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 3, 8);
  if (cond) val5 += spc;

  help = __shfl(sfA, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 4, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 4, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 4, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 4, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 4, 16);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 4, 16);
  if (cond) val5 += spc;

  help = __shfl(sfB, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 5, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 5, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 5, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 5, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 5, 16);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 5, 16);
  if (cond) val5 += spc;

  help = __shfl(sfC, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 6, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 6, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 6, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 6, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 6, 16);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 6, 16);
  if (cond) val5 += spc;

  help = __shfl(sfD, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 7, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 7, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 7, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 7, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 7, 16);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 7, 16);
  if (cond) val5 += spc;

  help = __shfl(sfA, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 12, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 12, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 12, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 12, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 12, 32);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 12, 32);
  if (cond) val5 += spc;

  help = __shfl(sfB, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 13, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 13, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 13, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 13, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 13, 32);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 13, 32);
  if (cond) val5 += spc;

  help = __shfl(sfC, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 14, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 14, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 14, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 14, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 14, 32);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 14, 32);
  if (cond) val5 += spc;

  help = __shfl(sfD, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 15, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 15, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 15, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 15, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 15, 32);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 15, 32);
  if (cond) val5 += spc;

  const int delta = block_size / warp_size * order;
  const int clane = lane - (warp_size - order);
  const int clwo = clane + warp * order;

  if (((warp & 1) == 0) && (clane >= 0)) {
    spartc[clwo + 0 * delta] = val0;
    spartc[clwo + 1 * delta] = val1;
    spartc[clwo + 2 * delta] = val2;
    spartc[clwo + 3 * delta] = val3;
    spartc[clwo + 4 * delta] = val4;
    spartc[clwo + 5 * delta] = val5;
  }

  __syncthreads();
  if ((warp & 1) != 0) {
    const int cwarp = ((warp & ~1) | 0) * order;
    const T helpA = sfacA[tid % (warp_size * 1)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 1)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 1)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 1)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    if (((warp & 3) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
      spartc[clwo + 3 * delta] = val3;
      spartc[clwo + 4 * delta] = val4;
      spartc[clwo + 5 * delta] = val5;
    }
  }

  __syncthreads();
  if ((warp & 2) != 0) {
    const int cwarp = ((warp & ~3) | 1) * order;
    const T helpA = sfacA[tid % (warp_size * 2)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 2)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 2)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 2)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    if (((warp & 7) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
      spartc[clwo + 3 * delta] = val3;
      spartc[clwo + 4 * delta] = val4;
      spartc[clwo + 5 * delta] = val5;
    }
  }

  __syncthreads();
  if ((warp & 4) != 0) {
    const int cwarp = ((warp & ~7) | 3) * order;
    const T helpA = sfacA[tid % (warp_size * 4)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 4)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 4)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 4)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    if (((warp & 15) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
      spartc[clwo + 3 * delta] = val3;
      spartc[clwo + 4 * delta] = val4;
      spartc[clwo + 5 * delta] = val5;
    }
  }

  __syncthreads();
  if ((warp & 8) != 0) {
    const int cwarp = ((warp & ~15) | 7) * order;
    const T helpA = sfacA[tid % (warp_size * 8)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 8)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 8)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 8)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    if ((warp == 15) && (clane >= 0)) {
      spartc[clane + (15 * order + 0 * delta)] = val0;
      spartc[clane + (15 * order + 1 * delta)] = val1;
      spartc[clane + (15 * order + 2 * delta)] = val2;
      spartc[clane + (15 * order + 3 * delta)] = val3;
      spartc[clane + (15 * order + 4 * delta)] = val4;
      spartc[clane + (15 * order + 5 * delta)] = val5;
    }
  }

  __syncthreads();
  if ((warp & 16) != 0) {
    const int cwarp = 15 * order;
    const T helpA = sfacA[tid % (warp_size * 16)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 16)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 16)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 16)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    if ((warp == 31) && (clane >= 0)) {
      spartc[clane + (31 * order + 0 * delta)] = val0;
      spartc[clane + (31 * order + 2 * delta)] = val2;
      spartc[clane + (31 * order + 4 * delta)] = val4;
    }
  }

  __syncthreads();
 if (warp < 17) {
  val1 += sfacA[tid] * spartc[31 * order + (0 * delta + 0)];
  val3 += sfacA[tid] * spartc[31 * order + (2 * delta + 0)];
  val5 += sfacA[tid] * spartc[31 * order + (4 * delta + 0)];
  val1 += sfacB[tid] * spartc[31 * order + (0 * delta + 1)];
  val3 += sfacB[tid] * spartc[31 * order + (2 * delta + 1)];
  val5 += sfacB[tid] * spartc[31 * order + (4 * delta + 1)];
  val1 += sfacC[tid] * spartc[31 * order + (0 * delta + 2)];
  val3 += sfacC[tid] * spartc[31 * order + (2 * delta + 2)];
  val5 += sfacC[tid] * spartc[31 * order + (4 * delta + 2)];
  val1 += sfacD[tid] * spartc[31 * order + (0 * delta + 3)];
  val3 += sfacD[tid] * spartc[31 * order + (2 * delta + 3)];
  val5 += sfacD[tid] * spartc[31 * order + (4 * delta + 3)];
 }
  if ((warp == 31) && (clane >= 0)) {
    spartc[clane + (31 * order + 1 * delta)] = val1;
    spartc[clane + (31 * order + 5 * delta)] = val5;
  }

  __syncthreads();
 if (warp < 17) {
  val2 += sfacA[tid] * spartc[31 * order + (1 * delta + 0)];
  val2 += sfacB[tid] * spartc[31 * order + (1 * delta + 1)];
  val2 += sfacC[tid] * spartc[31 * order + (1 * delta + 2)];
  val2 += sfacD[tid] * spartc[31 * order + (1 * delta + 3)];
 }
  if ((warp == 31) && (clane >= 0)) {
    spartc[clane + (31 * order + 3 * delta)] = val3;
  }

  __syncthreads();
 if (warp < 17) {
  val4 += sfacA[tid] * spartc[31 * order + (3 * delta + 0)];
  val4 += sfacB[tid] * spartc[31 * order + (3 * delta + 1)];
  val4 += sfacC[tid] * spartc[31 * order + (3 * delta + 2)];
  val4 += sfacD[tid] * spartc[31 * order + (3 * delta + 3)];
 }

  const int idx = tid - (block_size - order);
  if (idx >= 0) {
    fullcarry[chunk_id * order + idx] = val5;
    __threadfence();
    if (idx == 0) {
      status[chunk_id] = 2;
    }
  }

  if (chunk_id > 0) {
    __syncthreads();
    if (warp == 0) {
      const int cidm1 = chunk_id - 1;
      int flag = 1;
      do {
        if ((cidm1 - lane) >= 0) {
          flag = status[cidm1 - lane];
        }
      } while ((__any(flag == 0)) || (__all(flag != 2)));
      int mask = __ballot(flag == 2);
      const int pos = __ffs(mask) - 1;
      T fc;
      if (lane < order) {
        fc = fullcarry[(cidm1 - pos) * order + lane];
      }
      T X0 = __shfl(fc, 0);
      T X1 = __shfl(fc, 1);
      T X2 = __shfl(fc, 2);
      T X3 = __shfl(fc, 3);
      if (lane == 0) {
        sfullc[0] = X0;
        sfullc[1] = X1;
        sfullc[2] = X2;
        sfullc[3] = X3;
      }
    }

    __syncthreads();
    T X0 = sfullc[0];
    val0 += sfacA[tid] * X0;
    T X1 = sfullc[1];
    val0 += sfacB[tid] * X1;
    T X2 = sfullc[2];
    val0 += sfacC[tid] * X2;
    T X3 = sfullc[3];
    val0 += sfacD[tid] * X3;
  }

  if (chunk_id == gridDim.x - 1) {
    if (offs + (0 * block_size) < items) output[offs + (0 * block_size)] = val0;
    if (offs + (1 * block_size) < items) output[offs + (1 * block_size)] = val1;
    if (offs + (2 * block_size) < items) output[offs + (2 * block_size)] = val2;
    if (offs + (3 * block_size) < items) output[offs + (3 * block_size)] = val3;
    if (offs + (4 * block_size) < items) output[offs + (4 * block_size)] = val4;
    if (offs + (5 * block_size) < items) output[offs + (5 * block_size)] = val5;
  } else {
    output[offs + (0 * block_size)] = val0;
    output[offs + (1 * block_size)] = val1;
    output[offs + (2 * block_size)] = val2;
    output[offs + (3 * block_size)] = val3;
    output[offs + (4 * block_size)] = val4;
    output[offs + (5 * block_size)] = val5;
  }
}

static __global__ __launch_bounds__(block_size, 2)
void Recurrence7(const int items, const T* const __restrict__ input, T* const __restrict__ output, volatile int* const __restrict__ status, volatile T* const __restrict__ partcarry, volatile T* const __restrict__ fullcarry)
{
  const int valsperthread = 7;
  const int chunk_size = valsperthread * block_size;
  __shared__ T spartc[chunk_size / warp_size * order];
  __shared__ T sfullc[order];
  __shared__ int cid;

  const int tid = threadIdx.x;
  const int warp = tid / warp_size;
  const int lane = tid % warp_size;

  __shared__ T sfacA[block_size];
  __shared__ T sfacB[block_size];
  __shared__ T sfacC[block_size];
  __shared__ T sfacD[block_size];
  if (tid < 511) sfacA[tid] = facA[tid];
  else sfacA[tid] = 0;
  if (tid < 512) sfacB[tid] = facB[tid];
  else sfacB[tid] = 0;
  if (tid < 513) sfacC[tid] = facC[tid];
  else sfacC[tid] = 0;
  if (tid < 514) sfacD[tid] = facD[tid];
  else sfacD[tid] = 0;

  if (tid == 0) {
    cid = atomicInc(&counter, gridDim.x - 1);
  }

  __syncthreads();
  const int chunk_id = cid;
  const int offs = tid + chunk_id * chunk_size;

  T val0, val1, val2, val3, val4, val5, val6;
  if (chunk_id == gridDim.x - 1) {
    val0 = 0;
    if (offs + (0 * block_size) < items) val0 = input[offs + (0 * block_size)];
    val1 = 0;
    if (offs + (1 * block_size) < items) val1 = input[offs + (1 * block_size)];
    val2 = 0;
    if (offs + (2 * block_size) < items) val2 = input[offs + (2 * block_size)];
    val3 = 0;
    if (offs + (3 * block_size) < items) val3 = input[offs + (3 * block_size)];
    val4 = 0;
    if (offs + (4 * block_size) < items) val4 = input[offs + (4 * block_size)];
    val5 = 0;
    if (offs + (5 * block_size) < items) val5 = input[offs + (5 * block_size)];
    val6 = 0;
    if (offs + (6 * block_size) < items) val6 = input[offs + (6 * block_size)];
  } else {
    val0 = input[offs + (0 * block_size)];
    val1 = input[offs + (1 * block_size)];
    val2 = input[offs + (2 * block_size)];
    val3 = input[offs + (3 * block_size)];
    val4 = input[offs + (4 * block_size)];
    val5 = input[offs + (5 * block_size)];
    val6 = input[offs + (6 * block_size)];
  }

  val0 *= 2.366700e-01f;
  val1 *= 2.366700e-01f;
  val2 *= 2.366700e-01f;
  val3 *= 2.366700e-01f;
  val4 *= 2.366700e-01f;
  val5 *= 2.366700e-01f;
  val6 *= 2.366700e-01f;

  const T sfA = sfacA[lane];
  const T sfB = sfacB[lane];
  const T sfC = sfacC[lane];
  const T sfD = sfacD[lane];

  int cond;
  T help, spc;

  help = -9.840000e-03f;
  cond = ((lane & 1) != 0);
  spc = help * __shfl(val0, 0, 2);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 2);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 2);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 0, 2);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 0, 2);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 0, 2);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 0, 2);
  if (cond) val6 += spc;

  help = __shfl(sfC, lane % 2);
  cond = ((lane & 2) != 0);
  spc = help * __shfl(val0, 0, 4);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 4);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 4);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 0, 4);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 0, 4);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 0, 4);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 0, 4);
  if (cond) val6 += spc;

  help = __shfl(sfD, lane % 2);
  cond = ((lane & 2) != 0);
  spc = help * __shfl(val0, 1, 4);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 1, 4);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 1, 4);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 1, 4);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 1, 4);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 1, 4);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 1, 4);
  if (cond) val6 += spc;

  help = __shfl(sfA, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 0, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 0, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 0, 8);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 0, 8);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 0, 8);
  if (cond) val6 += spc;

  help = __shfl(sfB, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 1, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 1, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 1, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 1, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 1, 8);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 1, 8);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 1, 8);
  if (cond) val6 += spc;

  help = __shfl(sfC, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 2, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 2, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 2, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 2, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 2, 8);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 2, 8);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 2, 8);
  if (cond) val6 += spc;

  help = __shfl(sfD, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 3, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 3, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 3, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 3, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 3, 8);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 3, 8);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 3, 8);
  if (cond) val6 += spc;

  help = __shfl(sfA, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 4, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 4, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 4, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 4, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 4, 16);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 4, 16);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 4, 16);
  if (cond) val6 += spc;

  help = __shfl(sfB, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 5, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 5, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 5, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 5, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 5, 16);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 5, 16);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 5, 16);
  if (cond) val6 += spc;

  help = __shfl(sfC, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 6, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 6, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 6, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 6, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 6, 16);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 6, 16);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 6, 16);
  if (cond) val6 += spc;

  help = __shfl(sfD, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 7, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 7, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 7, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 7, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 7, 16);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 7, 16);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 7, 16);
  if (cond) val6 += spc;

  help = __shfl(sfA, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 12, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 12, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 12, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 12, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 12, 32);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 12, 32);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 12, 32);
  if (cond) val6 += spc;

  help = __shfl(sfB, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 13, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 13, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 13, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 13, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 13, 32);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 13, 32);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 13, 32);
  if (cond) val6 += spc;

  help = __shfl(sfC, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 14, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 14, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 14, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 14, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 14, 32);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 14, 32);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 14, 32);
  if (cond) val6 += spc;

  help = __shfl(sfD, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 15, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 15, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 15, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 15, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 15, 32);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 15, 32);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 15, 32);
  if (cond) val6 += spc;

  const int delta = block_size / warp_size * order;
  const int clane = lane - (warp_size - order);
  const int clwo = clane + warp * order;

  if (((warp & 1) == 0) && (clane >= 0)) {
    spartc[clwo + 0 * delta] = val0;
    spartc[clwo + 1 * delta] = val1;
    spartc[clwo + 2 * delta] = val2;
    spartc[clwo + 3 * delta] = val3;
    spartc[clwo + 4 * delta] = val4;
    spartc[clwo + 5 * delta] = val5;
    spartc[clwo + 6 * delta] = val6;
  }

  __syncthreads();
  if ((warp & 1) != 0) {
    const int cwarp = ((warp & ~1) | 0) * order;
    const T helpA = sfacA[tid % (warp_size * 1)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    val6 += helpA * spartc[cwarp + (6 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 1)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    val6 += helpB * spartc[cwarp + (6 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 1)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    val6 += helpC * spartc[cwarp + (6 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 1)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    val6 += helpD * spartc[cwarp + (6 * delta + 3)];
    if (((warp & 3) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
      spartc[clwo + 3 * delta] = val3;
      spartc[clwo + 4 * delta] = val4;
      spartc[clwo + 5 * delta] = val5;
      spartc[clwo + 6 * delta] = val6;
    }
  }

  __syncthreads();
  if ((warp & 2) != 0) {
    const int cwarp = ((warp & ~3) | 1) * order;
    const T helpA = sfacA[tid % (warp_size * 2)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    val6 += helpA * spartc[cwarp + (6 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 2)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    val6 += helpB * spartc[cwarp + (6 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 2)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    val6 += helpC * spartc[cwarp + (6 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 2)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    val6 += helpD * spartc[cwarp + (6 * delta + 3)];
    if (((warp & 7) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
      spartc[clwo + 3 * delta] = val3;
      spartc[clwo + 4 * delta] = val4;
      spartc[clwo + 5 * delta] = val5;
      spartc[clwo + 6 * delta] = val6;
    }
  }

  __syncthreads();
  if ((warp & 4) != 0) {
    const int cwarp = ((warp & ~7) | 3) * order;
    const T helpA = sfacA[tid % (warp_size * 4)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    val6 += helpA * spartc[cwarp + (6 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 4)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    val6 += helpB * spartc[cwarp + (6 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 4)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    val6 += helpC * spartc[cwarp + (6 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 4)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    val6 += helpD * spartc[cwarp + (6 * delta + 3)];
    if (((warp & 15) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
      spartc[clwo + 3 * delta] = val3;
      spartc[clwo + 4 * delta] = val4;
      spartc[clwo + 5 * delta] = val5;
      spartc[clwo + 6 * delta] = val6;
    }
  }

  __syncthreads();
  if ((warp & 8) != 0) {
    const int cwarp = ((warp & ~15) | 7) * order;
    const T helpA = sfacA[tid % (warp_size * 8)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    val6 += helpA * spartc[cwarp + (6 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 8)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    val6 += helpB * spartc[cwarp + (6 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 8)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    val6 += helpC * spartc[cwarp + (6 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 8)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    val6 += helpD * spartc[cwarp + (6 * delta + 3)];
    if ((warp == 15) && (clane >= 0)) {
      spartc[clane + (15 * order + 0 * delta)] = val0;
      spartc[clane + (15 * order + 1 * delta)] = val1;
      spartc[clane + (15 * order + 2 * delta)] = val2;
      spartc[clane + (15 * order + 3 * delta)] = val3;
      spartc[clane + (15 * order + 4 * delta)] = val4;
      spartc[clane + (15 * order + 5 * delta)] = val5;
      spartc[clane + (15 * order + 6 * delta)] = val6;
    }
  }

  __syncthreads();
  if ((warp & 16) != 0) {
    const int cwarp = 15 * order;
    const T helpA = sfacA[tid % (warp_size * 16)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    val6 += helpA * spartc[cwarp + (6 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 16)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    val6 += helpB * spartc[cwarp + (6 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 16)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    val6 += helpC * spartc[cwarp + (6 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 16)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    val6 += helpD * spartc[cwarp + (6 * delta + 3)];
    if ((warp == 31) && (clane >= 0)) {
      spartc[clane + (31 * order + 0 * delta)] = val0;
      spartc[clane + (31 * order + 2 * delta)] = val2;
      spartc[clane + (31 * order + 4 * delta)] = val4;
      spartc[clane + (31 * order + 6 * delta)] = val6;
    }
  }

  __syncthreads();
 if (warp < 17) {
  val1 += sfacA[tid] * spartc[31 * order + (0 * delta + 0)];
  val3 += sfacA[tid] * spartc[31 * order + (2 * delta + 0)];
  val5 += sfacA[tid] * spartc[31 * order + (4 * delta + 0)];
  val1 += sfacB[tid] * spartc[31 * order + (0 * delta + 1)];
  val3 += sfacB[tid] * spartc[31 * order + (2 * delta + 1)];
  val5 += sfacB[tid] * spartc[31 * order + (4 * delta + 1)];
  val1 += sfacC[tid] * spartc[31 * order + (0 * delta + 2)];
  val3 += sfacC[tid] * spartc[31 * order + (2 * delta + 2)];
  val5 += sfacC[tid] * spartc[31 * order + (4 * delta + 2)];
  val1 += sfacD[tid] * spartc[31 * order + (0 * delta + 3)];
  val3 += sfacD[tid] * spartc[31 * order + (2 * delta + 3)];
  val5 += sfacD[tid] * spartc[31 * order + (4 * delta + 3)];
 }
  if ((warp == 31) && (clane >= 0)) {
    spartc[clane + (31 * order + 1 * delta)] = val1;
    spartc[clane + (31 * order + 5 * delta)] = val5;
  }

  __syncthreads();
 if (warp < 17) {
  val2 += sfacA[tid] * spartc[31 * order + (1 * delta + 0)];
  val6 += sfacA[tid] * spartc[31 * order + (5 * delta + 0)];
  val2 += sfacB[tid] * spartc[31 * order + (1 * delta + 1)];
  val6 += sfacB[tid] * spartc[31 * order + (5 * delta + 1)];
  val2 += sfacC[tid] * spartc[31 * order + (1 * delta + 2)];
  val6 += sfacC[tid] * spartc[31 * order + (5 * delta + 2)];
  val2 += sfacD[tid] * spartc[31 * order + (1 * delta + 3)];
  val6 += sfacD[tid] * spartc[31 * order + (5 * delta + 3)];
 }
  if ((warp == 31) && (clane >= 0)) {
    spartc[clane + (31 * order + 3 * delta)] = val3;
  }

  __syncthreads();
 if (warp < 17) {
  val4 += sfacA[tid] * spartc[31 * order + (3 * delta + 0)];
  val4 += sfacB[tid] * spartc[31 * order + (3 * delta + 1)];
  val4 += sfacC[tid] * spartc[31 * order + (3 * delta + 2)];
  val4 += sfacD[tid] * spartc[31 * order + (3 * delta + 3)];
 }

  const int idx = tid - (block_size - order);
  if (idx >= 0) {
    fullcarry[chunk_id * order + idx] = val6;
    __threadfence();
    if (idx == 0) {
      status[chunk_id] = 2;
    }
  }

  if (chunk_id > 0) {
    __syncthreads();
    if (warp == 0) {
      const int cidm1 = chunk_id - 1;
      int flag = 1;
      do {
        if ((cidm1 - lane) >= 0) {
          flag = status[cidm1 - lane];
        }
      } while ((__any(flag == 0)) || (__all(flag != 2)));
      int mask = __ballot(flag == 2);
      const int pos = __ffs(mask) - 1;
      T fc;
      if (lane < order) {
        fc = fullcarry[(cidm1 - pos) * order + lane];
      }
      T X0 = __shfl(fc, 0);
      T X1 = __shfl(fc, 1);
      T X2 = __shfl(fc, 2);
      T X3 = __shfl(fc, 3);
      if (lane == 0) {
        sfullc[0] = X0;
        sfullc[1] = X1;
        sfullc[2] = X2;
        sfullc[3] = X3;
      }
    }

    __syncthreads();
    T X0 = sfullc[0];
    val0 += sfacA[tid] * X0;
    T X1 = sfullc[1];
    val0 += sfacB[tid] * X1;
    T X2 = sfullc[2];
    val0 += sfacC[tid] * X2;
    T X3 = sfullc[3];
    val0 += sfacD[tid] * X3;
  }

  if (chunk_id == gridDim.x - 1) {
    if (offs + (0 * block_size) < items) output[offs + (0 * block_size)] = val0;
    if (offs + (1 * block_size) < items) output[offs + (1 * block_size)] = val1;
    if (offs + (2 * block_size) < items) output[offs + (2 * block_size)] = val2;
    if (offs + (3 * block_size) < items) output[offs + (3 * block_size)] = val3;
    if (offs + (4 * block_size) < items) output[offs + (4 * block_size)] = val4;
    if (offs + (5 * block_size) < items) output[offs + (5 * block_size)] = val5;
    if (offs + (6 * block_size) < items) output[offs + (6 * block_size)] = val6;
  } else {
    output[offs + (0 * block_size)] = val0;
    output[offs + (1 * block_size)] = val1;
    output[offs + (2 * block_size)] = val2;
    output[offs + (3 * block_size)] = val3;
    output[offs + (4 * block_size)] = val4;
    output[offs + (5 * block_size)] = val5;
    output[offs + (6 * block_size)] = val6;
  }
}

static __global__ __launch_bounds__(block_size, 2)
void Recurrence8(const int items, const T* const __restrict__ input, T* const __restrict__ output, volatile int* const __restrict__ status, volatile T* const __restrict__ partcarry, volatile T* const __restrict__ fullcarry)
{
  const int valsperthread = 8;
  const int chunk_size = valsperthread * block_size;
  __shared__ T spartc[chunk_size / warp_size * order];
  __shared__ T sfullc[order];
  __shared__ int cid;

  const int tid = threadIdx.x;
  const int warp = tid / warp_size;
  const int lane = tid % warp_size;

  __shared__ T sfacA[block_size];
  __shared__ T sfacB[block_size];
  __shared__ T sfacC[block_size];
  __shared__ T sfacD[block_size];
  if (tid < 511) sfacA[tid] = facA[tid];
  else sfacA[tid] = 0;
  if (tid < 512) sfacB[tid] = facB[tid];
  else sfacB[tid] = 0;
  if (tid < 513) sfacC[tid] = facC[tid];
  else sfacC[tid] = 0;
  if (tid < 514) sfacD[tid] = facD[tid];
  else sfacD[tid] = 0;

  if (tid == 0) {
    cid = atomicInc(&counter, gridDim.x - 1);
  }

  __syncthreads();
  const int chunk_id = cid;
  const int offs = tid + chunk_id * chunk_size;

  T val0, val1, val2, val3, val4, val5, val6, val7;
  if (chunk_id == gridDim.x - 1) {
    val0 = 0;
    if (offs + (0 * block_size) < items) val0 = input[offs + (0 * block_size)];
    val1 = 0;
    if (offs + (1 * block_size) < items) val1 = input[offs + (1 * block_size)];
    val2 = 0;
    if (offs + (2 * block_size) < items) val2 = input[offs + (2 * block_size)];
    val3 = 0;
    if (offs + (3 * block_size) < items) val3 = input[offs + (3 * block_size)];
    val4 = 0;
    if (offs + (4 * block_size) < items) val4 = input[offs + (4 * block_size)];
    val5 = 0;
    if (offs + (5 * block_size) < items) val5 = input[offs + (5 * block_size)];
    val6 = 0;
    if (offs + (6 * block_size) < items) val6 = input[offs + (6 * block_size)];
    val7 = 0;
    if (offs + (7 * block_size) < items) val7 = input[offs + (7 * block_size)];
  } else {
    val0 = input[offs + (0 * block_size)];
    val1 = input[offs + (1 * block_size)];
    val2 = input[offs + (2 * block_size)];
    val3 = input[offs + (3 * block_size)];
    val4 = input[offs + (4 * block_size)];
    val5 = input[offs + (5 * block_size)];
    val6 = input[offs + (6 * block_size)];
    val7 = input[offs + (7 * block_size)];
  }

  val0 *= 2.366700e-01f;
  val1 *= 2.366700e-01f;
  val2 *= 2.366700e-01f;
  val3 *= 2.366700e-01f;
  val4 *= 2.366700e-01f;
  val5 *= 2.366700e-01f;
  val6 *= 2.366700e-01f;
  val7 *= 2.366700e-01f;

  const T sfA = sfacA[lane];
  const T sfB = sfacB[lane];
  const T sfC = sfacC[lane];
  const T sfD = sfacD[lane];

  int cond;
  T help, spc;

  help = -9.840000e-03f;
  cond = ((lane & 1) != 0);
  spc = help * __shfl(val0, 0, 2);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 2);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 2);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 0, 2);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 0, 2);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 0, 2);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 0, 2);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 0, 2);
  if (cond) val7 += spc;

  help = __shfl(sfC, lane % 2);
  cond = ((lane & 2) != 0);
  spc = help * __shfl(val0, 0, 4);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 4);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 4);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 0, 4);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 0, 4);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 0, 4);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 0, 4);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 0, 4);
  if (cond) val7 += spc;

  help = __shfl(sfD, lane % 2);
  cond = ((lane & 2) != 0);
  spc = help * __shfl(val0, 1, 4);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 1, 4);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 1, 4);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 1, 4);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 1, 4);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 1, 4);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 1, 4);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 1, 4);
  if (cond) val7 += spc;

  help = __shfl(sfA, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 0, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 0, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 0, 8);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 0, 8);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 0, 8);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 0, 8);
  if (cond) val7 += spc;

  help = __shfl(sfB, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 1, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 1, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 1, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 1, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 1, 8);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 1, 8);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 1, 8);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 1, 8);
  if (cond) val7 += spc;

  help = __shfl(sfC, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 2, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 2, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 2, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 2, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 2, 8);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 2, 8);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 2, 8);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 2, 8);
  if (cond) val7 += spc;

  help = __shfl(sfD, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 3, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 3, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 3, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 3, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 3, 8);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 3, 8);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 3, 8);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 3, 8);
  if (cond) val7 += spc;

  help = __shfl(sfA, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 4, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 4, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 4, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 4, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 4, 16);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 4, 16);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 4, 16);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 4, 16);
  if (cond) val7 += spc;

  help = __shfl(sfB, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 5, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 5, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 5, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 5, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 5, 16);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 5, 16);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 5, 16);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 5, 16);
  if (cond) val7 += spc;

  help = __shfl(sfC, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 6, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 6, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 6, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 6, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 6, 16);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 6, 16);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 6, 16);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 6, 16);
  if (cond) val7 += spc;

  help = __shfl(sfD, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 7, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 7, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 7, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 7, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 7, 16);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 7, 16);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 7, 16);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 7, 16);
  if (cond) val7 += spc;

  help = __shfl(sfA, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 12, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 12, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 12, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 12, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 12, 32);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 12, 32);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 12, 32);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 12, 32);
  if (cond) val7 += spc;

  help = __shfl(sfB, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 13, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 13, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 13, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 13, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 13, 32);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 13, 32);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 13, 32);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 13, 32);
  if (cond) val7 += spc;

  help = __shfl(sfC, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 14, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 14, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 14, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 14, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 14, 32);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 14, 32);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 14, 32);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 14, 32);
  if (cond) val7 += spc;

  help = __shfl(sfD, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 15, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 15, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 15, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 15, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 15, 32);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 15, 32);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 15, 32);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 15, 32);
  if (cond) val7 += spc;

  const int delta = block_size / warp_size * order;
  const int clane = lane - (warp_size - order);
  const int clwo = clane + warp * order;

  if (((warp & 1) == 0) && (clane >= 0)) {
    spartc[clwo + 0 * delta] = val0;
    spartc[clwo + 1 * delta] = val1;
    spartc[clwo + 2 * delta] = val2;
    spartc[clwo + 3 * delta] = val3;
    spartc[clwo + 4 * delta] = val4;
    spartc[clwo + 5 * delta] = val5;
    spartc[clwo + 6 * delta] = val6;
    spartc[clwo + 7 * delta] = val7;
  }

  __syncthreads();
  if ((warp & 1) != 0) {
    const int cwarp = ((warp & ~1) | 0) * order;
    const T helpA = sfacA[tid % (warp_size * 1)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    val6 += helpA * spartc[cwarp + (6 * delta + 0)];
    val7 += helpA * spartc[cwarp + (7 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 1)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    val6 += helpB * spartc[cwarp + (6 * delta + 1)];
    val7 += helpB * spartc[cwarp + (7 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 1)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    val6 += helpC * spartc[cwarp + (6 * delta + 2)];
    val7 += helpC * spartc[cwarp + (7 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 1)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    val6 += helpD * spartc[cwarp + (6 * delta + 3)];
    val7 += helpD * spartc[cwarp + (7 * delta + 3)];
    if (((warp & 3) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
      spartc[clwo + 3 * delta] = val3;
      spartc[clwo + 4 * delta] = val4;
      spartc[clwo + 5 * delta] = val5;
      spartc[clwo + 6 * delta] = val6;
      spartc[clwo + 7 * delta] = val7;
    }
  }

  __syncthreads();
  if ((warp & 2) != 0) {
    const int cwarp = ((warp & ~3) | 1) * order;
    const T helpA = sfacA[tid % (warp_size * 2)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    val6 += helpA * spartc[cwarp + (6 * delta + 0)];
    val7 += helpA * spartc[cwarp + (7 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 2)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    val6 += helpB * spartc[cwarp + (6 * delta + 1)];
    val7 += helpB * spartc[cwarp + (7 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 2)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    val6 += helpC * spartc[cwarp + (6 * delta + 2)];
    val7 += helpC * spartc[cwarp + (7 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 2)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    val6 += helpD * spartc[cwarp + (6 * delta + 3)];
    val7 += helpD * spartc[cwarp + (7 * delta + 3)];
    if (((warp & 7) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
      spartc[clwo + 3 * delta] = val3;
      spartc[clwo + 4 * delta] = val4;
      spartc[clwo + 5 * delta] = val5;
      spartc[clwo + 6 * delta] = val6;
      spartc[clwo + 7 * delta] = val7;
    }
  }

  __syncthreads();
  if ((warp & 4) != 0) {
    const int cwarp = ((warp & ~7) | 3) * order;
    const T helpA = sfacA[tid % (warp_size * 4)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    val6 += helpA * spartc[cwarp + (6 * delta + 0)];
    val7 += helpA * spartc[cwarp + (7 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 4)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    val6 += helpB * spartc[cwarp + (6 * delta + 1)];
    val7 += helpB * spartc[cwarp + (7 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 4)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    val6 += helpC * spartc[cwarp + (6 * delta + 2)];
    val7 += helpC * spartc[cwarp + (7 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 4)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    val6 += helpD * spartc[cwarp + (6 * delta + 3)];
    val7 += helpD * spartc[cwarp + (7 * delta + 3)];
    if (((warp & 15) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
      spartc[clwo + 3 * delta] = val3;
      spartc[clwo + 4 * delta] = val4;
      spartc[clwo + 5 * delta] = val5;
      spartc[clwo + 6 * delta] = val6;
      spartc[clwo + 7 * delta] = val7;
    }
  }

  __syncthreads();
  if ((warp & 8) != 0) {
    const int cwarp = ((warp & ~15) | 7) * order;
    const T helpA = sfacA[tid % (warp_size * 8)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    val6 += helpA * spartc[cwarp + (6 * delta + 0)];
    val7 += helpA * spartc[cwarp + (7 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 8)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    val6 += helpB * spartc[cwarp + (6 * delta + 1)];
    val7 += helpB * spartc[cwarp + (7 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 8)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    val6 += helpC * spartc[cwarp + (6 * delta + 2)];
    val7 += helpC * spartc[cwarp + (7 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 8)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    val6 += helpD * spartc[cwarp + (6 * delta + 3)];
    val7 += helpD * spartc[cwarp + (7 * delta + 3)];
    if ((warp == 15) && (clane >= 0)) {
      spartc[clane + (15 * order + 0 * delta)] = val0;
      spartc[clane + (15 * order + 1 * delta)] = val1;
      spartc[clane + (15 * order + 2 * delta)] = val2;
      spartc[clane + (15 * order + 3 * delta)] = val3;
      spartc[clane + (15 * order + 4 * delta)] = val4;
      spartc[clane + (15 * order + 5 * delta)] = val5;
      spartc[clane + (15 * order + 6 * delta)] = val6;
      spartc[clane + (15 * order + 7 * delta)] = val7;
    }
  }

  __syncthreads();
  if ((warp & 16) != 0) {
    const int cwarp = 15 * order;
    const T helpA = sfacA[tid % (warp_size * 16)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    val6 += helpA * spartc[cwarp + (6 * delta + 0)];
    val7 += helpA * spartc[cwarp + (7 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 16)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    val6 += helpB * spartc[cwarp + (6 * delta + 1)];
    val7 += helpB * spartc[cwarp + (7 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 16)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    val6 += helpC * spartc[cwarp + (6 * delta + 2)];
    val7 += helpC * spartc[cwarp + (7 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 16)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    val6 += helpD * spartc[cwarp + (6 * delta + 3)];
    val7 += helpD * spartc[cwarp + (7 * delta + 3)];
    if ((warp == 31) && (clane >= 0)) {
      spartc[clane + (31 * order + 0 * delta)] = val0;
      spartc[clane + (31 * order + 2 * delta)] = val2;
      spartc[clane + (31 * order + 4 * delta)] = val4;
      spartc[clane + (31 * order + 6 * delta)] = val6;
    }
  }

  __syncthreads();
 if (warp < 17) {
  val1 += sfacA[tid] * spartc[31 * order + (0 * delta + 0)];
  val3 += sfacA[tid] * spartc[31 * order + (2 * delta + 0)];
  val5 += sfacA[tid] * spartc[31 * order + (4 * delta + 0)];
  val7 += sfacA[tid] * spartc[31 * order + (6 * delta + 0)];
  val1 += sfacB[tid] * spartc[31 * order + (0 * delta + 1)];
  val3 += sfacB[tid] * spartc[31 * order + (2 * delta + 1)];
  val5 += sfacB[tid] * spartc[31 * order + (4 * delta + 1)];
  val7 += sfacB[tid] * spartc[31 * order + (6 * delta + 1)];
  val1 += sfacC[tid] * spartc[31 * order + (0 * delta + 2)];
  val3 += sfacC[tid] * spartc[31 * order + (2 * delta + 2)];
  val5 += sfacC[tid] * spartc[31 * order + (4 * delta + 2)];
  val7 += sfacC[tid] * spartc[31 * order + (6 * delta + 2)];
  val1 += sfacD[tid] * spartc[31 * order + (0 * delta + 3)];
  val3 += sfacD[tid] * spartc[31 * order + (2 * delta + 3)];
  val5 += sfacD[tid] * spartc[31 * order + (4 * delta + 3)];
  val7 += sfacD[tid] * spartc[31 * order + (6 * delta + 3)];
 }
  if ((warp == 31) && (clane >= 0)) {
    spartc[clane + (31 * order + 1 * delta)] = val1;
    spartc[clane + (31 * order + 5 * delta)] = val5;
  }

  __syncthreads();
 if (warp < 17) {
  val2 += sfacA[tid] * spartc[31 * order + (1 * delta + 0)];
  val6 += sfacA[tid] * spartc[31 * order + (5 * delta + 0)];
  val2 += sfacB[tid] * spartc[31 * order + (1 * delta + 1)];
  val6 += sfacB[tid] * spartc[31 * order + (5 * delta + 1)];
  val2 += sfacC[tid] * spartc[31 * order + (1 * delta + 2)];
  val6 += sfacC[tid] * spartc[31 * order + (5 * delta + 2)];
  val2 += sfacD[tid] * spartc[31 * order + (1 * delta + 3)];
  val6 += sfacD[tid] * spartc[31 * order + (5 * delta + 3)];
 }
  if ((warp == 31) && (clane >= 0)) {
    spartc[clane + (31 * order + 3 * delta)] = val3;
  }

  __syncthreads();
 if (warp < 17) {
  val4 += sfacA[tid] * spartc[31 * order + (3 * delta + 0)];
  val4 += sfacB[tid] * spartc[31 * order + (3 * delta + 1)];
  val4 += sfacC[tid] * spartc[31 * order + (3 * delta + 2)];
  val4 += sfacD[tid] * spartc[31 * order + (3 * delta + 3)];
 }

  const int idx = tid - (block_size - order);
  if (idx >= 0) {
    fullcarry[chunk_id * order + idx] = val7;
    __threadfence();
    if (idx == 0) {
      status[chunk_id] = 2;
    }
  }

  if (chunk_id > 0) {
    __syncthreads();
    if (warp == 0) {
      const int cidm1 = chunk_id - 1;
      int flag = 1;
      do {
        if ((cidm1 - lane) >= 0) {
          flag = status[cidm1 - lane];
        }
      } while ((__any(flag == 0)) || (__all(flag != 2)));
      int mask = __ballot(flag == 2);
      const int pos = __ffs(mask) - 1;
      T fc;
      if (lane < order) {
        fc = fullcarry[(cidm1 - pos) * order + lane];
      }
      T X0 = __shfl(fc, 0);
      T X1 = __shfl(fc, 1);
      T X2 = __shfl(fc, 2);
      T X3 = __shfl(fc, 3);
      if (lane == 0) {
        sfullc[0] = X0;
        sfullc[1] = X1;
        sfullc[2] = X2;
        sfullc[3] = X3;
      }
    }

    __syncthreads();
    T X0 = sfullc[0];
    val0 += sfacA[tid] * X0;
    T X1 = sfullc[1];
    val0 += sfacB[tid] * X1;
    T X2 = sfullc[2];
    val0 += sfacC[tid] * X2;
    T X3 = sfullc[3];
    val0 += sfacD[tid] * X3;
  }

  if (chunk_id == gridDim.x - 1) {
    if (offs + (0 * block_size) < items) output[offs + (0 * block_size)] = val0;
    if (offs + (1 * block_size) < items) output[offs + (1 * block_size)] = val1;
    if (offs + (2 * block_size) < items) output[offs + (2 * block_size)] = val2;
    if (offs + (3 * block_size) < items) output[offs + (3 * block_size)] = val3;
    if (offs + (4 * block_size) < items) output[offs + (4 * block_size)] = val4;
    if (offs + (5 * block_size) < items) output[offs + (5 * block_size)] = val5;
    if (offs + (6 * block_size) < items) output[offs + (6 * block_size)] = val6;
    if (offs + (7 * block_size) < items) output[offs + (7 * block_size)] = val7;
  } else {
    output[offs + (0 * block_size)] = val0;
    output[offs + (1 * block_size)] = val1;
    output[offs + (2 * block_size)] = val2;
    output[offs + (3 * block_size)] = val3;
    output[offs + (4 * block_size)] = val4;
    output[offs + (5 * block_size)] = val5;
    output[offs + (6 * block_size)] = val6;
    output[offs + (7 * block_size)] = val7;
  }
}

static __global__ __launch_bounds__(block_size, 2)
void Recurrence9(const int items, const T* const __restrict__ input, T* const __restrict__ output, volatile int* const __restrict__ status, volatile T* const __restrict__ partcarry, volatile T* const __restrict__ fullcarry)
{
  const int valsperthread = 9;
  const int chunk_size = valsperthread * block_size;
  __shared__ T spartc[chunk_size / warp_size * order];
  __shared__ T sfullc[order];
  __shared__ int cid;

  const int tid = threadIdx.x;
  const int warp = tid / warp_size;
  const int lane = tid % warp_size;

  __shared__ T sfacA[block_size];
  __shared__ T sfacB[block_size];
  __shared__ T sfacC[block_size];
  __shared__ T sfacD[block_size];
  if (tid < 511) sfacA[tid] = facA[tid];
  else sfacA[tid] = 0;
  if (tid < 512) sfacB[tid] = facB[tid];
  else sfacB[tid] = 0;
  if (tid < 513) sfacC[tid] = facC[tid];
  else sfacC[tid] = 0;
  if (tid < 514) sfacD[tid] = facD[tid];
  else sfacD[tid] = 0;

  if (tid == 0) {
    cid = atomicInc(&counter, gridDim.x - 1);
  }

  __syncthreads();
  const int chunk_id = cid;
  const int offs = tid + chunk_id * chunk_size;

  T val0, val1, val2, val3, val4, val5, val6, val7, val8;
  if (chunk_id == gridDim.x - 1) {
    val0 = 0;
    if (offs + (0 * block_size) < items) val0 = input[offs + (0 * block_size)];
    val1 = 0;
    if (offs + (1 * block_size) < items) val1 = input[offs + (1 * block_size)];
    val2 = 0;
    if (offs + (2 * block_size) < items) val2 = input[offs + (2 * block_size)];
    val3 = 0;
    if (offs + (3 * block_size) < items) val3 = input[offs + (3 * block_size)];
    val4 = 0;
    if (offs + (4 * block_size) < items) val4 = input[offs + (4 * block_size)];
    val5 = 0;
    if (offs + (5 * block_size) < items) val5 = input[offs + (5 * block_size)];
    val6 = 0;
    if (offs + (6 * block_size) < items) val6 = input[offs + (6 * block_size)];
    val7 = 0;
    if (offs + (7 * block_size) < items) val7 = input[offs + (7 * block_size)];
    val8 = 0;
    if (offs + (8 * block_size) < items) val8 = input[offs + (8 * block_size)];
  } else {
    val0 = input[offs + (0 * block_size)];
    val1 = input[offs + (1 * block_size)];
    val2 = input[offs + (2 * block_size)];
    val3 = input[offs + (3 * block_size)];
    val4 = input[offs + (4 * block_size)];
    val5 = input[offs + (5 * block_size)];
    val6 = input[offs + (6 * block_size)];
    val7 = input[offs + (7 * block_size)];
    val8 = input[offs + (8 * block_size)];
  }

  val0 *= 2.366700e-01f;
  val1 *= 2.366700e-01f;
  val2 *= 2.366700e-01f;
  val3 *= 2.366700e-01f;
  val4 *= 2.366700e-01f;
  val5 *= 2.366700e-01f;
  val6 *= 2.366700e-01f;
  val7 *= 2.366700e-01f;
  val8 *= 2.366700e-01f;

  const T sfA = sfacA[lane];
  const T sfB = sfacB[lane];
  const T sfC = sfacC[lane];
  const T sfD = sfacD[lane];

  int cond;
  T help, spc;

  help = -9.840000e-03f;
  cond = ((lane & 1) != 0);
  spc = help * __shfl(val0, 0, 2);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 2);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 2);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 0, 2);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 0, 2);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 0, 2);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 0, 2);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 0, 2);
  if (cond) val7 += spc;
  spc = help * __shfl(val8, 0, 2);
  if (cond) val8 += spc;

  help = __shfl(sfC, lane % 2);
  cond = ((lane & 2) != 0);
  spc = help * __shfl(val0, 0, 4);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 4);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 4);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 0, 4);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 0, 4);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 0, 4);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 0, 4);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 0, 4);
  if (cond) val7 += spc;
  spc = help * __shfl(val8, 0, 4);
  if (cond) val8 += spc;

  help = __shfl(sfD, lane % 2);
  cond = ((lane & 2) != 0);
  spc = help * __shfl(val0, 1, 4);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 1, 4);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 1, 4);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 1, 4);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 1, 4);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 1, 4);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 1, 4);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 1, 4);
  if (cond) val7 += spc;
  spc = help * __shfl(val8, 1, 4);
  if (cond) val8 += spc;

  help = __shfl(sfA, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 0, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 0, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 0, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 0, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 0, 8);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 0, 8);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 0, 8);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 0, 8);
  if (cond) val7 += spc;
  spc = help * __shfl(val8, 0, 8);
  if (cond) val8 += spc;

  help = __shfl(sfB, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 1, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 1, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 1, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 1, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 1, 8);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 1, 8);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 1, 8);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 1, 8);
  if (cond) val7 += spc;
  spc = help * __shfl(val8, 1, 8);
  if (cond) val8 += spc;

  help = __shfl(sfC, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 2, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 2, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 2, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 2, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 2, 8);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 2, 8);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 2, 8);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 2, 8);
  if (cond) val7 += spc;
  spc = help * __shfl(val8, 2, 8);
  if (cond) val8 += spc;

  help = __shfl(sfD, lane % 4);
  cond = ((lane & 4) != 0);
  spc = help * __shfl(val0, 3, 8);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 3, 8);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 3, 8);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 3, 8);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 3, 8);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 3, 8);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 3, 8);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 3, 8);
  if (cond) val7 += spc;
  spc = help * __shfl(val8, 3, 8);
  if (cond) val8 += spc;

  help = __shfl(sfA, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 4, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 4, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 4, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 4, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 4, 16);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 4, 16);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 4, 16);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 4, 16);
  if (cond) val7 += spc;
  spc = help * __shfl(val8, 4, 16);
  if (cond) val8 += spc;

  help = __shfl(sfB, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 5, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 5, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 5, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 5, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 5, 16);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 5, 16);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 5, 16);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 5, 16);
  if (cond) val7 += spc;
  spc = help * __shfl(val8, 5, 16);
  if (cond) val8 += spc;

  help = __shfl(sfC, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 6, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 6, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 6, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 6, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 6, 16);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 6, 16);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 6, 16);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 6, 16);
  if (cond) val7 += spc;
  spc = help * __shfl(val8, 6, 16);
  if (cond) val8 += spc;

  help = __shfl(sfD, lane % 8);
  cond = ((lane & 8) != 0);
  spc = help * __shfl(val0, 7, 16);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 7, 16);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 7, 16);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 7, 16);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 7, 16);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 7, 16);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 7, 16);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 7, 16);
  if (cond) val7 += spc;
  spc = help * __shfl(val8, 7, 16);
  if (cond) val8 += spc;

  help = __shfl(sfA, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 12, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 12, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 12, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 12, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 12, 32);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 12, 32);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 12, 32);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 12, 32);
  if (cond) val7 += spc;
  spc = help * __shfl(val8, 12, 32);
  if (cond) val8 += spc;

  help = __shfl(sfB, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 13, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 13, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 13, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 13, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 13, 32);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 13, 32);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 13, 32);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 13, 32);
  if (cond) val7 += spc;
  spc = help * __shfl(val8, 13, 32);
  if (cond) val8 += spc;

  help = __shfl(sfC, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 14, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 14, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 14, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 14, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 14, 32);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 14, 32);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 14, 32);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 14, 32);
  if (cond) val7 += spc;
  spc = help * __shfl(val8, 14, 32);
  if (cond) val8 += spc;

  help = __shfl(sfD, lane % 16);
  cond = ((lane & 16) != 0);
  spc = help * __shfl(val0, 15, 32);
  if (cond) val0 += spc;
  spc = help * __shfl(val1, 15, 32);
  if (cond) val1 += spc;
  spc = help * __shfl(val2, 15, 32);
  if (cond) val2 += spc;
  spc = help * __shfl(val3, 15, 32);
  if (cond) val3 += spc;
  spc = help * __shfl(val4, 15, 32);
  if (cond) val4 += spc;
  spc = help * __shfl(val5, 15, 32);
  if (cond) val5 += spc;
  spc = help * __shfl(val6, 15, 32);
  if (cond) val6 += spc;
  spc = help * __shfl(val7, 15, 32);
  if (cond) val7 += spc;
  spc = help * __shfl(val8, 15, 32);
  if (cond) val8 += spc;

  const int delta = block_size / warp_size * order;
  const int clane = lane - (warp_size - order);
  const int clwo = clane + warp * order;

  if (((warp & 1) == 0) && (clane >= 0)) {
    spartc[clwo + 0 * delta] = val0;
    spartc[clwo + 1 * delta] = val1;
    spartc[clwo + 2 * delta] = val2;
    spartc[clwo + 3 * delta] = val3;
    spartc[clwo + 4 * delta] = val4;
    spartc[clwo + 5 * delta] = val5;
    spartc[clwo + 6 * delta] = val6;
    spartc[clwo + 7 * delta] = val7;
    spartc[clwo + 8 * delta] = val8;
  }

  __syncthreads();
  if ((warp & 1) != 0) {
    const int cwarp = ((warp & ~1) | 0) * order;
    const T helpA = sfacA[tid % (warp_size * 1)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    val6 += helpA * spartc[cwarp + (6 * delta + 0)];
    val7 += helpA * spartc[cwarp + (7 * delta + 0)];
    val8 += helpA * spartc[cwarp + (8 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 1)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    val6 += helpB * spartc[cwarp + (6 * delta + 1)];
    val7 += helpB * spartc[cwarp + (7 * delta + 1)];
    val8 += helpB * spartc[cwarp + (8 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 1)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    val6 += helpC * spartc[cwarp + (6 * delta + 2)];
    val7 += helpC * spartc[cwarp + (7 * delta + 2)];
    val8 += helpC * spartc[cwarp + (8 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 1)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    val6 += helpD * spartc[cwarp + (6 * delta + 3)];
    val7 += helpD * spartc[cwarp + (7 * delta + 3)];
    val8 += helpD * spartc[cwarp + (8 * delta + 3)];
    if (((warp & 3) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
      spartc[clwo + 3 * delta] = val3;
      spartc[clwo + 4 * delta] = val4;
      spartc[clwo + 5 * delta] = val5;
      spartc[clwo + 6 * delta] = val6;
      spartc[clwo + 7 * delta] = val7;
      spartc[clwo + 8 * delta] = val8;
    }
  }

  __syncthreads();
  if ((warp & 2) != 0) {
    const int cwarp = ((warp & ~3) | 1) * order;
    const T helpA = sfacA[tid % (warp_size * 2)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    val6 += helpA * spartc[cwarp + (6 * delta + 0)];
    val7 += helpA * spartc[cwarp + (7 * delta + 0)];
    val8 += helpA * spartc[cwarp + (8 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 2)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    val6 += helpB * spartc[cwarp + (6 * delta + 1)];
    val7 += helpB * spartc[cwarp + (7 * delta + 1)];
    val8 += helpB * spartc[cwarp + (8 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 2)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    val6 += helpC * spartc[cwarp + (6 * delta + 2)];
    val7 += helpC * spartc[cwarp + (7 * delta + 2)];
    val8 += helpC * spartc[cwarp + (8 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 2)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    val6 += helpD * spartc[cwarp + (6 * delta + 3)];
    val7 += helpD * spartc[cwarp + (7 * delta + 3)];
    val8 += helpD * spartc[cwarp + (8 * delta + 3)];
    if (((warp & 7) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
      spartc[clwo + 3 * delta] = val3;
      spartc[clwo + 4 * delta] = val4;
      spartc[clwo + 5 * delta] = val5;
      spartc[clwo + 6 * delta] = val6;
      spartc[clwo + 7 * delta] = val7;
      spartc[clwo + 8 * delta] = val8;
    }
  }

  __syncthreads();
  if ((warp & 4) != 0) {
    const int cwarp = ((warp & ~7) | 3) * order;
    const T helpA = sfacA[tid % (warp_size * 4)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    val6 += helpA * spartc[cwarp + (6 * delta + 0)];
    val7 += helpA * spartc[cwarp + (7 * delta + 0)];
    val8 += helpA * spartc[cwarp + (8 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 4)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    val6 += helpB * spartc[cwarp + (6 * delta + 1)];
    val7 += helpB * spartc[cwarp + (7 * delta + 1)];
    val8 += helpB * spartc[cwarp + (8 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 4)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    val6 += helpC * spartc[cwarp + (6 * delta + 2)];
    val7 += helpC * spartc[cwarp + (7 * delta + 2)];
    val8 += helpC * spartc[cwarp + (8 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 4)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    val6 += helpD * spartc[cwarp + (6 * delta + 3)];
    val7 += helpD * spartc[cwarp + (7 * delta + 3)];
    val8 += helpD * spartc[cwarp + (8 * delta + 3)];
    if (((warp & 15) != 0) && (clane >= 0)) {
      spartc[clwo + 0 * delta] = val0;
      spartc[clwo + 1 * delta] = val1;
      spartc[clwo + 2 * delta] = val2;
      spartc[clwo + 3 * delta] = val3;
      spartc[clwo + 4 * delta] = val4;
      spartc[clwo + 5 * delta] = val5;
      spartc[clwo + 6 * delta] = val6;
      spartc[clwo + 7 * delta] = val7;
      spartc[clwo + 8 * delta] = val8;
    }
  }

  __syncthreads();
  if ((warp & 8) != 0) {
    const int cwarp = ((warp & ~15) | 7) * order;
    const T helpA = sfacA[tid % (warp_size * 8)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    val6 += helpA * spartc[cwarp + (6 * delta + 0)];
    val7 += helpA * spartc[cwarp + (7 * delta + 0)];
    val8 += helpA * spartc[cwarp + (8 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 8)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    val6 += helpB * spartc[cwarp + (6 * delta + 1)];
    val7 += helpB * spartc[cwarp + (7 * delta + 1)];
    val8 += helpB * spartc[cwarp + (8 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 8)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    val6 += helpC * spartc[cwarp + (6 * delta + 2)];
    val7 += helpC * spartc[cwarp + (7 * delta + 2)];
    val8 += helpC * spartc[cwarp + (8 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 8)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    val6 += helpD * spartc[cwarp + (6 * delta + 3)];
    val7 += helpD * spartc[cwarp + (7 * delta + 3)];
    val8 += helpD * spartc[cwarp + (8 * delta + 3)];
    if ((warp == 15) && (clane >= 0)) {
      spartc[clane + (15 * order + 0 * delta)] = val0;
      spartc[clane + (15 * order + 1 * delta)] = val1;
      spartc[clane + (15 * order + 2 * delta)] = val2;
      spartc[clane + (15 * order + 3 * delta)] = val3;
      spartc[clane + (15 * order + 4 * delta)] = val4;
      spartc[clane + (15 * order + 5 * delta)] = val5;
      spartc[clane + (15 * order + 6 * delta)] = val6;
      spartc[clane + (15 * order + 7 * delta)] = val7;
      spartc[clane + (15 * order + 8 * delta)] = val8;
    }
  }

  __syncthreads();
  if ((warp & 16) != 0) {
    const int cwarp = 15 * order;
    const T helpA = sfacA[tid % (warp_size * 16)];
    val0 += helpA * spartc[cwarp + (0 * delta + 0)];
    val1 += helpA * spartc[cwarp + (1 * delta + 0)];
    val2 += helpA * spartc[cwarp + (2 * delta + 0)];
    val3 += helpA * spartc[cwarp + (3 * delta + 0)];
    val4 += helpA * spartc[cwarp + (4 * delta + 0)];
    val5 += helpA * spartc[cwarp + (5 * delta + 0)];
    val6 += helpA * spartc[cwarp + (6 * delta + 0)];
    val7 += helpA * spartc[cwarp + (7 * delta + 0)];
    val8 += helpA * spartc[cwarp + (8 * delta + 0)];
    const T helpB = sfacB[tid % (warp_size * 16)];
    val0 += helpB * spartc[cwarp + (0 * delta + 1)];
    val1 += helpB * spartc[cwarp + (1 * delta + 1)];
    val2 += helpB * spartc[cwarp + (2 * delta + 1)];
    val3 += helpB * spartc[cwarp + (3 * delta + 1)];
    val4 += helpB * spartc[cwarp + (4 * delta + 1)];
    val5 += helpB * spartc[cwarp + (5 * delta + 1)];
    val6 += helpB * spartc[cwarp + (6 * delta + 1)];
    val7 += helpB * spartc[cwarp + (7 * delta + 1)];
    val8 += helpB * spartc[cwarp + (8 * delta + 1)];
    const T helpC = sfacC[tid % (warp_size * 16)];
    val0 += helpC * spartc[cwarp + (0 * delta + 2)];
    val1 += helpC * spartc[cwarp + (1 * delta + 2)];
    val2 += helpC * spartc[cwarp + (2 * delta + 2)];
    val3 += helpC * spartc[cwarp + (3 * delta + 2)];
    val4 += helpC * spartc[cwarp + (4 * delta + 2)];
    val5 += helpC * spartc[cwarp + (5 * delta + 2)];
    val6 += helpC * spartc[cwarp + (6 * delta + 2)];
    val7 += helpC * spartc[cwarp + (7 * delta + 2)];
    val8 += helpC * spartc[cwarp + (8 * delta + 2)];
    const T helpD = sfacD[tid % (warp_size * 16)];
    val0 += helpD * spartc[cwarp + (0 * delta + 3)];
    val1 += helpD * spartc[cwarp + (1 * delta + 3)];
    val2 += helpD * spartc[cwarp + (2 * delta + 3)];
    val3 += helpD * spartc[cwarp + (3 * delta + 3)];
    val4 += helpD * spartc[cwarp + (4 * delta + 3)];
    val5 += helpD * spartc[cwarp + (5 * delta + 3)];
    val6 += helpD * spartc[cwarp + (6 * delta + 3)];
    val7 += helpD * spartc[cwarp + (7 * delta + 3)];
    val8 += helpD * spartc[cwarp + (8 * delta + 3)];
    if ((warp == 31) && (clane >= 0)) {
      spartc[clane + (31 * order + 0 * delta)] = val0;
      spartc[clane + (31 * order + 2 * delta)] = val2;
      spartc[clane + (31 * order + 4 * delta)] = val4;
      spartc[clane + (31 * order + 6 * delta)] = val6;
      spartc[clane + (31 * order + 8 * delta)] = val8;
    }
  }

  __syncthreads();
 if (warp < 17) {
  val1 += sfacA[tid] * spartc[31 * order + (0 * delta + 0)];
  val3 += sfacA[tid] * spartc[31 * order + (2 * delta + 0)];
  val5 += sfacA[tid] * spartc[31 * order + (4 * delta + 0)];
  val7 += sfacA[tid] * spartc[31 * order + (6 * delta + 0)];
  val1 += sfacB[tid] * spartc[31 * order + (0 * delta + 1)];
  val3 += sfacB[tid] * spartc[31 * order + (2 * delta + 1)];
  val5 += sfacB[tid] * spartc[31 * order + (4 * delta + 1)];
  val7 += sfacB[tid] * spartc[31 * order + (6 * delta + 1)];
  val1 += sfacC[tid] * spartc[31 * order + (0 * delta + 2)];
  val3 += sfacC[tid] * spartc[31 * order + (2 * delta + 2)];
  val5 += sfacC[tid] * spartc[31 * order + (4 * delta + 2)];
  val7 += sfacC[tid] * spartc[31 * order + (6 * delta + 2)];
  val1 += sfacD[tid] * spartc[31 * order + (0 * delta + 3)];
  val3 += sfacD[tid] * spartc[31 * order + (2 * delta + 3)];
  val5 += sfacD[tid] * spartc[31 * order + (4 * delta + 3)];
  val7 += sfacD[tid] * spartc[31 * order + (6 * delta + 3)];
 }
  if ((warp == 31) && (clane >= 0)) {
    spartc[clane + (31 * order + 1 * delta)] = val1;
    spartc[clane + (31 * order + 5 * delta)] = val5;
  }

  __syncthreads();
 if (warp < 17) {
  val2 += sfacA[tid] * spartc[31 * order + (1 * delta + 0)];
  val6 += sfacA[tid] * spartc[31 * order + (5 * delta + 0)];
  val2 += sfacB[tid] * spartc[31 * order + (1 * delta + 1)];
  val6 += sfacB[tid] * spartc[31 * order + (5 * delta + 1)];
  val2 += sfacC[tid] * spartc[31 * order + (1 * delta + 2)];
  val6 += sfacC[tid] * spartc[31 * order + (5 * delta + 2)];
  val2 += sfacD[tid] * spartc[31 * order + (1 * delta + 3)];
  val6 += sfacD[tid] * spartc[31 * order + (5 * delta + 3)];
 }
  if ((warp == 31) && (clane >= 0)) {
    spartc[clane + (31 * order + 3 * delta)] = val3;
  }

  __syncthreads();
 if (warp < 17) {
  val4 += sfacA[tid] * spartc[31 * order + (3 * delta + 0)];
  val4 += sfacB[tid] * spartc[31 * order + (3 * delta + 1)];
  val4 += sfacC[tid] * spartc[31 * order + (3 * delta + 2)];
  val4 += sfacD[tid] * spartc[31 * order + (3 * delta + 3)];
 }
  if ((warp == 31) && (clane >= 0)) {
    spartc[clane + (31 * order + 7 * delta)] = val7;
  }

  __syncthreads();
 if (warp < 17) {
  val8 += sfacA[tid] * spartc[31 * order + (7 * delta + 0)];
  val8 += sfacB[tid] * spartc[31 * order + (7 * delta + 1)];
  val8 += sfacC[tid] * spartc[31 * order + (7 * delta + 2)];
  val8 += sfacD[tid] * spartc[31 * order + (7 * delta + 3)];
 }

  const int idx = tid - (block_size - order);
  if (idx >= 0) {
    fullcarry[chunk_id * order + idx] = val8;
    __threadfence();
    if (idx == 0) {
      status[chunk_id] = 2;
    }
  }

  if (chunk_id > 0) {
    __syncthreads();
    if (warp == 0) {
      const int cidm1 = chunk_id - 1;
      int flag = 1;
      do {
        if ((cidm1 - lane) >= 0) {
          flag = status[cidm1 - lane];
        }
      } while ((__any(flag == 0)) || (__all(flag != 2)));
      int mask = __ballot(flag == 2);
      const int pos = __ffs(mask) - 1;
      T fc;
      if (lane < order) {
        fc = fullcarry[(cidm1 - pos) * order + lane];
      }
      T X0 = __shfl(fc, 0);
      T X1 = __shfl(fc, 1);
      T X2 = __shfl(fc, 2);
      T X3 = __shfl(fc, 3);
      if (lane == 0) {
        sfullc[0] = X0;
        sfullc[1] = X1;
        sfullc[2] = X2;
        sfullc[3] = X3;
      }
    }

    __syncthreads();
    T X0 = sfullc[0];
    val0 += sfacA[tid] * X0;
    T X1 = sfullc[1];
    val0 += sfacB[tid] * X1;
    T X2 = sfullc[2];
    val0 += sfacC[tid] * X2;
    T X3 = sfullc[3];
    val0 += sfacD[tid] * X3;
  }

  if (chunk_id == gridDim.x - 1) {
    if (offs + (0 * block_size) < items) output[offs + (0 * block_size)] = val0;
    if (offs + (1 * block_size) < items) output[offs + (1 * block_size)] = val1;
    if (offs + (2 * block_size) < items) output[offs + (2 * block_size)] = val2;
    if (offs + (3 * block_size) < items) output[offs + (3 * block_size)] = val3;
    if (offs + (4 * block_size) < items) output[offs + (4 * block_size)] = val4;
    if (offs + (5 * block_size) < items) output[offs + (5 * block_size)] = val5;
    if (offs + (6 * block_size) < items) output[offs + (6 * block_size)] = val6;
    if (offs + (7 * block_size) < items) output[offs + (7 * block_size)] = val7;
    if (offs + (8 * block_size) < items) output[offs + (8 * block_size)] = val8;
  } else {
    output[offs + (0 * block_size)] = val0;
    output[offs + (1 * block_size)] = val1;
    output[offs + (2 * block_size)] = val2;
    output[offs + (3 * block_size)] = val3;
    output[offs + (4 * block_size)] = val4;
    output[offs + (5 * block_size)] = val5;
    output[offs + (6 * block_size)] = val6;
    output[offs + (7 * block_size)] = val7;
    output[offs + (8 * block_size)] = val8;
  }
}

struct GPUTimer
{
  cudaEvent_t beg, end;
  GPUTimer() {cudaEventCreate(&beg);  cudaEventCreate(&end);}
  ~GPUTimer() {cudaEventDestroy(beg);  cudaEventDestroy(end);}
  void start() {cudaEventRecord(beg, 0);}
  double stop() {cudaEventRecord(end, 0);  cudaEventSynchronize(end);  float ms;  cudaEventElapsedTime(&ms, beg, end);  return 0.001 * ms;}
};

int main(int argc, char *argv[])
{
  printf("Parallel Linear Recurrence Computation\n");
  printf("Copyright (c) 2018 Texas State University\n");

  if (argc != 2) {
    fprintf(stderr, "USAGE: %s problem_size\n", argv[0]);
    return -1;
  }

  const int n = atoi(argv[1]);
  if (n < 1) {fprintf(stderr, "ERROR: problem_size must be at least 1\n");  return -1;};

  int *d_status;
  T *h_in, *h_out, *h_sol, *d_in, *d_out, *d_partcarry, *d_fullcarry;

  const size_t size = n * sizeof(T);
  h_in = (T *)malloc(size);  assert(h_in != NULL);
  h_out = (T *)malloc(size);  assert(h_out != NULL);
  h_sol = (T *)malloc(size);  assert(h_sol != NULL);

  for (int i = 0; i < n; i++) {
    h_in[i] = (i & 32) / 16 - 1;
    h_sol[i] = 0;
  }
  for (int i = 0; i < n; i++) {
    if ((i - 0) >= 0) {
      h_sol[i] += 2.366700e-01f * h_in[i - 0];
    }
  }
  for (int i = 1; i < n; i++) {
    if ((i - 1) >= 0) {
      h_sol[i] += -9.840000e-03f * h_sol[i - 1];
    }
    if ((i - 2) >= 0) {
      h_sol[i] += -1.970900e-01f * h_sol[i - 2];
    }
    if ((i - 3) >= 0) {
      h_sol[i] += -1.287100e-01f * h_sol[i - 3];
    }
    if ((i - 4) >= 0) {
      h_sol[i] += -4.276600e-01f * h_sol[i - 4];
    }
  }

  cudaSetDevice(device);
  cudaDeviceProp deviceProp;
  cudaGetDeviceProperties(&deviceProp, device);

  const int SMs = deviceProp.multiProcessorCount;
  int valsperthread = 1;
  while ((valsperthread < 9) && (block_size * 2 * SMs * valsperthread < n)) {
    valsperthread++;
  }
  const int chunk_size = valsperthread * block_size;
  const int iterations = 5;

  assert(cudaSuccess == cudaMalloc(&d_in, size));
  assert(cudaSuccess == cudaMalloc(&d_out, size));
  assert(cudaSuccess == cudaMalloc(&d_status, (n + chunk_size - 1) / chunk_size * sizeof(int)));
  assert(cudaSuccess == cudaMalloc(&d_partcarry, (n + chunk_size - 1) / chunk_size * order * sizeof(T)));
  assert(cudaSuccess == cudaMalloc(&d_fullcarry, (n + chunk_size - 1) / chunk_size * order * sizeof(T)));
  assert(cudaSuccess == cudaMemcpy(d_in, h_in, size, cudaMemcpyHostToDevice));
  assert(cudaSuccess == cudaMemcpy(d_out, d_in, size, cudaMemcpyDeviceToDevice));

  cudaMemset(d_status, 0, (n + chunk_size - 1) / chunk_size * sizeof(int));
  switch (valsperthread) {
    case 1:  Recurrence1<<<(n + chunk_size - 1) / chunk_size, block_size>>>(n, d_in, d_out, d_status, d_partcarry, d_fullcarry); break;
    case 2:  Recurrence2<<<(n + chunk_size - 1) / chunk_size, block_size>>>(n, d_in, d_out, d_status, d_partcarry, d_fullcarry); break;
    case 3:  Recurrence3<<<(n + chunk_size - 1) / chunk_size, block_size>>>(n, d_in, d_out, d_status, d_partcarry, d_fullcarry); break;
    case 4:  Recurrence4<<<(n + chunk_size - 1) / chunk_size, block_size>>>(n, d_in, d_out, d_status, d_partcarry, d_fullcarry); break;
    case 5:  Recurrence5<<<(n + chunk_size - 1) / chunk_size, block_size>>>(n, d_in, d_out, d_status, d_partcarry, d_fullcarry); break;
    case 6:  Recurrence6<<<(n + chunk_size - 1) / chunk_size, block_size>>>(n, d_in, d_out, d_status, d_partcarry, d_fullcarry); break;
    case 7:  Recurrence7<<<(n + chunk_size - 1) / chunk_size, block_size>>>(n, d_in, d_out, d_status, d_partcarry, d_fullcarry); break;
    case 8:  Recurrence8<<<(n + chunk_size - 1) / chunk_size, block_size>>>(n, d_in, d_out, d_status, d_partcarry, d_fullcarry); break;
    case 9:  Recurrence9<<<(n + chunk_size - 1) / chunk_size, block_size>>>(n, d_in, d_out, d_status, d_partcarry, d_fullcarry); break;
  }
  GPUTimer timer;
  timer.start();
  for (long i = 0; i < iterations; i++) {
    cudaMemset(d_status, 0, (n + chunk_size - 1) / chunk_size * sizeof(int));
    switch (valsperthread) {
      case 1:  Recurrence1<<<(n + chunk_size - 1) / chunk_size, block_size>>>(n, d_in, d_out, d_status, d_partcarry, d_fullcarry); break;
      case 2:  Recurrence2<<<(n + chunk_size - 1) / chunk_size, block_size>>>(n, d_in, d_out, d_status, d_partcarry, d_fullcarry); break;
      case 3:  Recurrence3<<<(n + chunk_size - 1) / chunk_size, block_size>>>(n, d_in, d_out, d_status, d_partcarry, d_fullcarry); break;
      case 4:  Recurrence4<<<(n + chunk_size - 1) / chunk_size, block_size>>>(n, d_in, d_out, d_status, d_partcarry, d_fullcarry); break;
      case 5:  Recurrence5<<<(n + chunk_size - 1) / chunk_size, block_size>>>(n, d_in, d_out, d_status, d_partcarry, d_fullcarry); break;
      case 6:  Recurrence6<<<(n + chunk_size - 1) / chunk_size, block_size>>>(n, d_in, d_out, d_status, d_partcarry, d_fullcarry); break;
      case 7:  Recurrence7<<<(n + chunk_size - 1) / chunk_size, block_size>>>(n, d_in, d_out, d_status, d_partcarry, d_fullcarry); break;
      case 8:  Recurrence8<<<(n + chunk_size - 1) / chunk_size, block_size>>>(n, d_in, d_out, d_status, d_partcarry, d_fullcarry); break;
      case 9:  Recurrence9<<<(n + chunk_size - 1) / chunk_size, block_size>>>(n, d_in, d_out, d_status, d_partcarry, d_fullcarry); break;
    }
  }
  double runtime = timer.stop() / iterations;
  double throughput = 0.000000001 * n / runtime;
  assert(cudaSuccess == cudaMemcpy(h_out, d_out, size, cudaMemcpyDeviceToHost));

  for (int i = 0; i < n; i++) {
    T s = h_sol[i];
    T o = h_out[i];
    if (fabsf(o - s) > 0.001) {
      printf("result not correct at index %d: %e != %e\n", i, h_sol[i], h_out[i]);
      return -1;
    }
  }
  printf("size = %d\tthroughput = %7.4f gigaitems/s\truntime = %7.4f s\tPassed!\n", n, throughput, runtime);

  printf("first elements of result are:\n");
  for (int i = 0; (i < 8) && (i < n); i++) {
    printf(" %f", h_out[i]);
  }
  printf("\n");

  free(h_in);  free(h_out);  free(h_sol);
  cudaFree(d_in);  cudaFree(d_out);  cudaFree(d_status);  cudaFree(d_partcarry);  cudaFree(d_fullcarry);

  return 0;
}
